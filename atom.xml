<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nagisa</title>
  <subtitle>Static website deployed on Server</subtitle>
  <link href="https://love.nagisadaisuki.icu/" rel="alternate" type="text/html"/>
  <link href="https://love.nagisadaisuki.icu/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://love.nagisadaisuki.icu/</id>
  <updated>2025-12-24T06:43:31.840Z</updated>
  <language>en</language>
  <entry>
    <title>Markdown Tutorial</title>
    <link href="https://love.nagisadaisuki.icu/posts/markdown-tutorial/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/markdown-tutorial/</id>
    <published>2025-01-20T00:00:00.000Z</published>
    <updated>2025-01-20T00:00:00.000Z</updated>
    <summary>A simple example of a Markdown blog post.</summary>
    <content type="html"><![CDATA[<h1>Markdown Tutorial</h1>
<p>A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF).</p>
<ul>
<li><a href="#block-elements">Block Elements</a>
<ul>
<li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a></li>
<li><a href="#headers">Headers</a></li>
<li><a href="#blockquotes">Blockquotes</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#code-blocks">Code Blocks</a></li>
<li><a href="#horizontal-rules">Horizontal Rules</a></li>
<li><a href="#table">Table</a></li>
</ul>
</li>
<li><a href="#span-elements">Span Elements</a>
<ul>
<li><a href="#links">Links</a></li>
<li><a href="#emphasis">Emphasis</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#images">Images</a></li>
<li><a href="#strikethrough">Strikethrough</a></li>
</ul>
</li>
<li><a href="#miscellaneous">Miscellaneous</a>
<ul>
<li><a href="#automatic-links">Automatic Links</a></li>
<li><a href="#backslash-escapes">Backslash Escapes</a></li>
</ul>
</li>
<li><a href="#inline-html">Inline HTML</a></li>
</ul>
<h2>Block Elements</h2>
<h3>Paragraphs and Line Breaks</h3>
<h4>Paragraphs</h4>
<p>HTML Tag: <code>&lt;p&gt;</code></p>
<p>One or more blank lines. (A blank line is a line containing nothing but <strong>spaces</strong> or <strong>tabs</strong> is considered blank.)</p>
<p>Code:</p>
<pre><code>This will be
inline.

This is second paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be
inline.</p>
<p>This is second paragraph.</p>
<hr />
<h4>Line Breaks</h4>
<p>HTML Tag: <code>&lt;br /&gt;</code></p>
<p>End a line with <strong>two or more spaces</strong>.</p>
<p>Code:</p>
<pre><code>This will be not
inline.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be not<br />
inline.</p>
<hr />
<h3>Headers</h3>
<p>Markdown supports two styles of headers, Setext and atx.</p>
<h4>Setext</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code></p>
<p>"Underlined" using <strong>equal signs (=)</strong> as <code>&lt;h1&gt;</code> and <strong>dashes (-)</strong> as <code>&lt;h2&gt;</code> in any number.</p>
<p>Code:</p>
<pre><code>This is an H1
=============
This is an H2
-------------
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<hr />
<h4>atx</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code></p>
<p>Uses 1-6 <strong>hash characters (#)</strong> at the start of the line, corresponding to <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>.</p>
<p>Code:</p>
<pre><code># This is an H1
## This is an H2
###### This is an H6
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h6>This is an H6</h6>
<hr />
<p>Optionally, you may "close" atx-style headers. The closing hashes <strong>don't need to match</strong> the number of hashes used to open the header.</p>
<p>Code:</p>
<pre><code># This is an H1 #
## This is an H2 ##
### This is an H3 ######
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h3>This is an H3</h3>
<hr />
<h3>Blockquotes</h3>
<p>HTML Tag: <code>&lt;blockquote&gt;</code></p>
<p>Markdown uses email-style <strong>&gt;</strong> characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt;
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;.</p>
<p>Code:</p>
<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<hr />
<p>Blockquotes can contain other Markdown elements, including headers, lists, and code blocks.</p>
<p>Code:</p>
<pre><code>&gt; ## This is a header.
&gt;
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt;
&gt; Here's some example code:
&gt;
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<h2>This is a header.</h2>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here's some example code:</p>
<pre><code>return shell_exec("echo $input | $markdown_script");
</code></pre>
</blockquote>
<hr />
<h3>Lists</h3>
<p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p>
<h4>Unordered</h4>
<p>HTML Tag: <code>&lt;ul&gt;</code></p>
<p>Unordered lists use <strong>asterisks (*)</strong>, <strong>pluses (+)</strong>, and <strong>hyphens (-)</strong>.</p>
<p>Code:</p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<hr />
<p>is equivalent to:</p>
<p>Code:</p>
<pre><code>+   Red
+   Green
+   Blue
</code></pre>
<p>and:</p>
<p>Code:</p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre>
<h4>Ordered</h4>
<p>HTML Tag: <code>&lt;ol&gt;</code></p>
<p>Ordered lists use numbers followed by periods:</p>
<p>Code:</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<hr />
<p>It's possible to trigger an ordered list by accident, by writing something like this:</p>
<p>Code:</p>
<pre><code>1986. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>What a great season.</li>
</ol>
<hr />
<p>You can <strong>backslash-escape (\)</strong> the period:</p>
<p>Code:</p>
<pre><code>1986\. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<p>1986. What a great season.</p>
<hr />
<h4>Indented</h4>
<h5>Blockquote</h5>
<p>To put a blockquote within a list item, the blockquote's &gt; delimiters need to be indented:</p>
<p>Code:</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a blockquote:</p>
<blockquote>
<p>This is a blockquote
inside a list item.</p>
</blockquote>
</li>
</ul>
<hr />
<h5>Code Block</h5>
<p>To put a code block within a list item, the code block needs to be indented twice — <strong>8 spaces</strong> or <strong>two tabs</strong>:</p>
<p>Code:</p>
<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a code block:</p>
<pre><code>&lt;code goes here&gt;
</code></pre>
</li>
</ul>
<hr />
<h5>Nested List</h5>
<p>Code:</p>
<pre><code>* A
  * A1
  * A2
* B
* C
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>A
<ul>
<li>A1</li>
<li>A2</li>
</ul>
</li>
<li>B</li>
<li>C</li>
</ul>
<hr />
<h3>Code Blocks</h3>
<p>HTML Tag: <code>&lt;pre&gt;</code></p>
<p>Indent every line of the block by at least <strong>4 spaces</strong> or <strong>1 tab</strong>.</p>
<p>Code:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a normal paragraph:</p>
<pre><code>This is a code block.
</code></pre>
<hr />
<p>A code block continues until it reaches a line that is not indented (or the end of the article).</p>
<p>Within a code block, <strong><em>ampersands (&amp;)</em></strong> and angle <strong>brackets (&lt; and &gt;)</strong> are automatically converted into HTML entities.</p>
<p>Code:</p>
<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>&lt;div class="footer"&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>
<hr />
<p>Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block.</p>
<h4>Fenced Code Blocks</h4>
<p>Just wrap your code in <code>```</code> (as shown below) and you won't need to indent it by four spaces.</p>
<p>Code:</p>
<pre><code>Here's an example:

```
function test() {
  console.log("notice the blank line before this function?");
}
```
</code></pre>
<p>Preview:</p>
<hr />
<p>Here's an example:</p>
<pre><code>function test() {
  console.log("notice the blank line before this function?");
}
</code></pre>
<hr />
<h4>Syntax Highlighting</h4>
<p>In your fenced block, add an optional language identifier and we'll run it through syntax highlighting (<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">Support Languages</a>).</p>
<p>Code:</p>
<pre><code>```ruby
require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
```
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
</code></pre>
<hr />
<h3>Horizontal Rules</h3>
<p>HTML Tag: <code>&lt;hr /&gt;</code>
Places <strong>three or more hyphens (-), asterisks (*), or underscores (_)</strong> on a line by themselves. You may use spaces between the hyphens or asterisks.</p>
<p>Code:</p>
<pre><code>* * *
***
*****
- - -
---------------------------------------
___
</code></pre>
<p>Preview:</p>
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<h3>Table</h3>
<p>HTML Tag: <code>&lt;table&gt;</code></p>
<p>It's an extension.</p>
<p>Separates column by <strong>pipe (|)</strong> and header by <strong>dashes (-)</strong>, and uses <strong>colon (:)</strong> for alignment.</p>
<p>The outer <strong>pipes (|)</strong> and alignment are optional. There are <strong>3 delimiters</strong> each cell at least for separating header.</p>
<p>Code:</p>
<pre><code>| Left | Center | Right |
|:-----|:------:|------:|
|aaa   |bbb     |ccc    |
|ddd   |eee     |fff    |

 A | B
---|---
123|456


A |B
--|--
12|45
</code></pre>
<p>Preview:</p>
<hr />
<table>
<thead>
<tr>
<th>Left</th>
<th>Center</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>aaa</td>
<td>bbb</td>
<td>ccc</td>
</tr>
<tr>
<td>ddd</td>
<td>eee</td>
<td>fff</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>456</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>45</td>
</tr>
</tbody>
</table>
<hr />
<h2>Span Elements</h2>
<h3>Links</h3>
<p>HTML Tag: <code>&lt;a&gt;</code></p>
<p>Markdown supports two style of links: inline and reference.</p>
<h4>Inline</h4>
<p>Inline link format like this: <code>[Link Text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> inline link.</p>
<p><a href="http://example.net/">This link</a> has no title attribute.</p>
<hr />
<p>If you're referring to a local resource on the same server, you can use relative paths:</p>
<p>Code:</p>
<pre><code>See my [About](/about/) page for details.
</code></pre>
<p>Preview:</p>
<hr />
<p>See my <a href="/about/">About</a> page for details.</p>
<hr />
<h4>Reference</h4>
<p>You could predefine link references. Format like this: <code>[id]: URL "Title"</code></p>
<p>Title is also optional. And the you refer the link, format like this: <code>[Link Text][id]</code></p>
<p>Code:</p>
<pre><code>[id]: http://example.com/  "Optional Title Here"
This is [an example][id] reference-style link.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> reference-style link.</p>
<hr />
<p>That is:</p>
<ul>
<li>Square brackets containing the link identifier (<strong>not case sensitive</strong>, optionally indented from the left margin using up to three spaces);</li>
<li>followed by a colon;</li>
<li>followed by one or more spaces (or tabs);</li>
<li>followed by the URL for the link;</li>
<li>The link URL may, optionally, be surrounded by angle brackets.</li>
<li>optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses.</li>
</ul>
<p>The following three link definitions are equivalent:</p>
<p>Code:</p>
<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
[foo]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>
<p>Uses an empty set of square brackets, the link text itself is used as the name.</p>
<p>Code:</p>
<pre><code>[Google]: http://google.com/
[Google][]
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://google.com/">Google</a></p>
<hr />
<h3>Emphasis</h3>
<p>HTML Tags: <code>&lt;em&gt;</code>, <code>&lt;strong&gt;</code></p>
<p>Markdown treats <strong>asterisks (*)</strong> and <strong>underscores (_)</strong> as indicators of emphasis. <strong>One delimiter</strong> will be <code>&lt;em&gt;</code>; *<em>double delimiters</em> will be <code>&lt;strong&gt;</code>.</p>
<p>Code:</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>
<p>Preview:</p>
<hr />
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<hr />
<p>But if you surround an * or _ with spaces, it'll be treated as a literal asterisk or underscore.</p>
<p>You can backslash escape it:</p>
<p>Code:</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*this text is surrounded by literal asterisks*</p>
<hr />
<h3>Code</h3>
<p>HTML Tag: <code>&lt;code&gt;</code></p>
<p>Wraps it with <strong>backtick quotes (`)</strong>.</p>
<p>Code:</p>
<pre><code>Use the `printf()` function.
</code></pre>
<p>Preview:</p>
<hr />
<p>Use the <code>printf()</code> function.</p>
<hr />
<p>To include a literal backtick character within a code span, you can use <strong>multiple backticks</strong> as the opening and closing delimiters:</p>
<p>Code:</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre>
<p>Preview:</p>
<hr />
<p><code>There is a literal backtick (`) here.</code></p>
<hr />
<p>The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span:</p>
<p>Code:</p>
<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>
<p>Preview:</p>
<hr />
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<hr />
<h3>Images</h3>
<p>HTML Tag: <code>&lt;img /&gt;</code></p>
<p>Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference.</p>
<h4>Inline</h4>
<p>Inline image syntax looks like this: <code>![Alt text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" /></p>
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title" /></p>
<hr />
<p>That is:</p>
<ul>
<li>An exclamation mark: !;</li>
<li>followed by a set of square brackets, containing the alt attribute text for the image;</li>
<li>followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes.</li>
</ul>
<h4>Reference</h4>
<p>Reference-style image syntax looks like this: <code>![Alt text][id]</code></p>
<p>Code:</p>
<pre><code>[img id]: https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp  "Optional title attribute"
![Alt text][img id]
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title attribute" /></p>
<hr />
<h3>Strikethrough</h3>
<p>HTML Tag: <code>&lt;del&gt;</code></p>
<p>It's an extension.</p>
<p>GFM adds syntax to strikethrough text.</p>
<p>Code:</p>
<pre><code>~~Mistaken text.~~
</code></pre>
<p>Preview:</p>
<hr />
<p><s>Mistaken text.</s></p>
<hr />
<h2>Miscellaneous</h2>
<h3>Automatic Links</h3>
<p>Markdown supports a shortcut style for creating "automatic" links for URLs and email addresses: simply surround the URL or email address with angle brackets.</p>
<p>Code:</p>
<pre><code>&lt;http://example.com/&gt;

&lt;address@example.com&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://example.com/">http://example.com/</a></p>
<p><a href="mailto:address@example.com">address@example.com</a></p>
<hr />
<p>GFM will autolink standard URLs.</p>
<p>Code:</p>
<pre><code>https://github.com/emn178/markdown
</code></pre>
<p>Preview:</p>
<hr />
<p>https://github.com/emn178/markdown</p>
<hr />
<h3>Backslash Escapes</h3>
<p>Markdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown's formatting syntax.</p>
<p>Code:</p>
<pre><code>\*literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*literal asterisks*</p>
<hr />
<p>Markdown provides backslash escapes for the following characters:</p>
<p>Code:</p>
<pre><code>\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
</code></pre>
<h2>Inline HTML</h2>
<p>For any markup that is not covered by Markdown's syntax, you simply use HTML itself. There's no need to preface it or delimit it to indicate that you're switching from Markdown to HTML; you just use the tags.</p>
<p>Code:</p>
<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a regular paragraph.</p>
<p>&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;Foo&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</p>
<p>This is another regular paragraph.</p>
<hr />
<p>Note that Markdown formatting syntax is <strong>not processed within block-level HTML tags</strong>.</p>
<p>Unlike block-level HTML tags, Markdown syntax is <strong>processed within span-level tags</strong>.</p>
<p>Code:</p>
<pre><code>&lt;span&gt;**Work**&lt;/span&gt;

&lt;div&gt;
    **No Work**
&lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p>&lt;span&gt;<strong>Work</strong>&lt;/span&gt;</p>
<p>&lt;div&gt;
<strong>No Work</strong>
&lt;/div&gt;</p>
<hr />
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Examples"></category>
  </entry>
  <entry>
    <title>C与指针笔记</title>
    <link href="https://love.nagisadaisuki.icu/posts/c/c_pointer/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/c/c_pointer/</id>
    <published>2025-09-21T00:00:00.000Z</published>
    <updated>2025-09-21T00:00:00.000Z</updated>
    <summary>我去是C语言大佬!?</summary>
    <content type="html"><![CDATA[<p>&lt;h1&gt;&lt;center&gt;快速上手&lt;/center&gt;&lt;/h1&gt;</p>
<hr />
<h2>1.1.1 空白和注释</h2>
<ol>
<li>遵守一些规定会让C语言代码变得更加容易阅读和修改</li>
<li>注释告诉读者程序能做些什么</li>
<li>使用#if和#endif预处理有效地将代码从程序中去除</li>
</ol>
<pre><code>#if 0       //条件(真执行，假不执行)
    statements
#endif
</code></pre>
<h2>1.1.2 预处理指令</h2>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX_COLS 20
#define MAX_INPUT 1000 
</code></pre>
<p>| 这五行被称为预处理指令，因为它们是由预处理器解释的。</p>
<pre><code>int read_column_numbers(int columns[], int max);
void rearrange(char *output, char const *input,
                int n_columns, int const columns[]);
</code></pre>
<p>| 这些声明被称为<strong>函数原型(function prototype)</strong>。它告诉编译器这些以后将在源文件中定义的函数的特征。</p>
<h2>1.1.3 main函数</h2>
<p><strong>每个C程序都必须有一个main函数，因为它是程序执行的起点。</strong></p>
<p>&lt;code&gt;n_columns = read_column_numbers(columns,MAX_COLS);&lt;/code&gt;</p>
<blockquote>
<p>这条语句调用函数read_column_numbers。数组columns和MAX_COLS代表的常量20作为参数传递给这个函数。在C语言中，数组参数是以 <strong>引用(reference)</strong> 传递的，也就是传址调用，而标量和常量则是按 <strong>值(value)</strong> 传递的。</p>
</blockquote>
<h2>1.1.4 关于scanf的格式代码</h2>
<p>常用的scanf格式代码除了<code>%c,%s</code>以外在输入值前的空白都会被省略。所以在使用scanf函数中的格式代码%c,%s输入时不能在输入值前有空格、换行和tab</p>
<p>&lt;h1&gt;&lt;center&gt;基本概念&lt;/center&gt;&lt;/h1&gt;</p>
<hr />
<h2>2.1 环境</h2>
<p>在ANSI C的任何一种实现中存在两种不同的环境
&lt;/br&gt;
一种是<strong>翻译环境(translation environment)</strong>，在这个环境源代码被转换为可执行的机器指令。
&lt;/br&gt;
一种是<strong>执行环境(execution environment)</strong>，用于实际执行代码</p>
<h2>2.1.1 翻译</h2>
<p>翻译过程：编辑源文件-&gt;对源文件进行编译-&gt;对编译好的目标文件和链接器捆绑到一起-&gt;形成可执行程序
&lt;/br&gt;
编译过程： <strong>预处理器(preprocessor)</strong> 处理-&gt; <strong>源代码解析(parse)</strong> 处理-&gt;产生目标代码( <strong>优化器(optimizer)</strong> 会对目标代码进一步处理)</p>
<h2>2.1.2 执行</h2>
<p>程序必须载入到内存中(具有操作系统由操作系统执行)，无操作系统时必须手动载入</p>
<hr />
<p>在 C 语言的翻译过程中，通常的顺序是：</p>
<p>预处理（Preprocessing）：
这一步会处理所有的宏定义（#define）、头文件包含（#include）以及条件编译（#if）等指令。预处理器生成一个扩展后的 C 代码，这个阶段的产物是一个没有预处理指令的纯 C 源代码。</p>
<p>编译（Compilation）：
在这一阶段，编译器将预处理后的 C 代码转换成汇编语言代码。编译器主要做语法分析、语义分析、优化等工作。最终生成的是与特定平台相关的汇编代码文件（通常以 .s 为后缀）。</p>
<p>汇编（Assembly）：
汇编器将编译生成的汇编代码转换成机器码，生成目标文件（通常以 .o 或 .obj 为后缀）。目标文件包含机器指令，但没有完整的可执行程序所需的所有内容。</p>
<p>链接（Linking）：
链接器将多个目标文件和库文件合并，解决符号（如函数和变量的地址）之间的依赖关系，最终生成可执行文件（如 .exe 或没有后缀的文件）。如果有外部库函数或其他目标文件，链接器会将它们合并成一个完整的可执行程序。</p>
<p>总结起来，C 语言的翻译过程是：</p>
<p>预处理</p>
<p>编译（生成汇编代码）</p>
<p>汇编（生成目标文件）</p>
<p>链接（生成可执行文件）</p>
<p>所以，是先编译再汇编，然后通过汇编生成目标文件，最后由链接器生成可执行程序。</p>
<hr />
<h2>2.2 词法规则</h2>
<p>词法规则就是<strong>标记(token)</strong></p>
<h2>2.2.1 字符</h2>
<p>使用<strong>转义序列(escape sequence)<strong>和</strong>字符转义(character escape)</strong> 对上下文环境中特定字符表示</p>
<p>常见的有<code>\? \" \' \\</code>和<code>\a \b \f \n \r \t \v</code></p>
<p>用于表示八进制和十六进制的转义符有
<code>\ddd \xddd</code></p>
<h2>2.2.2 注释</h2>
<p>注意跨越多行的注释</p>
<h2>2.2.3 自由形式的源代码</h2>
<p>c格式相对自由，相邻的标记之间有一个或多个空白</p>
<h2>2.2.4 标识符(identifier)</h2>
<p>标识符就是变量、函数、类型等的名字，由大小写字母、数字和下划线组成，不能以数字开头。有<strong>32</strong>个关键字</p>
<h2>2.2.5 程序的形式</h2>
<p>一个C程序的源文件应该包含一组相关的函数，这是C程序较为合理的组织形式。</p>
<hr />
<h2>2.3 程序风格</h2>
<p>C 语言程序风格（Coding Style）是指在编写 C 语言代码时，为了提高可读性、可维护性和可扩展性而遵循的一些规范和约定。良好的程序风格可以让代码更加清晰，减少错误，并便于团队协作。以下是一些常见的 C 语言编程风格规范：</p>
<h3>1. 代码缩进</h3>
<p>使用统一的缩进风格。常见的缩进方法有<strong>空格缩进</strong>（通常是 4 个空格）和 <strong>制表符缩进</strong>（Tab 键）。</p>
<p>推荐： 一般来说，现代 C 编程习惯推荐使用 4 个空格进行缩进，避免混用空格和制表符。</p>
<pre><code>int main(){
    if(condition){
        // statements
    }
}
</code></pre>
<h3>2. 大括号风格</h3>
<p>K&amp;R风格（Kernighan &amp; Ritchie）和 Allman风格 是常见的大括号样式。建议选择一致的风格。</p>
<p>推荐： K&amp;R 风格通常更简洁，常用于 C 语言。即大括号 "{}" 在同一行。</p>
<p>示例（K&amp;R 风格）：</p>
<pre><code>if(condition){
    // 代码块
} else {
    // 代码块
}
</code></pre>
<h3>3.命名规范</h3>
<p>变量、函数、宏、结构体等命名应有一致性，且能清楚地表达含义。</p>
<p>推荐：</p>
<p>变量使用小写字母，单词之间用下划线分隔，如 int total_count;。</p>
<p>函数使用小写字母，多个单词之间使用下划线分隔，如 int calculate_area(int width, int height);。</p>
<p>宏常量使用全大写字母，单词之间用下划线分隔，如 #define MAX_BUFFER_SIZE 1024。</p>
<p>结构体和 类型常使用大写开头的驼峰式命名，如 typedef struct Student Student;。</p>
<h2>2.4 总结</h2>
<ul>
<li>一个C程序的代码保存在一个或多个源文件中，但一个函数只能完整地出现在同一个源文件中。把相关函数放在同一个文件内是一种好策略。</li>
<li></li>
</ul>
<p>&lt;h1&gt;&lt;center&gt;数据&lt;/center&gt;&lt;/h1&gt;</p>
<hr />
<h2>3.1 基本数据类型</h2>
<ul>
<li>在C语言中，只有四种基本数据类型：<strong>整形、浮点型、指针和聚合类型(数组和结构)</strong></li>
</ul>
<blockquote>
<p>字符型是整型的一种</p>
</blockquote>
<h2>3.1.1 整型家族</h2>
<p>分为字符型、短整型、整型和长整型，且分为有符号(signed)和无符号(unsigned)</p>
<ul>
<li><strong>长整型至少应该和整型一样长，整型至少应该和短整型一样长。</strong></li>
<li>如果显示地把变量声明为signed或unsigned可以提高这类程序的可移植性。</li>
</ul>
<p>1.整型字面值</p>
<p><strong>字面值(literal)</strong> 这个术语是字面值常量的缩写————这是一种实体，指定了自身的值并且不允许发生改变。所以ANSI C允许 <strong>命名常量const</strong></p>
<p>在整数值后面添加l或L将整数解释为长整型值、u或U将数值指定为unsigned整型值。ul和UL就是这两个的结合</p>
<p>对于多字节字符如果一个多字节字符常量的前面有一个L那么它就是**宽字符常量(wide character literal)**如：
<code>L'X' L'e^'</code></p>
<p>不管采用何种字符集，使用字符常量所产生的总是正确的值，所以字符常量能提高程序的可移植性</p>
<p>2.枚举类型</p>
<p><strong>枚举(enumerated)类型</strong>就是指它的值为符号常量而不是字面值的类型</p>
<pre><code>enum Jar_Type { CUP, PINT, QUART, HALF_GALLON, GALLON}; //声明了一个enum类型称为Jar_Type
enum { CUP, PINT, QUART, HALF_GALLON, GALLON} milk_jug,gas_can; // 匿名枚举类型并直接定义枚举类型变量 milk_jug,gas_can
enum Jar_Type { CUP = 8, PINT = 10, QUART = 11, HALF_GALLON, GALLON};
// 根据enum赋值规律，HALF_GALLON的值为12，GALLON为13
</code></pre>
<h2>3.1.2 浮点类型</h2>
<p>浮点数字面值在缺省情况下都是double类型的，后跟L为long double，跟F为float</p>
<h2>3.1.3 指针</h2>
<ol>
<li>指针常量</li>
</ol>
<p>指针常量只能通过已分配的内存的元素得知。&lt;/br&gt;
因此，把指针常量表达为数值字面值的形式几乎没有用处。</p>
<ol>
<li>字符串常量</li>
</ol>
<p>可以把字符串常量赋值给一个指向字符类型的数组char* &lt;/br&gt;
不能把字符串常量赋值给一个字符数组char[]</p>
<h2>3.2 基本声明</h2>
<p>变量声明的基本形式是：<code>说明符(一个或多个) 声明表达式列表</code></p>
<p><code>int* a,b,c和int *a,*b,*c</code>是在声明指针时非常容易搞混的两个概念，为避免概念上的错误建议将*号写在靠近变量名那一侧</p>
<h2>3.2.4 隐式声明</h2>
<p>一条语句实际上是一个声明时，如果它缺少类型名，编译器会假定它为整型</p>
<blockquote>
<p>依赖隐式声明不是一个好主意</p>
</blockquote>
<h2>3.3 typedef</h2>
<p>typedef 为数据类型定义新名字</p>
<pre><code>char *ptr_to_char; 是一个指向字符的指针
在添加关键字typedef后
typedef char* ptr_to_char;
这个声明把标识符ptr_to_char 作为指向字符的指针类型的新名字
ptr_to_char a; 声明a是一个指向字符的指针
</code></pre>
<ul>
<li>在定义函数指针或指向数组的指针时使用typedef更为合适。</li>
</ul>
<h2>3.4 常量</h2>
<p>对于普通的数据类型来说
<code>int const a; 和 const int a;</code>没有什么区别，因为对于整型只有值会变成常量</p>
<p>但是对于指针来说有两种东西可能成为常量：‘<strong>指针变量</strong>’和‘<strong>指针所指向的实体</strong>’</p>
<pre><code>int *pi; 是一个普通的指向整型的指针
而
int const *pci;
则是一个指向整型常量的指针，可以修改指针的值但不能修改它所指向的值
相比之下
int *const pci; 
则是一个指向整型的常量指针。此时指针是常量，它的值无法修改，但是可以修改它所指向的整型的值。
</code></pre>
<hr />
<p>在 C 语言中，“指向整型的常量指针”和“指向常量整型的指针”是两个非常常见的概念，它们在语法和使用上有所不同。下面我会分别讲解这两者的含义：</p>
<ol>
<li>指向整型常量的指针（<code>const int *ptr</code> 或 <code>int const *ptr</code>）
这种指针类型表示 指针指向的数据是常量，即指针指向的 整型数据不可修改，但是指针本身可以修改，使其指向不同的地址。</li>
</ol>
<pre><code>int a = 10;
int b = 20;
int const *ptr = &amp;a; // 或者 const int *ptr = &amp;a;
*ptr = 15; // 错误，不能修改指向的数据
ptr = &amp;b; // 正确，指针本身可以修改
</code></pre>
<ol>
<li>指向整型的常量指针（int *const ptr）
这种指针类型表示 指针本身是常量，即指针的值（即它指向的地址）不可修改，但是指针指向的 整型数据 是可以修改的。</li>
</ol>
<pre><code>int a = 10;
int b = 20;
int *const ptr = &amp;a; *ptr = 15; // OK，指向的值可以修改
ptr = &amp;b; // 错误，不能修改指针的地址(指针本身是常量)
</code></pre>
<ol>
<li>两者结合使用（const int<em>const ptr 或 int const</em> const ptr）
如果同时声明指针是常量且指向的数据是常量，那么就变成了“常量指针指向常量数据”。</li>
</ol>
<pre><code>int a = 10;
const int* const ptr = &amp;a;

*ptr = 15;  // 错误！不能修改指向的数据
ptr = &amp;b;   // 错误！不能修改指针本身
</code></pre>
<h2>3.5 作用域(scope)</h2>
<h2>3.5.1 代码块作用域</h2>
<p>特殊情况类似内层代码和外层代码拥有同一个标识符名字内层的标识符会隐藏外层的标识符</p>
<blockquote>
<p>应该避免在嵌套的代码块中出现相同的变量名</p>
</blockquote>
<h2>3.6 链接属性</h2>
<p>链接属性一共有三种：<strong>external(外部)、internal(内部)和none(无)</strong></p>
<ol>
<li>外部链接（External Linkage）
具有外部链接的符号可以在整个程序的多个翻译单元中访问。它意味着符号可以在一个文件中声明，并在其他文件中定义或使用。</li>
</ol>
<p>全局变量：如果在一个文件中声明了全局变量，并在其他文件中引用该变量，它会具有外部链接。</p>
<p>外部函数：同样地，外部函数可以在一个文件中定义，并在其他文件中调用。</p>
<p>示例：</p>
<pre><code>// file1.c 
#include &lt;stdio.h&gt;

int global_var = 10; // 外部链接
void func()
{
    printf("Hello World!\n");
}

// file2.c 
extern int global_var; //声明具有外部链接的变量
extern void func(); // 声明外部函数

int main()
{
    func();
    printf("Global variable: %d\n",global_var);
    return 0;
}
</code></pre>
<ul>
<li><code>global_var</code>和<code>func()</code>都具有外部链接，可以在file2.c中访问</li>
</ul>
<ol>
<li>内部链接（Internal Linkage）
具有内部链接的符号只能在同一翻译单元（即同一源文件及其包含的头文件）中访问。它们不能跨文件使用。</li>
</ol>
<p>static 关键字：使用 static 关键字声明的变量或函数具有内部链接。它意味着该符号的作用域仅限于当前源文件。</p>
<p>示例：</p>
<pre><code>// file1.c 
#include &lt;stdio.h&gt;
static int internal_var = 10; // 内部链接，只能在file1.c中使用
static void internal_func(){
    // 内部链接，只能在file1.c中调用
    printf("This is an internal function\n");
}

int main()
{
    internal_func();
    printf("Internal variable: %d\n",internal_var);
    return 0;
}

// file2.c 
extern void internal_func(); // 无法调用，因为internal_func在file1.c中是静态的
extern int internal_var; // 无法访问，因为internal_var是静态的
</code></pre>
<ul>
<li><code>internal_var</code>和<code>internal_func()</code>只能在file1.c中使用，其他文件无法访问它们</li>
</ul>
<ol>
<li>无链接（No Linkage）
没有链接的符号意味着它们在某个特定范围内是唯一的，通常这些符号仅限于局部作用域。局部变量和函数的参数一般都是无链接的。</li>
</ol>
<p>局部变量：它们的作用域仅限于函数内部，其他函数无法访问。</p>
<p>示例：</p>
<pre><code>void func() {
    int local_var = 10;  // 无链接，仅在func内部有效
    printf("Local variable: %d\n", local_var);
}

int main() {
    func();
    // 下面的代码会导致错误，因为local_var在main函数外不可见
    // printf("Local variable in func: %d\n", local_var);
    return 0;
}
</code></pre>
<ul>
<li><code>local_var</code>只能在<code>func()</code>内部使用，其他地方无法访问</li>
</ul>
<p>总结：</p>
<p><strong>外部链接（External Linkage）</strong>：符号可以在多个翻译单元（源文件）之间共享。通过 <code>extern</code> 关键字进行声明。</p>
<p><strong>内部链接（Internal Linkage）</strong>：符号仅在当前源文件内有效，不能跨文件访问。通过 <code>static</code> 关键字来定义。</p>
<p><strong>无链接（No Linkage）</strong>：符号仅在局部作用域内有效，通常用于函数参数和局部变量。</p>
<pre><code>static int i;
int func()
{
    int j;
    extern int k;
    extern int i; 
}
</code></pre>
<ul>
<li>当<code>extern</code>关键字用于源文件中一个标识符的第一次声明时，它指定该标识符具有external链接属性。但是如上面所示在int i一开始声明了static后并不会在func内部修改extern int i为external链接属性</li>
</ul>
<h2>3.7 存储类型</h2>
<p>有三个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。</p>
<ul>
<li>凡是在任何代码块之外的声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为静态(static)变量</li>
<li>在代码块内部声明的变量的缺省存储类型是自动的(automatic)，也就是说它存储于堆栈中，称为自动(auto)变量</li>
<li>对于在代码块内部声明的变量如果给它加上关键字static，可以使它的存储类型从自动变为静态。函数的形参不能声明为静态，因为实参总是在堆栈中传递给函数</li>
<li>关键字register可以用于自动变量的声明，声明变量应该存储于机器的硬件寄存器而不是内存</li>
</ul>
<p><strong>初始化</strong></p>
<ul>
<li>(P44)自动变量初始化和静态变量初始化存在一个重要的差别。</li>
</ul>
<blockquote>
<p>在静态变量初始化中我们可以把可执行程序想要初始化的值放在当程序执行时变量将会使用的位置。</p>
</blockquote>
<blockquote>
<p>自动变量的初始化需要更多的开销,因为当程序链接时还无法判断自动变量的存储位置，事实上函数的局部变量在函数的每次调用时都可能占据不同的位置</p>
</blockquote>
<blockquote>
<p><strong>自动变量的初始化较之赋值语句效率并无提高</strong>，除了声明为<code>const</code>的变量之外这两者只有风格之差，并无效率之别。</p>
</blockquote>
<blockquote>
<p>优点是由于初始化在运行时执行因此可以用任何表达式作为初始化值，例如：</p>
</blockquote>
<pre><code>int
func(int a)
{
    int b = a + 2;
}
</code></pre>
<blockquote>
<p>最后一个后果是除非对自动变量进行显式的初始化，否则当自动变量创建时，它们的值总是垃圾。</p>
</blockquote>
<h2>3.8 static关键字</h2>
<p>当用于函数定义时，或者用于代码块之外的变量声明时，static关键字用于修改标识符的连接属性(从external 改为 internal)，但标识符的存储类型和作用域不受影响。</p>
<p>用于代码块内部的变量声明时static关键字用于修改变量的存储类型，从自动变量改为静态变量，但变量的链接属性和作用域不受影响。</p>
<h2>3.10 总结</h2>
<ul>
<li>具有external链接属性的实体总是具有静态存储类型</li>
<li>如果一个变量声明于代码块内部，在它前面添加extern关键字将使它所引用的是全局变量而不是局部变量。</li>
</ul>
<p>&lt;h1&gt;&lt;center&gt;语句&lt;/center&gt;&lt;/h1&gt;</p>
<hr />
<h2>4.1 空语句</h2>
<p><code>;</code>空语句本身不执行任何任务</p>
<h2>4.2 表达式语句</h2>
<p>只要在表达式后面加上一个分号，就可以把表达式转变为语句</p>
<pre><code>x = y + 3;
ch = getchar();
</code></pre>
<p>是表达式语句</p>
<blockquote>
<p>类似于printf函数这类没有返回值的函数在标准输出中输出内容的作用称为副作用(side effect)</p>
</blockquote>
<h2>4.3 代码块</h2>
<ul>
<li>一对花括号之内的可选的声明和语句列表</li>
</ul>
<pre><code>{
    declarations
    statements
}
</code></pre>
<h2>4.4 if语句</h2>
<ul>
<li>C 并不具备布尔类型而是用整型来替代</li>
<li>else语句从属于最靠近它的不完整的if语句</li>
</ul>
<h2>4.5 while语句</h2>
<p>..............</p>
<h2>4.9 goto语句</h2>
<p><code>goto 语句标签;</code></p>
<ol>
<li>资源清理和错误处理(C中没有异常机制)</li>
</ol>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int func()
{
    int *p = malloc(100);
    if(!p) goto fail;
    
    FILE *fp = fopen("file.txt","r");
    if(!fp) goto cleanup;
    
    // 正常执行逻辑
    fclose(fp);
    free(p);
    return 0;
cleanup:
    free(p);
fail:
    return -1;
}
</code></pre>
<ol>
<li>从多层嵌套中快速跳出</li>
</ol>
<pre><code>for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 5; ++j) {
        if (i + j == 6) goto done;
    }
}
done:
printf("Exited nested loops\n");
</code></pre>
<p>goto 是 C 的原始控制流工具，能<strong>跳到代码中的任意标签</strong>；</p>
<p>不推荐<strong>滥用</strong>，但在特定情况下（如资源清理、退出多层嵌套）是非常有效的；</p>
<p>如果你在写<strong>可读性强、模块化的现代代码</strong>，能不用就尽量不用；</p>
<p>如果你在写<strong>驱动、内核、嵌入式或老式 C 代码</strong>，合理使用是完全 OK 的。</p>
<h2>4.10 总结</h2>
<p>&lt;h1&gt;&lt;center&gt;操作符和表达式&lt;/center&gt;&lt;/h1&gt;</p>
<h2>5.1 运算符</h2>
<ul>
<li>算数运算符(右结合)</li>
</ul>
<p><code>+ - * / %</code>除了<code>%</code>其他的操作符都适用于整型和浮点型</p>
<ul>
<li>移位操作符(右结合)</li>
</ul>
<p><code>&lt;&lt; &gt;&gt;</code>左移和右移操作符
左移右边多出来填充0，右移左边多出来填充0或1(具体看是逻辑运算还是算数运算（符号位1填1，符号位0填0）)</p>
<blockquote>
<p><code>a &lt;&lt; -5</code>左移-5位是什么意思其实不重要，结果是由编译器决定的，且其结果无意义，不能在程序中出现这种情况</p>
</blockquote>
<ul>
<li>位操作符(右结合)</li>
</ul>
<p><code>&amp; | ^</code>分别执行与或和异或操作</p>
<p>或操作符与左移操作符结合：</p>
<pre><code>int value = 0b00001010;
int bit_number = 1;
value = value | (1 &lt;&lt; bit_number);
// 即 value = 0b00001010 | ob00000010 = 0b00001010 （值没有发生改变）
bit_number = 2;
value = value | (1 &lt;&lt; bit_number);
// 即：value = 0b00001010 | 0b00000100 = 0b00001110 （值变成 14）
</code></pre>
<ul>
<li>赋值符和复合赋值符(左结合)</li>
</ul>
<p>可以用复合赋值符改写上面的操作</p>
<pre><code>value |= 1 &lt;&lt; bit_number;
value &amp;= 1 &lt;&lt; bit_number;
</code></pre>
<ul>
<li>单目运算符(左结合)</li>
</ul>
<p><code>~</code>操作符对二进制数进行求补操作，操作数原为1则为0，原为 0则为1</p>
<p><code>&amp;</code>操作符为取址符</p>
<p><code>*</code>间接访问操作符</p>
<p><code>sizeof()</code>判断操作数类型长度</p>
<p>&lt;h1&gt;&lt;center&gt;指针&lt;/center&gt;&lt;/h1&gt;</p>
<h2>6.1 内存和地址</h2>
<p>我们对两件事情感兴趣：</p>
<ul>
<li>内存中的每个位置由一个独一无二的地址标识：</li>
<li>内存中的每个位置都包含一个值：</li>
</ul>
<blockquote>
<p>名字与内存位置之间的关联并不是硬件提供的，而是由编译器为我们实现的。</p>
</blockquote>
<p><strong>硬件仍然通过地址访问内存位置。</strong></p>
<h2>6.2 值和类型</h2>
<ul>
<li><strong>不能简单地通过检查一个值的位来判断它的类型。</strong></li>
</ul>
<pre><code>int a = 112;
float b = 3.14;
int *c = &amp;a;
int *d = &amp;b;
</code></pre>
<p>在这上面变量a被解释为整型值，但b存储的为浮点值，在内存中却可能被解释为整型值，变成一个非常大的整型值。由于解释方法不同有可能被解释为整数<code>1078523331</code>。</p>
<blockquote>
<p>大部分情况编译器会帮助我们避免这些错误。当程序访问时编译器就会产生浮点型指令。</p>
</blockquote>
<h2>6.3 指针变量的内容</h2>
<p>上面的变量c和d为指针，指针初始化是用<code>&amp;</code>操作符完成的，该操作数用于产生操作数的内存地址。</p>
<p>区分变量c、d的地址和c、d存储的内容是非常重要的。c、d存储的内容为a、b的地址，c、d的地址为变量自身在内存中的地址。</p>
<h2>6.4 间接访问操作符</h2>
<p><code>*</code>操作符执行<strong>间接访问(idirection)</strong> 或 <strong>解引用(dereferencing the pointer)</strong>。</p>
<h2>6.5 未初始化和非法的指针</h2>
<pre><code>int *a;
*a = 12;
</code></pre>
<blockquote>
<p>a指向了哪里，我们声明了这个变量但是未对他进行初始化，所以没有办法预测12这个值将存储于什么地方。</p>
<blockquote>
<p><em>无论是哪种情况声明一个指向整型的指针都不会“创建”用于存储整型值的内存空间。</em></p>
</blockquote>
<p>所以程序执行这个赋值操作，有可能：</p>
<p><strong>1.</strong> a的初始值会是个非法地址，这样赋值语句将会出错，从而终止程序。在UNIX系统上这个错误被称为 <em>“段违例”(segmentation violation)</em> 或 <em>内存错误(memory fault)</em>。它提示程序试图访问一个并未分配给程序的内存空间。</p>
<p><strong>2.</strong> 对于那些要求整数必须存储于特定边界的机器而言，如果这种类型的数据在内存中的存储地址处于错误的边界上，那么对这个地址进行访问时将会产生一个错误。这个错误在UNIX系统中被称为 <em>总线错误(bus error)</em> 。</p>
<p><strong>3.</strong> 一种更为严重的情况是，这个指针偶尔可能包含了一个合法的地址。接下来的事情很简单：<strong>位于那个位置的值被修改！</strong></p>
</blockquote>
<h2>6.6 NULL指针</h2>
<p>要使一个指针变量为NULL可以给它赋一个零值。</p>
<blockquote>
<p>p96 NULL指针用法</p>
</blockquote>
<ul>
<li>对一个NULL指针解引用是非法的，因为NULL指针没有指向任何东西。</li>
</ul>
<h2>6.7 指针、间接访问和左值</h2>
<pre><code>int a;
int *d = &amp;a;

*d = 10 - *d;       // 1.正确
d = 10 - *d;        // 2.错误
</code></pre>
<p>第一条语句包含了两个间接操作。右边的间接访问作为右值使用，所以它的值d所指向的位置所存储的值(a的值)。左边的间接访问作为左值使用，所以d所指向的位置a把赋值符右边的表达式的计算结果作为它的新值。</p>
<p>第二条语句是非法的，因为它表示把一个整型变量(10 - *d)存储于一个指针变量中，当实际使用的变量类型和应该使用的变量类型不一致时，编译器会发出警告。</p>
<h2>6.8 指针、间接变量和变量</h2>
<p><code>*&amp;a = 25</code> 和 <code>a = 25</code>的效力是相同的，但是它涉及更多的操作，且这种写法会使得代码可读性更差。</p>
<h2>6.9 指针常量</h2>
<p>如果变量a存储于位置100</p>
<p><code>*100 = 25;</code>看上去像是把25赋值给a，但是这是错的！因为字面值100的类型是整型而不是指针类型表达式，如果想把25存储于位置100必须使用强制类型转换。</p>
<p><code>*(int *)100 = 25;</code>这种写法合法，但是需要使用这种技巧的地方几乎碰不到！因为<em>在编译器执行前无法确定变量会存储在内存的什么位置。</em></p>
<h2>6.10 指针的指针</h2>
<pre><code>int a = 12;
int *b = &amp;a;
int **c = &amp;b;
</code></pre>
<p><code>*</code>操作符具有从右向左的结合性，表达式<code>**c</code>的类型是int，它是指针的指针。<code>*c</code>访问c所指向的位置，我们知道这是变量b。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>相当的表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>12</td>
</tr>
<tr>
<td>b</td>
<td>&amp;a</td>
</tr>
<tr>
<td>*b</td>
<td>a,12</td>
</tr>
<tr>
<td>c</td>
<td>&amp;b</td>
</tr>
<tr>
<td>*c</td>
<td>b,&amp;a</td>
</tr>
<tr>
<td>**c</td>
<td>*b,a,12</td>
</tr>
</tbody>
</table>
<h2>6.11 指针表达式</h2>
<p>符号优先级：() &gt; ++ &gt; * &gt; -</p>
<ul>
<li>分析几个重要的指针表达式</li>
</ul>
<pre><code>char ch = 'a';
char * cp = &amp;ch;
</code></pre>
<ol>
<li><code>*cp + 1</code></li>
<li><code>*(cp + 1)</code></li>
<li><code>++cp</code></li>
<li><code>cp++</code></li>
<li><code>*++cp</code></li>
<li><code>*cp++</code></li>
<li><code>++*cp</code></li>
<li><code>(*cp)++</code></li>
<li><code>++*++cp</code></li>
<li><code>++*cp++</code></li>
</ol>
<ul>
<li><code>*cp + 1</code>
先执行间接访问操作得到它的值，后取得这个值的<strong>副本</strong>执行与1相加的操作。表达式最终结果为字符'b'。该表达式最终结果的存储位置并未清晰定义，所以不是一个合法左值。</li>
<li><code>*(cp + 1)</code>
指针加法运算的结果是一个右值，之后对这个右值进行间接访问操作后可以将其作为左值使用，尽管<code>cp + 1</code>本身并不是左值。</li>
</ul>
<blockquote>
<p><strong>间接访问操作符是少数几个其结果为左值的操作符之一。</strong></p>
</blockquote>
<ul>
<li><code>++cp</code>和<code>cp++</code>唯一区别是这两个表达式的返回值一个是cp + 1的副本，一个是cp的副本。且这两个表达式都不是合法的左值。</li>
<li><code>*cp++</code>和<code>*++cp</code>与不加间接访问操作的上面两个式子不同。右值为<code>ch + 1</code> 或 <code>ch</code>那个<strong>内存地址的值</strong>，左值为<strong>那个位置本身</strong>(作为变量使用)。</li>
<li><code>++*cp</code>与上式不同，由于<code>*</code>和<code>++</code>操作符都是左结合性，首先执行间接访问操作，然后cp所指向的位置的值加一，表达式结果是这个增值后的值的一个副本。</li>
<li><code>(*cp)++</code>是原本cp增值前的原先值，和<code>ch++</code>操作相同</li>
<li><code>++*++cp</code>先执行<code>*++cp</code>后执行<code>++*++cp</code>，结果为<code>*++cp</code>自增后的拷贝。</li>
<li><code>++*cp++</code>和上式的唯一区别是<code>*++cp</code>和<code>*cp++</code>的区别。</li>
</ul>
<h2>6.12 实例</h2>
<p>程序6.1：字符串的长度</p>
<pre><code>#include &lt;stdlib.h&gt;
size_t
strlen(char *string)
{
    int     length = 0;
    while(*string++ != '\0')
        length += 1;
    return length;
}
</code></pre>
<p>程序6.2：在一组字符串中查找指定的字符(版本1)</p>
<pre><code>#include &lt;stdio.h&gt;
#define     TRUE    1
#define     FALSE   0

int
find_char(char **strings, char value)
{
    char* string;
    // 未初始化的字符串类型
    
    // 对于列表中的每个字符串
    
    while( (string = *strings++) != NULL)
    {
        // 观察字符串中的每个字符
        while( *string != '\0')
        {
            if( *string++ == value)
                return TRUE;
        }
    }
    return FALSE;
}
</code></pre>
<p>程序6.3：在一组字符串中查找(版本2)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#define TRUE 1
#define FALSE 0

int 
find_char(char **strings, int value)
{
    assert(strings != NULL);
    while(*strings != NULL)
    {
        while(**strings != '\0')
        {
            if(*(*strings)++ == value)
                return TRUE;
        }
        strings++;
    }
    return FALSE;
}
</code></pre>
<h2>6.13 指针运算</h2>
<ul>
<li>对指针的操作不依赖于指针的类型</li>
</ul>
<h3>6.13.1 算数运算</h3>
<ol>
<li>指针 +/- 整数</li>
<li>指针 - 指针
只有两个指针都指向同一个数组中的元素时才允许从一个指针减去另一个指针。</li>
</ol>
<pre><code>int arr[5] = {1,2,3,4,5};
int *a = &amp;arr[0];
int *b = &amp;arr[3];
// b - a = 3
// a - b = -3 ----&gt; 指针可以进行反向运算并结果为负数
</code></pre>
<h3>6.13.2 关系运算</h3>
<p>关系运算的前提也是指针都指向一个数组中的元素</p>
<p>用于清除一个数组中的所有元素</p>
<pre><code>#define N_VALUES    5
float values[N_VALUES];
float *vp;
for(vp = &amp;value[0]; vp &lt; &amp;values[N_VALUES];)
    *vp++ = 0;
</code></pre>
<blockquote>
<p>这里使用<code>!=</code>替换<code>&lt;</code>也是可行的</p>
</blockquote>
<p>for循环的另一种写法</p>
<pre><code>for(vp = &amp;values[N_VALUES - 1]; vp &gt;= &amp;values[0];vp--)
    *vp = 0;
</code></pre>
<p>这种写法有一个问题，vp--最后会访问到一个未知的内存位置在满足<code>vp == &amp;values[0]</code>后。</p>
<h2>6.14 总结</h2>
<ul>
<li>计算机内存中的每个位置都由一个地址标识。通常邻近的内存位置合成一组，这样就允许存储更大范围的值。指针的值表示的是内存地址的变量。</li>
</ul>
<h1>😠 函数</h1>
<h2>7.1 函数定义</h2>
<ul>
<li>函数的定义就是<strong>函数体的实现</strong>:</li>
<li>函数体就是一个<strong>代码块</strong>，它在函数被调用时执行:</li>
</ul>
<pre><code>类型
函数名( 形式参数 )
代码块

function_name()
{

}
</code></pre>
<p><strong>存根(stub)</strong>：为那些此时尚未实现的代码保留一个位置。</p>
<blockquote>
<p><strong>K&amp;R C</strong>形参声明</p>
</blockquote>
<pre><code>int *
find_int(key, array, array_len)
int key;
int array[];
int array_len;
{}
</code></pre>
<p><strong>return语句</strong></p>
<ul>
<li>return语句允许从函数体的<em>任何位置</em>返回。</li>
<li>return expression中的<code>expression</code>是可选的。</li>
<li>通常，表达式的类型就是函数声明的返回类型。</li>
</ul>
<blockquote>
<p>没有返回值或<code>return;</code>的函数类型应该设置为void函数。</p>
<blockquote>
<p>函数被分为有返回值的函数(<strong>真函数</strong>)和没有返回值的函数(<strong>过程或副作用</strong>)。</p>
</blockquote>
</blockquote>
<h2>7.2 函数声明</h2>
<ul>
<li>使用 <em><strong>函数原型(function prototype)</strong></em> 为编译器提供函数的完整信息:</li>
<li>对于<em>K&amp;R C</em>风格函数编译器只知道函数返回值类型:</li>
</ul>
<blockquote>
<p>标准表示，在同一个代码块中，函数原型必须与<strong>同一个函数</strong>的<strong>任何先前原型</strong>匹配。</p>
</blockquote>
<h3>7.2.2 函数的缺省认定</h3>
<ul>
<li>无法见到原型的函数，编译器认为该函数返回值为整数类型。</li>
</ul>
<h2>7.3 函数的参数</h2>
<ul>
<li>C函数的所有参数均以 <strong>"传值调用"</strong> 方式进行传递，即传递参数的副本。</li>
<li>传递指针和数组的行为实际上为 <strong>"传址调用"</strong> 。</li>
</ul>
<blockquote>
<p>对指针和数组进行<em>间接访问操作</em>。</p>
</blockquote>
<p><strong>缺省参数提升</strong>：使用K&amp;R C旧风格的形参类型<em>类似char 和 short类型</em>会被提升为<code>int</code>类型,<em>float类型</em>会被提升为<code>double</code>类型</p>
<h2>7.4 ADT和黑盒</h2>
<ul>
<li>
<p>C语言可以用于设计和实现<strong>抽象数据类型(ADT, Abstract Data Type)</strong>，因为它可以<em><strong>限制</strong></em>函数和数据定义的作用域。</p>
</li>
<li>
<p><strong>抽象数据类型(ADT, Abstract Data Type)</strong> 是一种编程概念，它将数据的表示(如何存储)和对数据的操作(如何使用)分离开来。</p>
</li>
</ul>
<h3>ADT的核心思想</h3>
<ol>
<li>
<p><strong>数据隐藏(Data Hiding)</strong>：数据的具体存储方式被隐藏起来，外部代码无法直接访问或修改。</p>
</li>
<li>
<p><strong>接口(Interface)</strong>：ADT提供一组明确定义的公共函数，作为与外部世界的唯一交互方式。</p>
</li>
</ol>
<ul>
<li>限制对模块的访问是通过合理使用<code>static</code>关键字来实现的，它可以限制对那些并非接口的函数和数据的访问。</li>
</ul>
<h3>示例：一个简单的计数器模块</h3>
<p><code>counter.h</code>(公共接口)</p>
<p>这是模块的”对外合同“，它只声明了其他文件可以访问的公共函数。</p>
<pre><code>#ifndef COUNTER_H
#define COUNTER_H

// Increment the counter by 1.
void increment_counter(void);

// Get the current value of the counter. 
int get_counter(void);
#endif // COUNTER_H
</code></pre>
<p><code>counter.c</code>(黑盒实现)</p>
<p>这是模块的”内部黑盒“。<code>static</code>关键字使得<code>count</code>变量和<code>private_helper</code>函数无法被其他文件直接访问。</p>
<pre><code>#include "counter.h"
#include &lt;stdio.h&gt;
// This is a static variable. Its value is kept for the lifetime of the program,
// but it is only visible and accessible within this file (counter.c).
static int count = 0;

// This is a static function. It's a private helper and cannot be called
// from outside this file.
static void private_helper()
{
  printf("--- (Internal) The counter is now being updated... ---\n");
}

// Public API function. It calls the private helper function
void increment_counter()
{
  private_helper(); // This is allowed bacause private_helper is in the same file.
  count++;
}

// Public API function. It returns the value of the private variable.
int get_counter()
{
  return count;
}
</code></pre>
<p><code>main.c</code>(使用模块)</p>
<p>这个文件只能通过<code>counter.h</code>中声明的公共函数与<code>counter.c</code>交互。任何试图访问内部私有函数的行为都将导致编译或链接错误。</p>
<pre><code>#include &lt;stdio.h&gt;
#include "counter.h"

int main()
{
  printf("Initial counter value: %d\n",get_counter());
  
  // Call the public function to increment the counter.
  increment_counter();
  printf("Counter value after first increment: %d\n", get_counter());

  increment_counter();
  printf("Counter value after second increment: %d\n", get_counter());

  // COMPILE/LINK ERROR!
  // The linker will fail because private_helper() is not a public symbol.
  // private_helper(); 

  return 0; 
}
</code></pre>
<blockquote>
<p>如果不包含最后一行<code>private_helper()</code>的调用程序将编译和链接成功。</p>
</blockquote>
<h2>7.5 递归</h2>
<ul>
<li>递归函数就是直接或间接调用自身的函数。</li>
<li>C通过<strong>运行时堆栈</strong>支持递归函数的实现。</li>
<li>递归的效率大部分情况下都非常低。</li>
</ul>
<h3>使用递归与迭代来表示阶乘的计算</h3>
<pre><code>factorial(n) =
├── n &lt;= 0 : 1
└── n &gt; 0 : n x factorial(n - 1)
</code></pre>
<p><strong>递归方法</strong></p>
<pre><code>long 
factorial(int n)
{
  if (n &lt;= 0)
    return 1;
  else 
    return n * factorial(n - 1);
}
</code></pre>
<p><strong>迭代方法</strong></p>
<pre><code>long
factorial(int n)
{
  int result = 1;
  while (n &gt; 1)
  { 
    result *= n;
    n -= 1;
  }
  
  return result;
}
</code></pre>
<blockquote>
<p>许多问题是以递归的形式进行解释的，这只是因为它比非递归形式更为清晰，但是这些问题的迭代实现往往比递归实现效率更高。</p>
</blockquote>
<h3>使用递归与迭代来表示斐波那契数</h3>
<pre><code>Fibonacci(n) =
├── n &lt;= 1 : 1 
├── n = 2 : 1
├── n &gt; 2 : Fibonacci(n - 1) +Fibonacci(n - 2)
</code></pre>
<p><strong>递归方法</strong></p>
<pre><code>long fibonacci(int n)
{
  if (n &lt;= 2)
    return 1;

  return fibonacci(n - 1) + fibonacci(n - 2);
}
</code></pre>
<p><strong>迭代方法</strong></p>
<pre><code>long fibonacci(int n)
{
  long result;
  long previous_result;
  long next_older_result;
  
  result = previout_result = 1;
  
  if (n &lt;= 2)
    return 1;
  
  while (n &gt; 2)
  {
    n -= 1;
    next_older_result = previous_result;
    previous_result = result;
    result = previous_result + next_older_result;
  }
}
</code></pre>
<blockquote>
<p>使用递归实现斐波那契数的代价比你远想的要大。</p>
</blockquote>
<h2>7.6 可变参数列表</h2>
<ul>
<li>使用<code>stdarg</code>宏实现可变参数列表，这些宏定义在<code>stdarg.h</code>头文件</li>
<li>在定义可变参数列表时在省略号前一定是代表后面可变参数列表<strong>参数个数</strong></li>
</ul>
<p>这个头文件声明了一个类型<code>va_list</code>和3个宏---<code>va_start</code>、<code>va_arg</code>和<code>va_end</code></p>
<h3>计算标量参数平均值(非可变参数)</h3>
<pre><code>float average(int n_values, int v1,int v2, int v3, int v4, int v5)
{
  float sum = v1; 
  
  if ( n_values &gt;= 2)
    sum += v2;
  if ( n_values &gt;= 3 )
    sum += v3;
  if ( n_values &gt;= 4 )
    sum += v4;
  if ( n_values &gt;= 5 )
    sum += v5;

  return sum / n_values;
}
</code></pre>
<h3>计算标量参数平均值(可变参数)</h3>
<pre><code>#include &lt;stdarg.h&gt;

float average(int n_values, ...) // 传递任意数量的未知数
{
  va_list var_arg;
  int count;
  float sum;
  
  // 准备访问可变参数
  va_start (var_arg, n_values);
  
  // 添加取自可变参数列表的值
  for (count = 0;count &lt; n_values;count += 1)
    sum += va_arg(var_arg, int);
  
  // 完成处理可变参数
  va_end(var_arg);
  
  return sum / n_values;
}
</code></pre>
<h1>🖐 数组</h1>
<h2>8.1 一维数组</h2>
<ul>
<li><strong>指针与数组并不是相等的。</strong></li>
</ul>
<h3>8.1.1 数组名</h3>
<p>考虑下面的这些声明:</p>
<pre><code>int a;
int b[10];
</code></pre>
<blockquote>
<p>a为标量，因为它是一个单一的值；b为数组，因为它是一些值的集合。</p>
</blockquote>
<p><strong>数组</strong>: 相同类型的值的集合。</p>
<blockquote>
<p>int b[10]中的b并不表示整个数组而是表示数组首个元素的地址。数组为<code>int</code>类型表示数组名的类型为"指向int的常量指针"。</p>
</blockquote>
<ul>
<li>区分指针与数组差别的其中一个理由是数组名是<strong>指针常量</strong>而不是<strong>指针变量</strong>。</li>
</ul>
<blockquote>
<p>常量的值是不能修改的，这也就意味着如果有一个指针<code>int *c</code>那么b = c这种赋值是非法的，因为b是常量。</p>
</blockquote>
<h3>8.1.2 下标引用</h3>
<ul>
<li><strong>除优先级外，下标引用和间接访问完全相同。</strong></li>
</ul>
<pre><code>array[subscript] == *(array + (subscript))
</code></pre>
<p><strong>证明相等性:</strong></p>
<pre><code>int array[10];
int *ap = array + 2;
</code></pre>
<table>
<thead>
<tr>
<th>statement</th>
<th>expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>ap</td>
<td>array + 2 and &amp;array[2]</td>
</tr>
<tr>
<td>*ap</td>
<td>array[2] and *(array + 2)</td>
</tr>
<tr>
<td>ap[0]</td>
<td>*(ap + 0) and array[2]</td>
</tr>
<tr>
<td>ap+6</td>
<td>array + 8 and &amp;array[8]</td>
</tr>
<tr>
<td>*ap+6</td>
<td>array[2] + 6</td>
</tr>
<tr>
<td>*(ap+6)</td>
<td>array[8]</td>
</tr>
<tr>
<td>ap[6]</td>
<td>*(ap+6)</td>
</tr>
<tr>
<td>&amp;ap</td>
<td><strong>unpredictable</strong></td>
</tr>
<tr>
<td>ap[-1]</td>
<td><strong>correct operation and its array[1]</strong></td>
</tr>
<tr>
<td>ap[9]</td>
<td><strong>unpredictable</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>偏移量的负数是可以允许的</strong></p>
</blockquote>
<p>最后两个例子显示了为什么<strong>下标检查</strong>在C中是一项困难的任务。最初的C编译器并不检查下标，而最新的编译器有些依然不检查下标。且如果编译器进行下标检查涉及的开销比想象的多。</p>
<blockquote>
<p>2[array] 是一个<strong>合法</strong>的数组表示！它表示的是 <em>(2 + array)，也就是</em>(array + 2)即array[2]。</p>
</blockquote>
<h3>8.1.3 指针与下标</h3>
<ul>
<li>如果可以互换地使用指针表达式和下标表达式，下标绝不会比指针更有效率，指针表达式有时候比下标表达式<strong>更有效率</strong>。</li>
</ul>
<p><strong>下标方案执行循环</strong></p>
<pre><code>int array[10],a;
for (a = 0;a &lt; 10;a++)
  array[a] = 0;
</code></pre>
<p><strong>指针间接访问方案执行循环</strong></p>
<pre><code>int array[10],*ap;
for (ap = array;ap &lt; array + 10;ap++)
  *ap = 0;
</code></pre>
<ul>
<li>在比较老的编译器中指针间接访问比下标访问更有效率</li>
</ul>
<p><strong>1. 数组下标版本</strong><br />
对于<code>array[a] = 0;</code>这行代码，计算机在每次循环时都必须做以下三件事：<br />
a. 找到数组的起始地址(<code>array</code>);<br />
b. 将循环变量<code>a</code>乘以<code>int</code>类型的大小(例如四字节)；<br />
c. 将相乘的结果<strong>加到</strong>起始地址，才能找到<code>array[a]</code>的准确内存位置。</p>
<blockquote>
<p>这个过程在每次循环中都涉及<strong>一次乘法和一次加法</strong>。</p>
</blockquote>
<p><strong>2. 指针间接访问版本</strong><br />
对于<code>*ap = 0;</code>这行代码，计算机的处理方法更直接：<br />
a. 指针<code>ap</code>已经直接存储了当前要操作的内存地址。<br />
b. <code>*ap</code>操作直接访问地址，非常快。<br />
c. <code>ap++</code>操作只需要简单地在<code>ap</code>的地址上加上<code>int</code>类型的大小(例如四字节)，就能得到下一个元素的地址。</p>
<blockquote>
<p>这个过程只涉及<strong>一次简单的加法</strong>，比乘法要快得多。</p>
</blockquote>
<ul>
<li>但现代编译器<strong>非常智能</strong>，像数组下标版本会被<strong>优化成更高效的指针算术指令</strong>。</li>
</ul>
<h3>8.1.4 指针的效率</h3>
<ul>
<li>程序的效率取决于你的<strong>编译器</strong>和<strong>机器</strong>。</li>
</ul>
<p>把一个数组的内容复制到另一个数组：</p>
<pre><code>#define SIZE 50
int x[SIZE];
int y[SIZE];
int i;
int *p1,*p2;
</code></pre>
<p>下标版本函数：</p>
<pre><code>void try1()
{
  for(i = 0; i &lt; SIZE;i++)
    x[i] = y[i];
}
</code></pre>
<p>指针版本函数：</p>
<pre><code>void try2()
{
    for( p1 = x, p2 = y; p1 - x &lt; SIZE;)
      *p1++ = *p2++;
}
</code></pre>
<p>重新使用计数器：</p>
<pre><code>void try3()
{
  for( i = 0, p1 = x, p2 = y; i &lt; SIZE; i++)
  {
    *p1++ = *p2++;
  }
}
</code></pre>
<p>寄存器指针变量：</p>
<pre><code>void try4()
{
  register int *p1, *p2;
  register int i;
  
  for( i = 0,p1 = x, p2 = y;i &lt; SIZE; i++)
    *p1++ = *p2++;
}
</code></pre>
<p>消除计数器：</p>
<pre><code>void try5()
{
  register int *p1, *p2;

  for( p1 = x, p2 = y;p1 &lt; &amp;x[SIZE])
  {
    *p1++ = *p2++;
  }
}
</code></pre>
<p>重新使用计数器是一个比较不错的写法，而消除计数器则是一个更加快速的执行代码。</p>
<p><strong>结论</strong>:</p>
<ol>
<li>使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。</li>
<li>如果有经过初始化并经过调整的内容来判断循环是否应该终止，就不需要使用一个单独的计数器。</li>
<li>那些必须在运行时求值的表达式诸如<code>&amp;array[SIZE]</code>或<code>array+SIZE</code>这样的常量表达式往往代价更高。</li>
</ol>
<h3>8.1.5 数组和指针</h3>
<ul>
<li>指针和数组并不是相等的。</li>
</ul>
<p>在使用<code>int a[10]</code> 和 <code>int *b</code>这两个指针值时表达式<code>*a</code>是合法而<code>*b</code>是非法的；表达式<code>b++</code>可以通过编译，但<code>a++</code>不行。</p>
<h3>8.1.6 作为函数参数的数组名</h3>
<pre><code>void strcpy(char *buffer, char const *string)
{
  while (*buffer++ = *string++ != '\0');
}
</code></pre>
<p>while语句中的<code>*string++</code>表达式取得string所指向的那个字符，并且产生一个副作用，就是修改<code>string</code>，使它指向下一个字符。用这种方法修改形参并不会影响调用程序的实参，因为只有传递给函数的那份拷贝进行了修改。</p>
<h3>8.1.7 声明数组参数</h3>
<p><code>int strlen(char * string)</code>和<code>int strlen(char string[])</code>这两种声明是相等的，<strong>但是只在当前这个上下文环境中</strong>。</p>
<ul>
<li>使用<code>char *string</code>指针声明数组参数更加准确，且数组作为形参不需要传递元素个数，因为函数并不为数组参数分配内存空间，<strong>形参只是一个指针</strong>。</li>
</ul>
<h3>8.1.8 初始化</h3>
<p><code>int vector[5] = {10,20,30,40,50};</code>是一个标准的数组初始化。</p>
<h4>静态和自动初始化</h4>
<ul>
<li>数组初始化的方式类似于标量变量的初始化方式---也就是取决于它们的存储类型。</li>
<li>存储在静态内存的数组只初始化一次，也就是在程序开执行之前。</li>
<li>对于自动变量而言自动变量位于运行时堆栈编译器没办法在程序开始前对它进行初始化。所以自动变量在缺省情况下是未初始化的。</li>
</ul>
<blockquote>
<p>当数组的初始化局部于一个函数(或代码块)时，你应该仔细考虑一下，在程序的执行流每次进入该函数(或代码块)时，每次都对数组进行重新初始化是不是值得。如果答案是否定的，就把数组声明为<code>static</code>，这样数组的初始化只需在程序开始前执行一次。</p>
</blockquote>
<h3>8.1.9 不完整的初始化</h3>
<ul>
<li>初始化值数目大于数组长度(编译时错误)；小于则将未初始化的元素初始化为0，且只允许省略最后几个初始值。</li>
</ul>
<h3>8.1.10 自动计算数组长度</h3>
<p><code>int vector[] = {1,2,3,4,5};</code>让编译器识别数组大小</p>
<h3>8.1.11 字符数组的初始化</h3>
<p>两种初始化方法：<br />
1.<code>char message[] = {'H','e','l','l','o',0};</code><br />
2.<code>char message[] = "Hello";</code></p>
<p>这两种初始化方法是相同的，都是一个字符数组初始化列表，而<code>char* message = "Hello";</code>是一个<strong>字符串常量</strong>，即一个指向常量字符串"Hello"的指针。上面两个都是可修改的字符数组。</p>
<h2>8.2 多维数组</h2>
<ul>
<li><code>int martix[6][10]</code>在某些上下文环境中，既是6行10列，也是10行6列。</li>
</ul>
<h3>8.2.1 存储顺序</h3>
<p><code>int array[4];</code>是一个存储三个整型元素的数组<br />
<code>int array[4][6];</code>在上面的基础上将三个整型元素改为三个包含6个元素的数组</p>
<ul>
<li>在C中，多维数组的元素存储顺序按照最右边下标率先变化的原则称为<strong>行主序(row major order)</strong>。比如读取<code>array[2][4]</code>往下读取应该是<code>array[2][5]</code>后是<code>array[3][0]</code>。</li>
</ul>
<h3>8.2.2 数组名</h3>
<ul>
<li>一维数组名的值是一个指针常量，它的类型是"指向元素类型的指针"</li>
<li>多维数组和一维数组为一个区别是多维数组的第一维元素实际上是另一个数组</li>
</ul>
<p><code>int martix[3][10];</code>这个数组名<code>matrix</code>的值是一个指向它第一个元素的指针，所以<code>matrix</code>是一个指向一个包含10个整型的数组的指针。</p>
<h3>8.2.3 下标</h3>
<p><code>matrix</code>: 指向包含10个整型元素的数组的指针<br />
<code>matrix+1</code>: 指向包含10个整型元素的数组的指针，但是指向的是matrix的下一行<br />
<code>*(matrix + 1)</code>: 包含10个整型元素的子数组(常量指针)，与<code>matrix[1]</code>相等<br />
<code>*(matrix + 1) + 5</code>: 上面的常量指针右移5位<br />
<code>*(*(matrix + 1) + 5)</code>: 上面指针所指向的元素，与<code>matrix[1][5]</code>值相等<br />
上面的式子可以改写为：*(matrix[1] + 5)</p>
<h3>8.2.4 指向数组的指针</h3>
<pre><code>int   vector[10], *vp = vector;
int   matrix[3][10], *mp = matrix;
</code></pre>
<p>第一个声明是合法的，第二个声明是非法的。<br />
<code>matrix</code>不是一个指向整型的数组而是一个指向整型数组的指针。</p>
<p><code>int (*p)[10]</code>是一个合法的指向二维数组的数组指针。因为下标引用的优先级高于间接访问
，所以要给<code>*p</code>加上括号。</p>
<pre><code>int *pi = &amp;matrix[0][0];
int *pi = matrix[0];
</code></pre>
<p>上面的两个指针指向二维数组的首地址可以逐个访问整型元素而不是逐行在数组中移动</p>
<blockquote>
<p>应该避免使用<code>int  (*p)[] = matrix;</code>这种没有数组长度的声明，因为没有声明数组长度当执行指针运算时它的值将根据空数组的长度进行调整(与0相乘)</p>
</blockquote>
<h3>8.2.5 作为函数参数的多维数组</h3>
<p>如果是二维数组你可以声明为以下的任意一个</p>
<pre><code>void func2(int (*mat)[10]);
void func2(int mat[][10]);
</code></pre>
<ul>
<li>编译器必须知道<strong>第二个</strong>及以后各维的长度才能对各下标进行求值，因此在原型中必须声明这些维的长度，也就是在原数组声明时至少为<code>int mat[][10]</code>这种并且在函数形参声明时也写成这样</li>
</ul>
<p><code>void func2(int **mat);</code>是一个指向整型指针的指针，和一开始说的一样，指针和数组是不同的，和指向整型数组的指针不是一回事。</p>
<h3>8.2.6 初始化</h3>
<pre><code>int matrix[2][3] = {100,101,102,110,111,112};

int two_dim[3][5] = {
  {00,01,02,03,04},
  {00,01,02,03,04},
  {00,01,02,03,04}
};
</code></pre>
<p>上面两种初始化的方法都可以，对于三维以上的数组来说也是类似，和一维数组一样也可以省略尾部的几个初始值。</p>
<h2>8.3 指针数组</h2>
<p><code>int  *api[10];</code>: 下标引用的优先级高于间接访问，在这个表达式中首先执行下标引用。</p>
<p>使用指针数组的场景：</p>
<pre><code>char const *keyword[] = {
    "do",
    "for",
    "register",
    "return",
    "switch",
    "while",
    NULL 
};
#define N_KEYWORD \
  (sizeof(keyword) / sizeof(keyword[0]))

# 判断参数是否与一个关键字列表中的任何单词匹配，并返回匹配的索引值。
# 如果未找到匹配函数返回-1
#include &lt;string.h&gt;

int lookup_keyword( char const* const desired_word, 
              char const *keyword_table[], int const size)
{
  char const **kwp;
  
  // 对于表中的每个单词 ...
  // for (kwp = keyword_table; kwp &lt; keyword_table + size; kwp++)
  // {
  //   if (strcmp(desired_word, *kwp) == 0)
  //       return kwp - keyword_table;
  // }
  for (kwp = keyword_table; kwp != NULL;kwp++)
  {
    if (strcmp(desired_word, *kwp) == 0)
      return kwp - keyword_table;
  }
  

  // 没有找到
  return -1;
}

</code></pre>
<blockquote>
<p>使用sizeof()对数组元素个数进行自动计数</p>
</blockquote>
<h2>8.4 总结</h2>
<ol>
<li><code>sizeof(array)</code>返回的是整个数组所占用的字节而不是一个指针所占用的字节。</li>
<li>&amp;array 和 array 指向的地址相同，但是&amp;array的类型为<code>int (*)[]</code>而array的类型为<code>int*</code></li>
<li>其他使用数组名的地方数组名都是指向数组第一个元素的指针</li>
<li><code>数组地址(类似于&amp;array[1][2]) = 数组基地址 + (行索引 * 每行总大小) + (列索引 * 单个元素大小)</code></li>
</ol>
<p><code>地址 = 基地址 + ((行索引 * 一行元素个数) + 列索引) * sizeof(元素类型)</code></p>
<p>假如<code>int array[4][2]</code>,int大小为2,array的地址为0x1000，则 &amp;array[1][2] = <code>0x1000 + (2 * 2) + (2 * 2) == 0x1008</code></p>
<h1>💝 字符串、字符和字节</h1>
<ul>
<li>字符串是一种重要的数据类型，但是C语言并没有显式的字符串数据类型，因为字符串以字符串常量的形式出现或者存储于字符数组中。</li>
<li>操作字符串变量时必须额外小心各种可能导致缓冲区溢出的操作。</li>
</ul>
<h2>9.1 字符串基础</h2>
<ul>
<li>字符串是一串<strong>零个或多个字符</strong>，并且以一个<strong>位模式为全0的NUL字符结尾</strong>。</li>
</ul>
<blockquote>
<p>字符串所包含的字符内部不能出现NUL字节</p>
</blockquote>
<h2>9.2 字符串长度</h2>
<ul>
<li>字符串的长度就是它所包含的字符个数。</li>
</ul>
<p>使用标准库头文件<code>#include &lt;string.h&gt;</code>中的函数计算字符串长度</p>
<pre><code>strlen 原型
size_t strlen (char const *string);
</code></pre>
<blockquote>
<p>size_t 是一个无符号整数类型，且这个类型是在头文件<code>stddef.h</code>中定义的</p>
</blockquote>
<ul>
<li>无符号数的使用需要考虑是否会产生负数</li>
</ul>
<pre><code>if (strlen(x) &gt;= strlen(y)) ...
if (strlen(x) - strlen(y) &gt;= 0) ...
</code></pre>
<p>这两个式子是不相等的，第二行的<code>strlen(x) - strlen(y)</code>的返回结果是一个无符号数，<strong>无符号数绝不可能是负数</strong>！</p>
<p><strong>strlen原型</strong></p>
<pre><code>#include &lt;stddef.h&gt;

size_t 
strlen(char const *string)
{
  int length;
  
  for (length = 0; *string++ != '\0';)
    length += 1;
  return length;
}
</code></pre>
<ul>
<li>表达式中如果同时存在无符号数和有符号数，可能会产生奇怪的结果</li>
</ul>
<pre><code>if (strlen(x) &gt;= 10) ...
if (strlen(x) - 10 &gt;= 0) ...
</code></pre>
<p>这两个式子也是不相等的，原因和上面相同。</p>
<blockquote>
<p>如果把strlen的返回值强制转换为<code>int</code>，就可以消除这个问题。</p>
</blockquote>
<p><strong>tips:</strong></p>
<blockquote>
<p>自己重写一个标准库函数可能会比标准库函数效率更高，如果合理使用寄存器register声明和一些技巧，<strong>但事实上很少能如愿</strong>。</p>
<blockquote>
<p>&lt;u&gt;寻找一种更好的算法比改良一种差劲的算法更有效率，复用已经存在的软件比重新开发一个效率更高。&lt;/u&gt;</p>
</blockquote>
</blockquote>
<h2>9.3 不受限制的字符串函数</h2>
<ul>
<li>最常用的字符串函数都是<strong>不受限制</strong>的，就是说它们只是通过寻找字符串参数结尾的<code>NUL</code>字节来判断它的长度。</li>
</ul>
<h3>9.3.1 复制字符串</h3>
<pre><code>char *strcpy(char *dst, char const *src);
</code></pre>
<p>这个函数把参数src字符串复制到dst参数，&lt;u&gt;由于dst参数将进行修改，所以它必须是个字符数组或者是一个指向动态分配内存的数组的指针，<strong>不能使用字符串常量</strong>&lt;/u&gt;</p>
<blockquote>
<p>&lt;u&gt;程序员必须保证目标字符数组的空间足以容纳需要复制的字符串。&lt;/u&gt;因为如果字符串比数组长，多余的字符仍然被复制，它们将覆盖原先存储于数组后面的内存空间的值。</p>
<blockquote>
<p>strcpy无法解决这个问题，因为它无法判断目标字符数组的长度。</p>
</blockquote>
</blockquote>
<h3>9.3.2 连接字符串</h3>
<pre><code>char *strcat( char *dst, char const *src);
</code></pre>
<ul>
<li>找到字符串末尾NUL并将src中的首字符覆盖掉NUL</li>
</ul>
<p>常见<code>strcat</code>用法</p>
<pre><code>strcpy( message, "Hello ");
strcat( message, customer_name );
strcpy( message, ", how are you?");
</code></pre>
<h3>9.3.3 函数的返回值</h3>
<ul>
<li><code>strcpy</code>和<code>strcat</code>都返回它第一个参数的一份拷贝</li>
</ul>
<p>将函数返回值作为另一个函数的参数</p>
<pre><code>strcat(strcpy(dst,a),b);
</code></pre>
<blockquote>
<p>首先执行<code>strcpy</code>将字符串从a复制到dst并返回dst。然后这个返回值成为<code>strcat</code>函数的第一个参数，<code>strcat</code>函数把b添加到dst的后面。</p>
</blockquote>
<p>但是在可读性上其实不如</p>
<pre><code>strcpy(dst,a);
strcat(dst,b);
</code></pre>
<ul>
<li>事实上，在这些函数的绝大多数调用中它们的返回值只是被简单地忽略。</li>
</ul>
<h3>9.3.4 字符串比较</h3>
<ul>
<li>比较两个字符串涉及对两个字符串对应的字符逐个进行比较，直到发现不匹配为止。</li>
<li>那个最先不匹配的字符中较"小"(字符集中序数较小)的那个字符所在的字符串被认为"小于"另外一个字符串</li>
</ul>
<pre><code>int strcmp(char const *s1, char const *s2);
</code></pre>
<p>如果<code>s1</code>小于<code>s2</code>，strcmp函数返回一个小于零的值，反之返回一个大于零的值。相等返回零。</p>
<pre><code>if (strcmp(a,b)) // 用于布尔值测试是一种坏风格
if (strcmp(a,b) &gt; 0) // 用于与零进行比较更好
else if (strcmp(a,b) &lt; 0)
else
</code></pre>
<h2>9.4 长度受限的字符串函数</h2>
<p>&lt;u&gt;标准库还包含了一些函数，它们以一种不同的方式处理字符串。&lt;/u&gt;</p>
<pre><code>char *strncpy(char *dst, char const *src, size_t len);
char *strncat(char *dst, char const *src, size_t len);
char *strncmp(char const *s1, char const *s2, size_t len);
</code></pre>
<p>这些函数接受一个显式的长度参数，用于<strong>限定</strong>进行复制或比较的字符数。</p>
<ul>
<li>注意⚠️：如果strlen(src)的值大于或等于len，&lt;u&gt;那么只有len个字符被复制到dst中。它的结果将不会以<strong>NUL</strong>字节结尾。&lt;/u&gt;</li>
</ul>
<blockquote>
<p>strncpy 调用的结果可能不是一个字符串，因此字符串必须以NUL字节结尾。</p>
</blockquote>
<p>保证strncpy的结果是以'\0'结尾的</p>
<pre><code>char buffer[BSIZE];
...
strncpy(buffer, name, BSIZE);
buffer[BSIZE - 1] = '\0';
</code></pre>
<p>如果name的内容可以容纳于buffer中最后的赋值语句无效。</p>
<p>如果strlen(name) &gt;= BSIZE 那么最后一条赋值语句可以截断name的字符防止缓存区溢出。</p>
<blockquote>
<p>strncat总是在结果字符串后面添加一个NUL字节，所以不会有这种问题；strncmp只比较len长度的字符串是否相等，如果strlen(name)比BSIZE大则只比较BSIZE长度个字符。</p>
</blockquote>
<h2>9.5 字符串查找基础</h2>
<h3>9.5.1 查找一个字符</h3>
<pre><code>char *strchr(char const *str, int ch);
char *strrchr(char const *str, int ch);
</code></pre>
<blockquote>
<p>虽然ch是<code>int</code>类型但是包含一个字符值。</p>
</blockquote>
<ul>
<li><code>strchr</code>在字符串str中查找字符ch第一次出现的位置，找到后函数返回一个指向该位置的指针，如果该字符不存在则返回NULL指针。strrchr返回一个指向字符串中最后一次出现的位置。</li>
</ul>
<pre><code>char string[20] = "Hello there, honey.";
char *ans;
ans = strchr(string, 'h');
</code></pre>
<h3>9.5.2 查找任何几个字符</h3>
<pre><code>char *strpbrk(char const *str, char const *group);
</code></pre>
<ul>
<li>返回一个指向str中第一个匹配group中任何一个字符的字符位置。如果未找到匹配则返回NULL指针。区分大小写。</li>
</ul>
<pre><code>char string[20] = "Hello there, honey.";
char *ans;
ans = strchr(string, "aeiou");
</code></pre>
<p>ans所指向的位置是string + 1，因为这个位置是第二个参数中的字符第一次出现的位置。区分大小写。</p>
<h3>9.5.3 查找一个子串</h3>
<pre><code>char *strstr(char const *s1, char const *s2);
</code></pre>
<ul>
<li>在s1中查找s2第一次出现的位置，并返回一个指向该位置的指针；如果s2并没有完出现在s1返回一个NULL指针；如果第二个参数是一个空指针函数返回s1。</li>
</ul>
<h4>自己实现一个 <code>strtstr</code> 和 <code>strrpbrk</code> 函数</h4>
<pre><code>#include &lt;string.h&gt;

char*
my_strrstr(char const *s1, char const *s2)
{
  register char *last;
  register char *current;

  // 把指针初始化为我们已经找到的前一次匹配
  last = NULL;
  
  // 只在第二个字符串不为空的时候进行查找，如果s2为空返回NULL
  
  if (*s2 != '\0')
  {
    // 查找 s2 在 s1 中第一次出现的位置。
    current = strstr(s1,s2);
    while (current != NULL)
    {
      last = current;
      current = strstr(last + 1, s2);
    }
  }
  return last; // 返回指向我们找到的最后一次匹配的起始位置的指针。
}
</code></pre>
<pre><code>#include &lt;string.h&gt;

char *
my_strrpbrk(char const *str, char const *group)
{
  register char *last;
  register char current;
  
  // 把指针初始化为我们已经找到的前一次匹配
  last = NULL;
  
  if (*s2 != '\0')
  {
    current = strpbrk(str, group);
    while (current != NULL)
    {
      last = current;
      current = strpbrk(last + 1, group);
    }
  }
  return last;
}
</code></pre>
<h2>9.6 高级字符串查找</h2>
<h3>9.6.1 查找一个字符串前缀</h3>
<ul>
<li><code>strspn</code>和<code>strcspn</code>函数用于计算字符串开头连续匹配指定字符集中的字符的个数</li>
</ul>
<pre><code>size_t strspn(char const *str, char const *group);
size_t strcspn(char const *str, char const *group);
</code></pre>
<p><code>str</code>: 要检查的字符串。<br />
<code>group</code>：包含要匹配的字符集的字符串。</p>
<blockquote>
<p><code>strspn</code> 从 <code>str1</code> 的第一个字符开始，依次检查每个字符。只要这个字符在 <code>str2</code> 中能找到，就继续向后检查。<strong>一旦遇到一个不在 <code>str2</code> 中的字符，函数就停止并返回已匹配的字符数。</strong></p>
</blockquote>
<blockquote>
<p><code>strcspn</code> 从 <code>str1</code> 的第一个字符开始，依次检查每个字符。只要这个字符不在 <code>str2</code> 中，就继续向后检查。一旦遇到一个在 <code>str2</code> 中的字符，函数就停止并返回已检查的字符数。</p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    const char *sentence = "Hello, world!";
    const char *charset_vowels = "aeiou";
    const char *charset_alpha = "abcdefghijklmnopqrstuvwxyz";

    size_t length1 = strspn(sentence, "Heo");
    printf("The length of the initial part of \"%s\" consisting of 'H', 'e', 'o' is: %zu\n", sentence, length1); 
    // 输出: 2 (因为 'l' 不在 "Heo" 中)

    size_t length2 = strspn(sentence, charset_alpha);
    printf("The length of the initial part of \"%s\" consisting of letters is: %zu\n", sentence, length2);
    // 输出: 5 (因为 ' ' 不在字母表中)

    return 0;
}
</code></pre>
<h3>9.6.2 查找标记</h3>
<ul>
<li><code>strtok</code>函数用于分割字符串。它会根据指定的分隔符，将字符串分解成一系列的标记(token)。</li>
</ul>
<pre><code>char *strtok(char *str, char const *sep);
</code></pre>
<p><code>str</code>：要被分割的字符串。
<code>sep</code>：包含一个或多个分隔符的字符串。</p>
<blockquote>
<p>strtok是在字符串本身进行处理的(in-place)，建议使用原字符串的拷贝进行操作。</p>
</blockquote>
<ul>
<li><code>strtok</code>的使用非常特殊，因为它是有状态的：
<ul>
<li>第一次调用：传入要分割的字符串<code>str</code>。它会找到第一个分隔符，用<code>\0</code>替换它，并返回第一个标记的指针。</li>
<li>后续调用：传入<code>NULL</code>作为<code>str</code>参数。<code>strtok</code>会从上次停止的位置继续，找到下一个分隔符，用<code>\0</code>替换它，并返回下一个标记的指针。</li>
</ul>
</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[] = "apple,banana-orange";
  const char *delimiters = ",-";
  char *token;

  // 第一次调用， 传入字符串
  token = strtok(str,delimiters);
  printf("First token: %s\n", token);
  
  // 后续调用，传入NULL
  while(token != NULL)
  {
    token = strtok(NULL,delimiters);
    if (token != NULL){
      printf("Next token: %s\n",token);
    }
  }
  return 0;
}
</code></pre>
<h2>9.7 错误信息</h2>
<ul>
<li>当你调用一些函数，请求操作系统执行一些功能如打开文件时，如果出现错误，操作系统是通过设置一个外部的整型变量<code>errno</code>进行错误代码报告的。<code>strerror</code>函数把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串的指针。</li>
</ul>
<pre><code>char *stderror(int error_number);
</code></pre>
<p>事实上，返回值应该被声明为<code>const</code>，因为你不应该修改它。</p>
<ul>
<li><code>strerror</code>函数用于将错误编号转换为人类可读的错误信息字符串。</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
// 必须包含此头文件来使用 errno

int main(void)
{
  FILE *file;
  // 尝试打开一个不存在的文件
  file = fopen("non_existent_file.txt", "r");
  
  // 如果 fopen 失败
  if (file == NULL)
    printf("Error opening file: %s\n", strerror(errno));
  else
  {
    printf("File opened successfully.\n");
    fclose(file);
  }
  return 0;
}
</code></pre>
<h2>9.8 字符操作</h2>
<ul>
<li>字符操作的原型位于<code>ctype.h</code>头文件中，分为字符分类函数和字符转换函数</li>
</ul>
<h3>9.8.1 字符分类</h3>
<p>&lt;h4&gt;字符分类函数&lt;/h4&gt;</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>如果它的参数符合下列条件就返回真</th>
</tr>
</thead>
<tbody>
<tr>
<td>isspace</td>
<td>空白字符: '空格', 换页'\f'，换行 '\n', 回车 '\r', 制表符 '\t'或垂直制表符'\v'</td>
</tr>
<tr>
<td>isdigit</td>
<td>十进制数字0~9</td>
</tr>
<tr>
<td>isxdigit</td>
<td>十六进制数字，包括所有十进制数字，小写字母a~f,大写字母A~F</td>
</tr>
<tr>
<td>islower</td>
<td>小写字母a~z</td>
</tr>
<tr>
<td>isupper</td>
<td>大写字母A~Z</td>
</tr>
<tr>
<td>isalpha</td>
<td>字母a~z A~Z</td>
</tr>
<tr>
<td>isalnum</td>
<td>字母或数字，a~z,A~z或0~9</td>
</tr>
<tr>
<td>ispunct</td>
<td>标点符号，任何不属于数字或字母的图形字符(可打印符号)</td>
</tr>
<tr>
<td>isgraph</td>
<td>任何图形字符</td>
</tr>
<tr>
<td>isprint</td>
<td>任何可打印字符，包括图形字符和空白字符</td>
</tr>
</tbody>
</table>
<h3>9.8.2 字符转换</h3>
<pre><code>int tolower(int ch);
int toupper(int ch);

if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') 在ASCII字符集的机器上能够运行，但是其他字符集有可能会失败
if (isupper(ch))
就都能顺利运行
</code></pre>
<h2>9.9 内存操作</h2>
<ul>
<li>根据定义，字符串由一个NUL字节结尾，所以字符串内部不能包含任何NUL字符。但是非字符串数据内部包含零值的情况并不罕见。你无法使用字符串函数来处理这种类型的数据，因为当它们遇到第一个NUL字节时将停止工作。</li>
<li>使用<strong>内存操作函数</strong>可以处理任意的字节序列</li>
</ul>
<pre><code>void *memcpy(void *dst, void const *src, size_t length);
void *memmove(void *dst, void const *src, size_t length);
void *memcmp(void const *a, void const *b, size_t length);
void *memchr(void const *a, int ch, size_t length);
void *memset(void *a, int ch, size_t length);
</code></pre>
<ul>
<li>和字符操作函数类似，对于memcpy()函数，如果src与dst以任何形式出现了重叠，它的结果是未定义的。但是memmove()函数可以重叠。</li>
<li>内存操作函数传入的长度为内存长度不是元素长度。</li>
<li>任何类型的指针都可以转换为<code>void*</code>型指针。</li>
</ul>
<p><code>memcpy</code></p>
<p><code>memcpy</code> copies a block of memory from a source to a destination location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>dest</code>: A pointer to the destination memory block.</li>
<li><code>src</code>: A pointer to the source memory block.</li>
<li><code>n</code>: The number of bytes to copy</li>
</ul>
<p><strong>Use case:</strong> Copying data between non_overlapping memory regions.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  int source_array[] = {1,2,3,4,5};
  int destinaion_array[5];
  
  // copy 5 integers from soure_array to destination_array
  memcpy(destination_array, source_array, sizeof(source_array));

  printf("Destinaion array: ");
  for (int i = 0; i &lt; 5; i++)
  {
    printf("%d ",destination_array[i]);
  }
  printf("\n");
  return 0;
}
</code></pre>
<p><code>memmove</code></p>
<p><code>memmove</code> copies a block of memory from a source location to a destination location, even if the memory blocks overlap.</p>
<p><strong>Parameters:</strong> Same as <code>memcpy</code></p>
<p><strong>Use case:</strong> Shifting data within the same array or buffer. This is safer than <code>memcpy</code> for overlapping regions.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[] = "abcdefgh";
  
  // Shift the string two characters to the left
  // The source and destination overlap (str + 2 and str)
  memmove(str, str + 2,strlen(str) - 2);
  
  // manually add the null terminator since memmove doesn't
  str[strlen(str) - 2] = '\0';
  printf("String after memmove: %s\n", str); // prints "cdefgh"

  return 0;

}
</code></pre>
<p><code>memchr</code></p>
<p><code>memchr</code> search a block of memory for the first occurrence of a specific byte.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>a</code>: A pointer to the memory block to search</li>
<li><code>ch</code>: The byte value to search for. It's passed as an <code>int</code> but is treated as an <code>unsigned char</code>.</li>
<li><code>length</code>: The number of bytes to search.</li>
</ul>
<p><strong>Return Value:</strong></p>
<ul>
<li>A pointer to the first occurrence of the byte <code>ch</code> within the first <code>n</code> bytes of the memory block <code>a</code>.</li>
<li>A null pointer (<code>NULL</code>) if the byte is not found.</li>
</ul>
<p><strong>Use Case:</strong> Searching for a specific byte within a block of raw binary data.Unlike string functions like <code>strchr</code>. <code>memchr</code> continues its search past null terminators (<code>\0</code>).</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
  // This array contains a null byte in the middle.
  char data[] = {'h', 'e', 'l', 'l', 'o', '\0', 'w', 'o', 'r', 'l', 'd'};
  char *result;
- 
  // Search for the character 'o' within the first 11 bytes of the array.
  // A string search function like strchr would stop at the '\0'
  result = memchr(data, 'o', sizeof(data));
  if (result != NULL) {
    printf("Found 'o' at memory address: %p\n", result);
    printf("Character found: '%c'\n", *result);

    // Calculate the index of the found character
    size_t index = (size_t)(result - data);
    printf("It is located at index: %zu\n", index);
  } else {
    printf("The character was not found.\n");
  }
  return 0;
}
</code></pre>
<p><code>memcmp</code></p>
<p><code>memcmp</code> compares a specified number of bytes in two memory blocks</p>
<p><strong>Parameter:</strong></p>
<ul>
<li><code>a</code>: A pointer to the first memory block</li>
<li><code>b</code>: A pointer to the second memory block</li>
<li><code>length</code>: The number of bytes to compare.</li>
</ul>
<p><strong>Use case:</strong> Comparing raw binary data, which may contain null bytes that would terminate string functions like <code>strcmp</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char data1[] = "Hello";
  char data2[] = "HellO";
  char data3[] = "Hello";
  
  // compare the first 5 bytes of data1 and data2
  int result1 = memcmp(data1, data2, 5);
  if (result1 != 0)
  {
    printf("data1 and data2 are different.\n");
  }
  // compare the first 5 bytes of data1 and data2
  
  int result2 = memcmp(data1, data3, 5);
  if(result2 != 0)
  {
    printf("data1 and data3 are different.\n");
  }
  return 0;
}
</code></pre>
<p><code>memset</code></p>
<p><code>memset</code> fills a block of memory with a specified byte value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>a</code>: A pointer to the memory block to fill.</li>
<li><code>ch</code>: The value to be set. It's passed as an <code>int</code> but is converted to an <code>unsigned char</code>.</li>
<li><code>length</code>: The number of bytes to fill.</li>
</ul>
<p><strong>Use case:</strong> Initializing a block of memory, such as an array or a structure, to all zeros or a specific value.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char buffer[10];
  
  // Initialize all 10 bytes of the buffer to 'A'
  memset(buffer, 'A', sizeof(buffer));
  printf("Buffer after memset: %.10s\n",buffer);
  
  // Initialize the buffer to all zeros (a common and safe practice)
  memset(buffer, 0, sizeof(buffer));
  printf("Buffer after zeroing: %d\n", buffer[0]); // Prints 0

  return 0;
}
</code></pre>
<h2>9.10 总结</h2>
<ul>
<li>字符串就是零个或多个字符的序列，该序列以一个NUL字节结尾。</li>
</ul>
<h2>9.13 问题</h2>
<ol>
<li>C语言缺少显式字符串数据类型，这是一个优点还是一个缺点？</li>
</ol>
<p>Answer:</p>
<p>C语言缺少显式的字符串数据类型，既是它的<strong>优点</strong>，也是它的<strong>缺点</strong>。</p>
<p>优点：灵活性和高效性</p>
<p>C语言的字符串被实现为以 <strong>空字符（\0）</strong> 结尾的字符数组，这带来了以下几个显著的优点：</p>
<ul>
<li>
<p>内存效率高：C语言的字符串存储非常紧凑，没有额外的元数据（如长度信息）。这使得C语言程序在处理大量文本时，内存开销极小。</p>
</li>
<li>
<p>直接操作内存：字符串作为数组，可以像普通数组一样通过指针直接访问和操作每个字符。这给予了程序员极大的灵活性，可以实现各种高效的算法，例如原地修改、零拷贝（zero-copy）等。这在系统编程、嵌入式开发和性能关键的应用中至关重要。</p>
</li>
<li>
<p>互操作性强：几乎所有编程语言都支持字节数组或指针，这使得C语言的字符串可以轻松地与其他语言（如Python、Rust、Java等）进行接口交互，而无需复杂的类型转换。</p>
</li>
</ul>
<p>缺点：安全性和易用性</p>
<p>这种设计也带来了明显的缺点，尤其是在安全和易用方面：</p>
<ul>
<li>
<p>安全性风险：由于字符串的长度信息不是显式存储的，字符串处理函数（如 strcpy、strcat、sprintf）都假定目标缓冲区足够大，这极易导致缓冲区溢出。这是C语言长期以来面临的最大安全挑战之一。程序员必须手动跟踪字符串长度，否则会引发严重的漏洞。</p>
</li>
<li>
<p>容易出错：忘记在字符串末尾添加 \0，或不小心覆盖了它，都会导致程序读取到无效内存，引发未定义行为。初学者经常会因为这些问题而感到困惑。</p>
</li>
<li>
<p>操作不便：字符串的拼接、截取等操作不像高级语言那样简洁。例如，要拼接两个字符串，你需要手动计算所需空间、分配内存、然后使用 strcpy 和 strcat，整个过程繁琐且容易出错。</p>
</li>
</ul>
<h1>🤖 结构和联合</h1>
<ul>
<li>
<p>C提供了两种类型的<em>聚合数据类型(aggregate data type)</em>。<strong>数组</strong>是相同类型的元素的集合，<strong>结构体</strong>是可具有不同类型的元素的集合。</p>
</li>
<li>
<p><em><strong>数组</strong></em>可以通过下标访问，且数据不能相互赋值，只能通过循环逐个赋值。</p>
</li>
<li>
<p><em><strong>结构体</strong></em>通过名字访问，相同类型的结构体变量可以相互赋值。</p>
</li>
</ul>
<h2>10.1 结构基础知识</h2>
<ul>
<li>
<p>结构体是一些值的集合，这些值称为它的<strong>成员(member)</strong>，&lt;u&gt;但一个结构体的各个成员可能具有不同的类型。&lt;/u&gt;</p>
</li>
<li>
<p>&lt;u&gt;结构变量属于标量类型，所以你可以像对待其他标量类型那样执行相同类型的操作。&lt;/u&gt;</p>
</li>
</ul>
<h3>10.1.1 结构声明</h3>
<p>在声明结构时，必须列出它包含的所有成员。</p>
<pre><code>struct tag {member-list} variable-list;
</code></pre>
<p>结构声明语法的不同</p>
<pre><code>struct {
  int   a;
  char  b;
  float c;
}x;


struct {
  int   a;
  char  b;
  float c;
} y[20],*z;
</code></pre>
<p>&lt;u&gt;这两个声明被编译器当作两种截然不同的类型，即使它们的成员列表完全相同。&lt;/u&gt;</p>
<pre><code>z = &amp;x;
</code></pre>
<p>这条语句是非法的。</p>
<ul>
<li>使用 <strong>标签(tag)</strong> 和 <strong>类型定义别名(typedef)</strong> 来更方便地声明和定义一个结构体变量。</li>
</ul>
<p><strong>标签(tag)</strong> 字段允许为成员列表提供一个名字。</p>
<pre><code>struct SIMPLE{
  int   a;
  char  b;
  float c;
};

struct SIMPLE x,y[20],*z;
</code></pre>
<p>这个声明使用标签来创建变量，且现在<code>x</code>,<code>y</code>,<code>z</code>都是同一种类型的结构变量。</p>
<p><strong>类型定义别名(typedef)</strong> 字段可以创建一个新的类型。</p>
<pre><code>typedef struct {
  int   a;
  char  b;
  float c;
} Simple;

Simple x;
Simple y[20], *z;
</code></pre>
<p><code>Simple</code>现在是一个类型而不是个结构标签。</p>
<blockquote>
<p>如果你想在多个源文件中使用同一种类型的结构，你应该把标签声明或<code>typedef</code>形式的声明放在一个头文件中。当源文件需要这个声明时可以使用<code>#include</code>指令把那个头文件包含进来。</p>
</blockquote>
<h3>10.1.2 结构成员</h3>
<pre><code>struct COMPLEX{
  float f;
  int a[20];
  long *lp;
  struct SIMPLE s;
  struct SIMPLE sa[10];
  struct SIMPLE *sp;
};
</code></pre>
<p>结构成员可以是标量、数组、指针甚至是其他结构体。</p>
<h3>10.1.3 结构成员的直接访问</h3>
<ul>
<li>结构变量的成员是通过点操作符<code>.</code>访问的。</li>
<li>点操作符接受两个参数，左操作数就是结构变量的名字，右操作数就是需要访问的成员的名字。这个表达式的结果就是指定的成员。</li>
</ul>
<pre><code>struct COMPLEX comp;
(comp.s).a; // 类型为struct SIMPLE 
(comp.sa)[4]; // 同上类型的数组
((comp.sa)[4]).c // 取出数组元素
结合性都是从左到右
comp.sa[4].c; equals ((comp.sa)[4]).c;
</code></pre>
<h3>10.1.4 结构成员的间接访问</h3>
<ul>
<li>对于指向结构体的指针要访问其元素应该执行<strong>间接访问操作<code>-&gt;</code></strong>。</li>
</ul>
<pre><code>void func(struct COMPLEX *cp);
// 第一种访问方式
(*cp).f;
// 第二种访问方式
cp-&gt;f;
</code></pre>
<h3>10.1.5 结构的自引用</h3>
<pre><code>// 作为结构这种声明是非法的，程序内部会无限包含自身和结构的成员。(永不终止的递归程序)
// 如果我定义了 struct SELF_REF1 b; 那么 sizeof(SELF_REF1) = sizeof(int) + (4+4+4+.....) + sizeof(int)
// 无法计算，无法在内存中分配一个固定大小的空间。

struct SELF_REF1 {
  int   a;
  struct SELF_REF1 b; // 非法，不能这样定义。
  int   c;

};

// 作为指针这个声明是合法的，因为指针的长度在编译器确定结构体长度前就知道了。
// sizeof(SELF_REF2) = sizeof (int) + sizeof(SELF_REF2*) + sizeof(int)
// 可以计算固定大小空间

struct SELF_REF2{
  int   a;
  struct SELF_REF2 *b;
  int   c;
};

</code></pre>
<p><strong>&lt;u&gt;事实上一个结构内指向自身结构的指针所指向的是同一种类型的不同结构。&lt;/u&gt;</strong>
更高级的数据结构如链表和树，都是用这些技巧实现的。每个结构指向链表的下一个元素或树的下一个分支。</p>
<pre><code>// 这个结构体创建失败了，因为SELF_REF3 直到声明的末尾才定义，所以在结构
// 声明的内部时还尚未定义。
typedef struct {
  int   a;
  SELF_REF3 *b;
  int   c;
}SELF_REF3;

// 解决方案是定义一个结构标签来声明b
typedef struct SELF_REF3_TAG {
  int   a;
  struct SELF_REF3_TAG *b;
  int   c;
}SELF_REF3
// 这次正确定义了结构体。
</code></pre>
<h3>10.1.6 不完整的声明</h3>
<ul>
<li>在声明一些相互之间存在依赖的结构时使用不完整声明(incomplete declaration)</li>
</ul>
<pre><code>struct B;

struct A {
    struct B  *parnter;
      
};
struct B {
    struct A  *partner;
};
</code></pre>
<p>在A的成员列表中需要标签B的不完整声明。一旦A被声明之后，B的成员列表也可以被声明。</p>
<h3>10.1.7 结构的初始化</h3>
<ul>
<li>位于花括号，由逗号分隔。</li>
</ul>
<pre><code>struct INI_EX {
  int   a;
  short b[10];
  Simple c;

}x = {
  10,
  {1,2,3,4,5},
  {25,'x',1.9},
};
// 另一种初始化
struct INI_EX x1 = {
  10,
  {1,2,3,4,5},
  {25,'x',1.9},
};
</code></pre>
<h2>10.2 结构、指针和成员</h2>
<p>声明和定义一些结构体和结构体变量</p>
<pre><code>typedef struct {
  int   a;
  short b[2];
}Ex2;

typedef struct EX{
  int   a;
  char  b[3];
  Ex2   c;
  struct EX   *d;
}Ex;

// 定义并初始化
Ex x = {10, "Hi", {5,{ -1 , 25 }}, 0};
Ex *px = &amp;x;
</code></pre>
<h3>10.2.1 访问指针</h3>
<p><strong>step1:</strong> <code>px</code>是一个指针变量，<code>px</code>的表达式<code>Ex *px = x;</code>表示作为左值的<code>px</code>旧值将被一个新值取代。</p>
<blockquote>
<p>考虑表达式<code>px + 1</code>。这个表达式并不是一个合法的左值，因为它的值并不存储于任何可标识的内存位置。<code>px</code>的右值更有意思，如果px指向一个结构数组的元素，这个表达式将指向该数组的下一个结构。就算如此<code>px + 1</code>仍是非法的，因为我们没办法分辨内存下一个位置所存储的是这些结构元素之一还是其他东西。编译器无法检测到这类错误。</p>
</blockquote>
<h3>10.2.2 访问结构</h3>
<p><strong>step2:</strong> <code>*px</code>的右值是px所指向的整个结构。可以用于同类型结构体赋值，作为点操作符的左操作数，访问一个指定的成员，作为参数传递给函数，作为函数的返回值返回。<code>px</code>的左值是从<code>x</code>接收来的新值，它将接受它的所有成员的新值。</p>
<ul>
<li>作为左值，重要的是位置，而不是这个位置所保存的值。</li>
</ul>
<p>表达式<code>*px + 1</code>是非法的，因为<code>*px</code>的结果是一个结构。C语言并没有定义结构体和整型值之间的加法运算。但表达式<code>*(px+1)</code>中的<code>px+1</code>表示结构体指针但x是一个标量所以这个表达式也是非法的。</p>
<h3>10.2.3 访问结构成员</h3>
<p><strong>step3:</strong> 表达式<code>px-&gt;a</code>右值是<code>10</code>,<code>x.a</code>和<code>px-&gt;a</code>值相同。</p>
<p>&lt;u&gt;<code>*px</code>和<code>px-&gt;a</code>之间的关系&lt;/u&gt;。在这两个表达式中<code>px</code>所保存的地址都用于寻找这个结构。但结构体的第一个成员是<code>a</code>。所以<code>a</code>的地址和结构的地址是一样的。&lt;u&gt;这样<code>px</code>看上去是指向整个结构，同时指向结构的第一个成员。&lt;/u&gt;但是他们的类型不同，变量<code>px</code>被声明为一个指向结构的指针，所以表达式<code>*px</code>的结果是整个结构而不是它的第一个成员。</p>
<pre><code>int *pi;

pi = px;
// 这个操作是非法的，因为它们的类型不匹配。
pi = (int *)px;
// 使用强制类型转换就能奏效

// 但是这种方法很危险，因为它避开了编译器的类型检查。
// 正确的表达式更为简单
pi = &amp;px-&gt;a;
// -&gt; 操作符的优先级高于&amp;操作符的优先级，所以这个表达式无需使用括号。

</code></pre>
<p><code>px-&gt;b</code>的值是一个指针常量，因为<code>b</code>是一个数组这个表达式<code>px-&gt;b</code>不是一个合法的左值。</p>
<pre><code>char *pc;
pc = px-&gt;b; // 一个指针常量
pc = px-&gt;b[1]; // 指向数组的第二个元素
</code></pre>
<h3>10.2.4 访问嵌套的结构</h3>
<p><strong>step4:</strong> 表达式<code>px-&gt;c</code>也是指向一个结构体，它的左值是整个结构。</p>
<pre><code>int num = px-&gt;c.a; 指向结构体内结构体并访问结构体成员a
short *num1 = px-&gt;c.b;
int num2 = *px-&gt;c.b;
</code></pre>
<h3>10.2.5 访问指针成员</h3>
<p><strong>step5:</strong> <code>px-&gt;d</code>的右值是0，左值是本身的内存位置。<code>*px-&gt;d</code>是非法的操作，因为d内包含了一个NULL指针，所以它不指向任何东西。</p>
<pre><code>Ex te;
te = *px-&gt;d;
x.d = &amp;te;
</code></pre>
<blockquote>
<p><strong>空指针的本质：地址0</strong></p>
<blockquote>
<p>空指针是一个特殊的指针值，它表示该指针不指向任何有效的内存对象。
<em>解引用空指针后CPU会尝试访问地址0</em>--&gt;<em>操作系统会捕获异常</em>--&gt;<em>触发硬件异常(Page Fault)或(Segmentation Fault)</em>--&gt;<em>内核终止程序</em>。</p>
</blockquote>
</blockquote>
<h2>10.3 结构的存储分配</h2>
<ul>
<li>编译器按照成员列表的顺序一个接一个地给每个成员分配内存。&lt;u&gt;只有当存储成员时需要满足正确的边界要求时，成员之间才可能出现用于填充的额外内存空间。&lt;/u&gt;</li>
</ul>
<pre><code>struct ALIGN{
  char  a;
  int   b; 
  char  c;
};
</code></pre>
<p>这个结构体实际分配了12个字节的内存空间但是有6个字节空间实际上不能访问。</p>
<pre><code>struct ALIGN2{
  int b;
  char a;
  char c;

};
</code></pre>
<p>这个结构体实际分配了8个字节的内存空间。（两个字符可以紧挨着存储，最后有2个字节被浪费）</p>
<blockquote>
<p>但是实际上依程序的可维护性和可读性而言不是特别大的内存损失都不需要重新排。</p>
</blockquote>
<ul>
<li>在程序创建成百上千个结构体时内存浪费问题就更为明显。</li>
<li>可以使用<code>offsetof</code>宏（定义于<code>stddef.h</code>）判断结构体内成员距离首地址的偏移值</li>
</ul>
<pre><code>offsetof(type,member) // type 是结构体类型名，member是结构体里面的成员名
offsetof(struct ALIGN, b) // 返回值是 4,也就是成员a占用了4个字节用于结构体内内存对齐
</code></pre>
<h2>10.4 作为函数参数的结构</h2>
<ul>
<li>非必要不建议将结构体作为函数参数传递</li>
<li>结构体作为一个标量的大小可能会比想象中的大</li>
</ul>
<pre><code>typedef struct
{
  char    product[PRODUCT_SIZE];
  int     quantity;
  float   unit_price;
  float   total_amount;
};

void print_receipt(Transaction trans);
void print_receipt(Transaction *trans);
</code></pre>
<p>一个传递的是结构体的拷贝，一个传递的是结构体指针。就大小而言指针比结构体小得多，效率更高。</p>
<pre><code>Transaction print_receipt(Transaction trans);
void print_receipt(Transaction *trans);
</code></pre>
<p>如果结构体作为函数返回值在堆栈上的操作效率会更低，传递结构体指针可以直接在函数内部完成结构体成员的修改。</p>
<h2>10.5 位段</h2>
<ul>
<li>结构体具有实现 <strong>位段(bit field)</strong> 的能力</li>
<li>位段的成员是一个或多个位的字段，这些不同长度的字段实际上存储于一个或多个整型变量中。</li>
<li>位段成员必须声明为<code>int</code>,<code>unsigned int</code>,<code>signed int</code>, <code>_Bool(C99)</code>类型，在成员名的后面是一个冒号和一个整数。</li>
<li>不能对位段成员取地址(不能使用<code>&amp;</code>运算符)</li>
<li>位段不能是数组</li>
<li>可移植性的程序应该避免使用位段。</li>
<li>位段和结构体成员一样之间需要内存对齐(在位段与位段之间插入填充位(Padding))</li>
</ul>
<pre><code>struct CHAR {
  unsigned  ch  : 7;
  unsigned font : 6;
  unsigned size : 19;
};
</code></pre>
<p>因为最后一个位段<code>size</code>过于庞大(大于短整型的长度)，所以可以利用前两个位段<code>ch</code>和<code>font</code>所剩余的位来增加<code>size</code>的位数，这样就避免了声明一个32位的整数来存储<code>size</code>位段。</p>
<blockquote>
<p>CHAR这个结构体内的位段说明了位段可以把长度为奇数的数据包装在一起，节省存储空间</p>
</blockquote>
<h2>10.6 联合</h2>
<ul>
<li>联合所有成员引用的是<strong>内存中的相同位置</strong></li>
<li>适用于在不同时刻把不同的东西存储于同一个位置时</li>
</ul>
<pre><code>union {
  float f;
  int   i;
} fi;

fi.f = 3.14159;
printf("%d\n", fi.i);
</code></pre>
<p>在一个浮点型和整型都是32位的机器上，变量 <code>fi</code> 只占据内存中的一个32位的字。最后用占位符<code>%d</code>输出一个浮点数不是<code>3</code>而是<code>1078530000</code>，与IEEE754单精度浮点标准有关。</p>
<h3>10.6.1 变体记录</h3>
<ul>
<li>内存中某个特定的区域将在不同的时刻存储不同类型的值</li>
</ul>
<p>在 C 语言中，可以使用 <strong>联合体（Union）</strong> 和 <strong>结构体（Struct）</strong> 结合的方式来模拟 <code>Pascal</code> 语言中的<strong>变体记录（Variant Record）</strong>，也称为<strong>带标签的联合体（Tagged Union）</strong>。</p>
<p>这种模式是 C 语言处理异构数据集合的标准方法，同时提供了类型安全性和可预测性。</p>
<h4>一个存货系统的变体记录</h4>
<pre><code>// 前两个结构指定每个零件和装配件必须存储的内容
struct PARTINFO {
  int     cost;
  int     supplier;
};

struct SUBASSYINFO {
  int     n_parts;
  struct {
    char partno[10];
    short quan;
  }part[MAXPARTS];
};

// 存货记录包含每个项目的一般信息并包含了一个联合
struct INVREC {
  char    partno[10];
  int     quan;
  enum    { PART, SUBPASSY }    type;
  union   {
          struct PARTINFO       part;
          struct SUBASSYIINFO   subassy;
  }info;
};

// 操作名为 rec 的 INVERC 结构变量
if (rec.type == PART){
  y = rec.info.part.cost;
  z = rec.info.part.supplier;
}
else{
  y = rec.info.subpassy.nparts;
  z = rec.info.subpassy.parts[0].quan;
}
</code></pre>
<h3>10.6.2 联合的初始化</h3>
<ul>
<li>联合初始化的初始值必须是联合第一个成员的类型，且必须位于一对花括号里</li>
</ul>
<pre><code>union {
  int   a;
  float b;
  char  c[4];
} x = { 5 };
</code></pre>
<blockquote>
<p>把<code>x.a</code>初始化为 5,如果给出的初始值是任何其他类型都会被转换为一个整数并赋值给<code>x.a</code></p>
</blockquote>
<h1>♿ 动态内存分配</h1>
<ul>
<li>数组的元素存储于内存中连续的位置上。当一个数组被声明时，它所需要的内存在<strong>编译时</strong>就被分配。但是也可以使用动态内存分配在<strong>运行时</strong>为它分配内存。</li>
</ul>
<h2>11.1 为什么使用动态内存分配</h2>
<p>如果是已经知道数量大小的数组分配发生在编译时，但如果在编译时不能确定数组长度(数组的长度常常在运行时才知道)，因为所需内存空间取决于输入数据。</p>
<h2>11.2 malloc和free</h2>
<ul>
<li><code>malloc</code>执行动态内存分配<code>free</code>执行分配内存的释放。这些函数维护一个可用内存池。</li>
<li><code>malloc</code>分配的动态内存没有初始化，可以使用<code>calloc</code>函数初始化也可以手动初始化。</li>
</ul>
<p>函数原型(在<code>stdlib.h</code>中声明)</p>
<pre><code>void *malloc(size_t size);
void *free(void *pointer);
</code></pre>
<p><code>malloc</code>分配的是一块连续的内存，如果请求分配100字节的内存那么实际分配的内存就是100个连续的字节。</p>
<blockquote>
<p><code>malloc</code>分配的内存可能比请求的内存大小稍微多一点，这个行为是由编译器定义的。</p>
</blockquote>
<p>内存池如果是空的(可用内存无法满足请求)<code>malloc</code>函数会像操作系统请求得到更多的内存。并在这块新的内存上执行分配任务。如果操作系统无法向malloc提供更多的内存，malloc就返回一个NULL指针。<em><strong>因此对malloc所分配的内存确保其是非空(NULL)是非常重要的</strong></em>。</p>
<pre><code>int *a_pointer = (int*)malloc(sizeof(int) * 100);
if (a_pointer == NULL)
  return -1; // 在函数内提前退出并返回错误值-1
</code></pre>
<p><code>free</code>的参数只能是<code>NULL</code>或是之前请求分配内存函数<code>malloc</code>,<code>calloc</code>或<code>realloc</code>的返回值。向<code>free</code>函数传递一个NULL参数没有任何意义。</p>
<blockquote>
<p>因为malloc的返回值是一个<code>void*</code>类型，在比较老的编译器(C89或之前)可能会要求对返回值进行强制类型转换(int*)。</p>
</blockquote>
<blockquote>
<p>二次释放和悬空指针：对同一块内存调用两次<code>free(ptr)</code>会导致堆损坏和程序崩溃；<code>free(ptr)</code>后<code>ptr</code>仍然指向已释放的内存。为了安全应立即执行<code>ptr=NULL</code>将指针置为空指针，避免后续误用。</p>
</blockquote>
<h2>11.3 calloc和realloc</h2>
<p>函数原型(在<code>stdlib.h</code>中声明)</p>
<pre><code>void *calloc(size_t num_elements, size_t element_size);
void *realloc(void *ptr,size_t new_size);
</code></pre>
<p><code>calloc</code>也用于分配内存，而<code>realloc</code>用于修改一个原先已经分配的内存块大小，使用<code>realloc</code>可以扩大和缩小内存大小。</p>
<blockquote>
<p><code>malloc</code>分配的内存是未初始化的，内容是随机的垃圾值；<code>calloc</code>分配的内存会被初始化为全0。<br />
<code>realloc</code>重新分配内存大小失败时会返回NULL但原始指针ptr指向的内存块仍有效，数据保持不变。</p>
</blockquote>
<blockquote>
<p>realloc(NULL,size) == malloc(size)<br />
realloc(ptr,0) == free(ptr)并返回NULL</p>
</blockquote>
<h2>11.4 使用动态分配的内存</h2>
<pre><code>int *pi;
...
pi = malloc(100); // 如果分配成功，在整型为 4 个字节大小的机器上被当作25个整型元素的数组
pi = malloc(25 * sizeof(int)); // 这种分配方式更好一些因为它是可移植的
...
// 使用内存：为内存分配元素
int *pi2, i;

pi2 = pi;
for(;pi2 != pi + 25;)
  *pi2++ = 0;

// 使用下标
for(i = 0; i &lt; 25; i++)
  pi[i] = 0;
</code></pre>
<h2>11.5 常见的动态内存错误</h2>
<ul>
<li>释放内存的一部分是不允许的，动态分配的内存必须一起释放。可以使用<code>realloc</code>函数缩小一块动态分配的内存并有效地释放尾部的部分内存(还是用原分配函数的返回值)</li>
</ul>
<pre><code>pi = malloc(10 * sizeof(int));
free(pi + 5); // 释放部分内存
</code></pre>
<p><strong>内存泄露</strong></p>
<p>分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。在那些所有执行程序共享一个通用内存池的操作系统中，内存泄露将一点点地榨干可用内存。</p>
<p>其他操作系统能够记住每个程序当前拥有的内存段，这样当一个程序终止时，所有分配给它但未被释放的内存都归还给内存池。</p>
<h1>🤧使用结构和指针</h1>
<h2>12.1 链表</h2>
<ul>
<li><strong>链表(linked_list)</strong> 就是一些包含数据的独立数据结构的集合。链表中的每个节点通过链或指针连接在一起。程序通过指针访问链表中的节点。通常节点是动态分配的，也有由节点数组构建的链表。</li>
</ul>
<h2>12.2 单链表</h2>
<ul>
<li>在单链表中，每个节点包含一个指向链表下一节点的指针。链表最后一个节点的指针字段的值为<code>NULL</code>，提示链表后面不在有其他节点。在找到链表的第一个节点后，指针就可以带你访问剩余的所有节点。为了记住链表的起始位置，可以使用一个<strong>根指针(root pointer)</strong>。根指针指向链表的第一个节点。注意根指针只是一个指针，它不包含任何数据。</li>
</ul>
<pre><code>typedef struct NODE{
  struct NODE *link; // 指向下一个节点的指针
  int         value; // 存储数据的变量 
} Node;
</code></pre>
<blockquote>
<p>单链表无法从结束位置往前遍历</p>
</blockquote>
<h3>12.2.1 在单链表中插入</h3>
<pre><code>// 插入到一个有序的单链表。函数的参数是一个指向链表第一个节点的指针以及需要插入的值。

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "sll_node.h"

#define FALSE 0
#define TRUE  1

int sll_insert(Node *current, int new_value)
{
  Node *previous;
  Node *new;

  // 寻找正确的插入位置，方法是按顺序访问链表，直到到达其值大于或等于新插入值的节点。
  
  while(current-&gt;value &lt; new_value)
  {
    previous = current;
    current = current-&gt;link;
  }
  // 为新节点分配内存，并把新值存储到新节点中，如果内存分配失败。
  // 函数返回false
  new = (Node*)malloc(sizeof(Node));
  if (new == NULL)
    return FALSE;
  new-&gt;value = new_value;

  // 把新节点插入到链表中，并返回true 
  new-&gt;link = current;
  previous-&gt;link = new; 
  return TRUE;
}
</code></pre>
<pre><code>result = sll_insert(root,12); // 假设有一个节点存储15，插入在这个节点前
</code></pre>
<ul>
<li>这个插入函数是<strong>不正确</strong>的，它不能处理插入最后一个节点后的场景(最后一个节点的link为NULL)，也不能处理插入第一个节点前的场景(函数不能访问root，previous未定义)</li>
<li>可以将一个指向root的指针作为参数传递给函数。然后使用间接访问，函数不仅可以获得root(指向链表第一个节点的指针，也就是根指针)的值，也可以向它存储一个新的指针值(解决current和previous分开的问题，函数总是可以判断Node**是否满足条件并间接访问root判断值大小是否满足。Node**总是作为当前节点的前一个链接字段。)</li>
</ul>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "sll_node.h"

#define FALSE 0
#define TRUE  1

int sll_insert(Node **rootp, int new_value)
{
  Node *current;
  Node *previous;
  Node *new;
  
  // 得到指向第一个节点的指针
  current = *rootp;
  previous = NULL;
  
  // 寻找正确的插入位置，方法是按序访问链表，直到到达一个其值大于或等于新值的节点
  while(current != NULL &amp;&amp; current-&gt;value &lt; new_value)
  {
    previous = current;
    current = current-&gt;link;
  }

  // 为新节点分配内存，并把新值存储到新节点中，如果内存分配失败，
  // 函数返回false
  new = (Node*)malloc(sizeof(Node));
  if (new == NULL)
    return FALSE;
  new-&gt;link = current;
  if (previous == NULL)
    *rootp = new;
  else
    previous-&gt;link = new;
  return TRUE;
}

int sll_insert_ease(Node **head, int new_value)
{
  Node *new_node;
  
  // current_ptr 现在指向的是一个指针 (head 或 link 字段)
  // 初始时指向调用者的 head 指针变量
  Node **current_ptr = head;
  
  // 1. 寻找插入位置：循环直到指针指向NULL(末尾)或指向的值 &gt;= new_value
  while (*current_ptr != NULL &amp;&amp; (*current_ptr)-&gt;value &lt; new_value)
    current_ptr = &amp;(*current_ptr)-&gt;link;
  
  // 2. 分配新节点
  new_node = (Node*)malloc(sizeof(Node));
  if (new_node == NULL)
    return FALSE;
  new_node-&gt;value = new_value;
  
  // 3. 插入：新节点指向 current_ptr 当前指向的那个节点
  new_node-&gt;link = *current_ptr;
  
  // 4. 核心：更新current_ptr 指向的指针变量，让它指向新节点
  *current_ptr = new_node; // *current_ptr 其实就是上一个节点的link
  return TRUE;
}
// 书上的优化
int sll_insert(register Node **linkp, int new_value)
{
  register Node *current;
  register Node *new;
  
  while ((current = *linkp) != NULL &amp;&amp; current-&gt;value &lt; new_value)
    linkp = &amp;current-&gt;link;

  new = (Node*)malloc(sizeof(Node));
  if (new == NULL)
    return FALSE;
  new-&gt;value = new_value;
  
  new-&gt;link = current;
  *linkp = new;
  return TRUE;
}
</code></pre>
<h2>12.3 双链表</h2>
<ul>
<li>单链表的替代方案是双链表。在一个双链表中，每个节点都包含两个指针，指向前一个节点的指针和指向后一个节点的指针。这样就可以以任何方向遍历双链表，甚至可以忽前忽后地在双链表中访问。</li>
</ul>
<pre><code>typedef struct NODE {
  struct NODE   *fwd;
  struct NODE   *bwd;
  int           value;
};
</code></pre>
<p>现在存在两个指针：一个指向链表的第一个节点(*fwd)，另一个指向最后一个节点(*bwd)。如果当前链表为空，这两字段都为<code>NULL</code>。</p>
<h3>12.3.1 在双链表中插入</h3>
<ul>
<li><code>dll_insert</code>函数接受两个参数：一个指向根节点的指针和一个整型值。</li>
<li>先前所编写的单链表插入函数把重复的值也添加到链表中。在有些应用程序中，不插入重复的值可能更为合适。<code>dll_insert</code>函数只有当欲插入的值原先不存在于链表中时才将其插入。</li>
</ul>
<p>考虑四种情况：</p>
<ol>
<li>新值可能必须插入到链表的中间位置。</li>
<li>新值可能必须插入到链表的起始位置。</li>
<li>新值可能必须插入到链表的结束位置。</li>
<li>新值可能必须既插入到链表的初始位置，又插入到链表的结束位置(即原链表为空)。</li>
</ol>
<pre><code>/*
  把一个值插入到一个双链表，rootp是一个指向根节点的指针，
  value是欲插入的新值
  返回值：如果欲插值原先已存在于链表中，函数返回0；
  如果内存不足导致无法插入，函数返回-1；如果插入成功，函数返回1。
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "doubly_linked_list_node.h"

int dll_insert(Node *rootp, int value)
{
  Node *this;
  Node *next;
  Node *newnode;
  
  /*
    查看value是否已经存在于链表中，如果是就返回
    否则，为新值创建一个新节点("newnode"将指向它)
    "this"将指向应该在新节点之前的那个节点。
    "next"将指向应该在新节点之前的那个节点。
  */
  for (this = rootp; (next = this-&gt;fwd) != NULL; this = next){
    if (next-&gt;value == value)
      return 0;
    if (next-&gt;value &gt; value)
      break;
  }

  newnode = (Node*)malloc(sizeof(Node));
  if (newnode == NULL)
    return -1;
  newnode-&gt;value = value;

  // 把新值添加到链表中
  if (next != NULL)
  {
    // 情况1或2:并非位于链表尾部
    if (this != rootp) // 情况1：并非位于链表起始位置
    {
      newnode-&gt;fwd = next;
      this-&gt;fwd = newnode;
      newnode-&gt;bwd = this;
      next-&gt;bwd = newnode;
    }
    else // 情况2：位于链表的起始位置
    {
      newnode-&gt;fwd = next;
      rootp-&gt;fwd = newnode;
      newnode-&gt;bwd = NULL;
      next-&gt;bwd = newnode;
    }   
  }
  else
  {
    // 情况3或4:位于链表的尾部
    if (this != rootp) // 情况3：并非位于链表的起始位置
    {
      newnode-&gt;fwd = NULL;
      this-&gt;fwd = newnode;
      newnode-&gt;bwd = this;
      rootp-&gt;bwd = newnode;
    }
    else // 情况4：位于链表的起始位置
    {
      newnode-&gt;fwd = NULL;
      rootp-&gt;fwd = newnode;
      newnode-&gt;bwd = NULL;
      rootp-&gt;bwd = newnode;
    }
  }
  return 1;
}
</code></pre>
<h4>语句提炼(statement factoring)</h4>
<blockquote>
<p>上面的双链表在最后判断节点插入位置时各个嵌套的if语句群存在大量的相似之处，可以使用<strong>语句提炼</strong>技巧消除这些重复代码</p>
</blockquote>
<pre><code>if (x == 3)
{
  i = 1;
  some statement;
  j = 2;
}
else
{
  i = 1;
  some statement different;
  j = 2; 
}
</code></pre>
<blockquote>
<p>这里不管<code>x == 3</code>的值是真是假，语句<code>i = 1</code> 和 <code>j = 2</code>都将执行。且这两天语句在if条件判断前都不会执行，所以：</p>
</blockquote>
<pre><code>i = 1; 
if (x == 3)
  some statement;
else 
  some statement different;
j = 2;
</code></pre>
<blockquote>
<p><em><strong>但是如果是对测试的结果有所影响的语句千万不能提炼出来！</strong></em></p>
</blockquote>
<pre><code>/*
  双链表部分代码使用语句提炼
*/
// 把新节点添加到链表中
if(next != NULL)
{
  newnode-&gt;fwd = next;
  if (this != rootp)
  {
    this-&gt;fwd = newnode;
    newnode-&gt;bwd = this;
  }
  else
  {
    rootp-&gt;fwd = newnode;
    newnode-&gt;bwd = NULL;
  }
  next-&gt;bwd = newnode;
}
else
{
  newnode-&gt;fwd = NULL;
  if (this != rootp)
  {
    this-&gt;fwd = newnode;
    newnode-&gt;bwd = this;
  }
  else
  {
    rootp-&gt;fwd = newnode;
    newnode-&gt;bwd = NULL;
  }
  rootp-&gt;bwd = newnode;
}
</code></pre>
<p>第二个简化技巧</p>
<pre><code>if (pointer != NULL)
  field = pointer;
else
  field = NULL;
</code></pre>
<p>这段代码的意思是设置一个和pointer相等的变量，如果pointer未指向任何东西，这个变量就设置为NULL。但是：</p>
<pre><code>field = pointer;
</code></pre>
<p>这个代码的意思其实和上面的一模一样，也就是第三四种情况的else语句内的<code>newnode-&gt;fwd = NULL</code>可以写成<code>newnode-&gt;fwd = next</code>；同理<code>rootp-&gt;fwd = newnode</code>也可以写成<code>this-&gt;fwd = newnode</code>。</p>
<pre><code>/*
  最终提炼的双链表插入函数
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "doubly_linked_list_node.h"

int dll_insert(register Node *rootp, int value)
{
  register Node *this;
  register Node *next;
  register Node *newnode;
  
  /*
    查看value是否已经存在于链表中，如果是就返回。
    否则，为新值创建一个新节点("newnode"将指向它)。
    "this"将指向应该在新节点之前的那个节点，
    "next"将指向应该在新节点之后的那个节点。
  */
  for (this = rootp; (next = this-&gt;fwd) != NULL; this = next)
  {
    if (next-&gt;value == value)
      return 0;
    if (next-&gt;value &gt; value)
      break;
  }
  newnode = (Node*)malloc(sizeof(Node));
  if (newnode == NULL)
    return -1;
  newnode-&gt;value = value;

  // 把新节点添加到链表中
  newnode-&gt;fwd = next;
  this-&gt;fwd = newnode;

  //if (this != rootp)
  //  newnode-&gt;bwd = this;
  //else
  //  newnode-&gt;bwd = NULL;
  newnode-&gt;bwd = (this != rootp) ? this : NULL;
  
  //if (next != NULL)
  //  next-&gt;bwd = newnode;
  //else
  //  rootp-&gt;bwd = newnode;
  (next != NULL ? next : rootp)-&gt;bwd = newnode;
  return 1;
}
</code></pre>
<h1>🍋‍🟩 预处理器</h1>
<p>编译一个C程序涉及很多步骤。其中第一个步骤被称为<strong>预处理(preprocessing)阶段</strong>。C预处理器在源代码编译之前对其进行一些文本性质的操作。它的主要任务包括删除注释、插入被<code>#include</code>指令包含的文件的内容、定义和替换由<code>#define</code>指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。</p>
<h2>14.1 预定义符号</h2>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>样例值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>__FILE__</td>
<td>"name.c"</td>
<td>进行编译的源文件名</td>
</tr>
<tr>
<td>__LINE__</td>
<td>25</td>
<td>文件当前行的行号</td>
</tr>
<tr>
<td>__DATE__</td>
<td>"Jan 31 1997"</td>
<td>文件被编译的日期</td>
</tr>
<tr>
<td>__TIME__</td>
<td>"18:04:30"</td>
<td>文件被编译的时间</td>
</tr>
<tr>
<td>__STDC__</td>
<td>1</td>
<td>如果编译器遵循ANSI C，其值就为1，否则未定义</td>
</tr>
</tbody>
</table>
<p><code>__FILE__</code>和<code>__LINE__</code>在确认调试输出的来源方面很有用处。<code>__DATE__</code>和<code>__TIME__</code>常常用于在被编译的程序中加入版本信息。<code>__STDC__</code>用于那些在ANSI环境和非ANSI环境都必须进行编译的程序中结合条件编译。</p>
<p><strong>更多实用的预定义符号</strong></p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>样例值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>__STDC_VERSION__</td>
<td>202311</td>
<td>显示编译器当前版本号</td>
</tr>
<tr>
<td>__func__</td>
<td>main</td>
<td>显示当前所在函数函数名</td>
</tr>
<tr>
<td>__GUNC__</td>
<td>15</td>
<td>和下面两个预定义符号一起使用，显示gcc当前符号</td>
</tr>
<tr>
<td>__GUNC_MINOR__</td>
<td>2</td>
<td>同上</td>
</tr>
<tr>
<td>__GUNC_PATCHLEVEL__</td>
<td>1</td>
<td>同上</td>
</tr>
<tr>
<td>__OPTIMIZE__</td>
<td>1</td>
<td>判断是否使用code optimization</td>
</tr>
<tr>
<td>__x86_64__</td>
<td>1</td>
<td>判断系统芯片架构，下面一致</td>
</tr>
<tr>
<td>__i386__</td>
<td>1</td>
<td>同上</td>
</tr>
<tr>
<td>__aarch64__</td>
<td>1</td>
<td>同上</td>
</tr>
<tr>
<td>__arm__</td>
<td>1</td>
<td>同上</td>
</tr>
<tr>
<td>__powerpc64__</td>
<td>1</td>
<td>同上</td>
</tr>
<tr>
<td>__powerpc__</td>
<td>1</td>
<td>同上</td>
</tr>
</tbody>
</table>
<h2>14.2 #define</h2>
<p>在一些简单的用法中<code>#define</code>就是为数值命名一个符号</p>
<p><code>#define</code>更为正式的描述</p>
<pre><code>#define name stuff
</code></pre>
<p>替换文本并不限于数值字面值常量。使用<code>#define</code>指令，你可以把任何文本替换到程序中。</p>
<pre><code>#define reg         register
#define do_forever  for(;;)
#define CASE        break;case
</code></pre>
<p>如果定义中的stuff非常长，它可以分成几行，除了最后一行之外，每行的末尾都要加一个反斜杠。</p>
<pre><code>#define DEBUG_PRINT(x,y,z)   printf( "File %s line %d:" \
                             " x=%d, y=%d, z=%d", \
                             __FILE__, __LINE__, \
                             x, y, z ) 
</code></pre>
<p>这里使用了相邻的字符串常量被自动连接为一个字符串的这个特性。</p>
<blockquote>
<p>#define 语句末尾不需要加分号<code>;</code>
还可以使用<code>#define</code>指令把一序列语句插入到程序中。</p>
</blockquote>
<pre><code>#define PROCESS_LOOP \
        for (i = 0; i &lt; 10; i += 1){  \
            sum += i;                 \
            if (i &gt; 0)                \
            prod *= i;                \
        }
</code></pre>
<blockquote>
<p>不要滥用这种技巧，如相同的代码需要出现在程序的几个地方，函数是一个更好的实现办法。</p>
</blockquote>
<h3>14.2.1 宏</h3>
<ul>
<li>#define 机制包括了一个规定，允许把参数替换到文本上，这种实现通常称为 <strong>宏(macro)</strong> 或定义宏(defined macro)</li>
</ul>
<pre><code>#define name(parameter-list) stuff
</code></pre>
<p><code>parameter-list(参数列表)</code>是一个由逗号分隔的值的列表，每个值都与宏定义中的一个参数相对应</p>
<pre><code>// 一个接受一个参数的宏
#define SQUARE(x) x * x

// 正常使用没有问题
SQUARE(5) // 返回值是 25

// 下面是这个定义的问题
int a;
a = 5; 
printf("%d\n",SQUARE(a + 1));
// 这里返回值返回 11 而不是 36

// 被替换宏文本
printf("%d\n", a + 1 * a + 1);
// 根据四则运算先执行 1 * a 后执行两个加法
// 修改为
#define SQUARE(x) (x) * (x)
// 这样就可以避免第一个问题

// 另一个问题
#define DOUBLE(x) (x) + (x)
a = 5;
printf("%d\n", 10 * DOUBLE(a));
// 这里返回的是 55 而不是 100
printf("%d\n", 10 * (a) + (a));
// 在原来的定义外添加一个括号
#define DOUBLE(x) ((x) + (x))
// 就可以解决这个问题
</code></pre>
<blockquote>
<p>所有用于对数值表达式进行求值的宏定义都应该用这种方式加上括号</p>
</blockquote>
<p><strong>一种有趣的宏</strong></p>
<pre><code>#define repeat do
#define until(x) while(!(x))

// 上面的宏定义将下面的循环替换

// 替换
do{
  statements;
}while(!(i &gt;= 10));

// 为
repeat {
  statements;
} until (i &gt;= 10);
</code></pre>
<blockquote>
<p>应该避免一直使用这种写法</p>
</blockquote>
<h3>14.2.2 #define 替换</h3>
<ol>
<li>在调用宏时，首先对参数进行检查，看看是否包含了任何由<code>#define</code>定义的符号。如果是，它们首先被替换。</li>
<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替代。</li>
<li>最后，再次对结果文本进行扫描，看看它是否包含了任何由<code>#define</code>定义的符号。如果是就重复上述处理过程。</li>
</ol>
<p>这样宏参数和<code>#define</code>可以包含其他<code>#define</code>定义的符号。但是宏不可以出现递归。</p>
<ul>
<li>当预处理器搜索<code>#define</code>定义的符号时，字符串常量的内容并不进行检查。有两种将宏参数插入到字符串常量的方法</li>
</ul>
<pre><code>#define PRINT(FORMAT, VALUE) \
      printf( "The value is " FORMAT "\n", VALUE)
... 
PRINT("%d", x + 3)
</code></pre>
<blockquote>
<p>这种技巧只有当字符串常量作为宏参数给出时才能使用</p>
</blockquote>
<pre><code>#define PRINT(FORMAT, VALUE) \
    printf( "The value of " #VALUE \
    " is " FORMAT "\n", VALUE )
...
PRINT( "%d", x + 3 ) // The value of x + 3 is 25 
</code></pre>
<ul>
<li>
<p>第二个技巧使用预处理器把一个宏参数转换为一个字符串。<code>#argument</code>这种结构被预处理器翻译为<code>argument</code>。</p>
</li>
<li>
<p><code>##</code>结构则执行一种不同的任务。它把位于它两边的符号连接成一个符号。作为用途之一，它允许宏定义从分离的文本片段创建标识符。</p>
</li>
</ul>
<pre><code>#define ADD_TO_SUM ( sum_number, value ) \
    sun ## sum_number += value
... 
ADD_TO_SUM( 5, 25 );
// 这条语句的意思是 sum5 += 25; 这种连接必须产生一个合法的标识符。否则其结果就是未定义的。
</code></pre>
<h3>14.2.3 宏与函数</h3>
<pre><code>#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))
</code></pre>
<p>使用宏来定义简单计算而不是函数有两个优点：</p>
<ol>
<li>用于调用和从函数返回的代码可能比实际执行这个小型计算工作的代码更大，所以对于简单函数使用宏比使用函数在<em><strong>程序的规模和速度方面都更胜一筹</strong></em>。</li>
<li>函数的参数必须声明一种特定的类型，上面这个宏定义可以用于整型、长整型、单浮点型、双浮点型等其他的类型。<em><strong>宏是与类型无关的</strong></em>。</li>
</ol>
<p>还有一些任务无法用函数实现只能用宏定义实现。</p>
<pre><code>#define MALLOC(n, type) \ 
    ( (type*)malloc( (n) * sizeof(type)))
// 被转换为
pi = MALLOC(25, int);
pi = ((int*)malloc((25) * sizeof(int)));
</code></pre>
<blockquote>
<p>请注意宏定义并没有用一个分号结尾。分号出现在调用这个宏的语句中。</p>
</blockquote>
<h3>14.2.4 带副作用的宏参数</h3>
<p>当宏参数在宏定义中出现的次数超过一次时，如果这个参数具有副作用那么当你使用这个宏时就可能出现危险，导致不可预料的结果。<strong>副作用</strong>就是在表达式求值时出现的永久性效果。例如 :</p>
<pre><code>x + 1
</code></pre>
<p>可以重复执行几百次，它每次获得的结果都是一样的。这个表达式不具有副作用。但是：</p>
<pre><code>x++
</code></pre>
<p>就具有副作用：它增加<code>x</code>的值。当这个值在下一次执行时，它将产生不同的结果。</p>
<pre><code>#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))
...
x = 5;
y = 8;
z = MAX( x++, y++ );
printf("x=%d, y=%d, z=%d\n", x, y, z);
// MAX的结果执行后 x = 6, y = 10, z = 9
// 虽然那个较小的值只增加了一次，但那个较大的值却增加了两次(y++) ? (y++)
z = ((x++) &gt; (y++) ? (x++) : (y++));
</code></pre>
<h3>14.2.5 命名约定</h3>
<p>为了区分宏定义和函数的区别需要一个<strong>命名约定</strong>，最明显的区别就是函数名一般用全小写字母，宏定义用全大写字母。</p>
<p><em><strong>宏和函数的不同之处</strong></em></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>#define宏</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码长度</td>
<td>每次使用时，宏代码都被插入到程序中。除了非常小的宏之外，程序的长度将大幅度增长</td>
<td>函数代码之处限于一个地方；每次使用这个函数时，都调用那个地方的同一份代码</td>
</tr>
<tr>
<td>执行速度</td>
<td>更快</td>
<td>存在函数调用/返回的额外开销</td>
</tr>
<tr>
<td>操作符/优先级</td>
<td>宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能会产生不可预料的结果</td>
<td>函数参数只在函数调用时求值一次，它的结果值传递给函数。表达式的求值结果更容易预测</td>
</tr>
<tr>
<td>参数求值</td>
<td>参数每次用于宏定义时，它们都将重新求值。由于多次求值，具有副作用的参数可能会产生不可预测的结果</td>
<td>参数在函数被调用前只求值一次。在函数中多次使用参数并不会导致多种求值过程。参数的副作用并不会造成任何特殊的问题</td>
</tr>
<tr>
<td>参数类型</td>
<td>宏与类型无关。只要对参数的操作是合法的，它可以使用于任何参数类型</td>
<td>函数的参数是与类型有关的。如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务是相同的</td>
</tr>
</tbody>
</table>
<h3>14.2.6 #undef</h3>
<ul>
<li>这条预处理指令用于移除一个宏定义。</li>
</ul>
<pre><code>#undef name
</code></pre>
<p>如果一个现存的名字需要被重新定义，那么它的旧定义首先必须用<code>#undef</code>移除。</p>
<h3>14.2.7 命令行定义</h3>
<p>许多C编译器提供了在命令行中定义符号，用于启动编译过程。</p>
<pre><code>int array[ARRAY_SIZE];

-Dname
-Dname=stuff

cc -DARRAY_SIZE=100 prog.c
</code></pre>
<h2>14.3 条件编译</h2>
<ul>
<li>只用于调试程序的语句就是一个明显的例子它们不应该出现在程序的产品版本中，<strong>但是你可能并不想把这些语句从源代码中物理删除，因为如果需要一些维护性修改时，你可能需要重新调试这个程序，还需要这些语句</strong>。</li>
<li>条件编译(conditional compilation)就是用于实现这个目的。</li>
</ul>
<pre><code>#if constant-expression
      statements
#endif
</code></pre>
<p>其中<code>constant-expression</code>（常量表达式）由预处理器进行求值。如果它的值是非零值（真），那么<code>statements</code>部分就被正常编译，否则预处理器就安静地删除它们。</p>
<pre><code>#define DEBUG 1
#if DEBUG
  printf(statements);
#endif
</code></pre>
<p>一个简单的使用条件编译</p>
<p><code>#if</code>的子句<code>#elif</code>和<code>#else</code></p>
<pre><code>#if constant-expression
      statements
#elif  constant-expression
      other statements ...
#else 
      other statements
#endif
</code></pre>
<h3>14.3.1 是否被定义</h3>
<pre><code>#if defined(symbol)
#ifdef symbol

#if !defined(symbol)
#ifndef symbol
</code></pre>
<p><code>#if</code>形式的语句功能更强。因为常量表达式可能包含额外的条件</p>
<pre><code>#if X &gt; 0 || defined(ABC) &amp;&amp; defined(BCD)
</code></pre>
<blockquote>
<p>一些老K&amp;R C编译器并未包含所有功能。</p>
</blockquote>
<h3>14.3.2 嵌套指令</h3>
<pre><code>#if defined( OS_UNIX )
  #ifdef OPTION1
  unix_version_of_option1();
  #endif
  #ifdef OPTION2
  unix_version_of_option2();
  #ifdef OPTION3
  unix_version_of_option3();
#elif defined( OS_MSDOS )
  #ifdef OPTION2
  msdos_version_of_option2();
  #endif
#endif
</code></pre>
<blockquote>
<p>在每个#endif 后添加一个注释标签可以很好地区分每个嵌套的指令</p>
</blockquote>
<h2>14.4 文件包含</h2>
<ul>
<li>一个头文件如果被包含到10个源文件中，它实际上被编译了10次。</li>
</ul>
<blockquote>
<p>但实际上这种额外开销实际上并不大。</p>
</blockquote>
<h3>14.4.1 函数库文件包含</h3>
<p>头文件包含语法</p>
<pre><code>#include &lt;filename&gt;
</code></pre>
<blockquote>
<p>UNIX 系统上使用<code>&lt;&gt;</code>包含的头文件一般在目录<code>/usr/include</code>查找</p>
<blockquote>
<p>编译器有一个选项<code>-I</code>允许把其他目录添加到这个列表中</p>
</blockquote>
</blockquote>
<h3>14.4.2 本地文件包含</h3>
<pre><code>#include "filename"
</code></pre>
<blockquote>
<p>优先从.c文件或.h文件所在的当前目录查找</p>
</blockquote>
<h3>14.4.3 嵌套文件包含</h3>
<pre><code>#include "a.h"
#include "b.h"
// 如果b.h 文件里包含了a.h，那么a.h在当前文件就被包含了两次
--------
// another file
#ifndef _HEADERNAME_H
#define _HEADERNAME_H 1 // #define _HEADERNAME_H
// All the stuff that you want in the header file
#endif

// 使用这种方法并不能直接不调用第二次该文件，但是文件内的所有文件会在第二次调用被弃用
</code></pre>
<blockquote>
<p>这种处理将拖慢编译速度，所以可能尽量避免出现多重包含</p>
</blockquote>
<h2>14.5 其他指令</h2>
<h3>14.5.1 #error</h3>
<p>当程序编译之后，<code>#error</code>指令允许你生成错误信息，并强制终止编译过程。</p>
<pre><code>#error text of error message
// 使用案例
#if defined(OPTION_A)
    stuff needed for optionA
#elif defined(OPTION_B)
    stuff needed for optionA
#elif defined(OPTION_C)
    stuff needed for optionC
#else
    #error No option selected!
#endif

// 检查 C 标准版本
#if __STDC_VERSION__ &lt; 199901L
#error "本项目要求 C99 或更高版本的编译器！"
#endif

#ifdef WINDOWS_ENV 
    // 针对 Windows的代码...
#elif defined(LINUX_ENV)
    // 针对 Linux的代码...
#else
#error "必须定义 WINDOWS_ENV 或 LINUX_ENV 宏以指定编译环境！"
</code></pre>
<h3>14.5.2 #line</h3>
<p><code>#line</code>指令用于改变编译器对当前代码行号和文件名的追踪。</p>
<pre><code>#line number "string"
// number 将当前源代码行的行号设置为这个数字
// string 可选，将编译器追踪的文件名设置为这个字符串

// 例子
// 原始文件名 line.c  假设
#include &lt;stdio.h&gt;

int a = 1;

#define DEBUG 0
#undef DEBUG
// gcc -std=c11 -g -Wall -DDEBUG=0 line.c
// gcc -std=c11 -g -Wall -DDEBUG=1 line.c
// 使用-DNAME 控制定义名的值
#if DEBUG
#line 100 "generated_code.c"
#endif
void func() {
  int b = 2;       // 编译器现在认为这是 generated_code.c 的 101 行
  int c = "error"; // 故意制造一个错误
}

// 恢复到当前文件的实际行号
#line __LINE__

int main(void) {
  func();
  return 0;
}
</code></pre>
<h3>14.5.3 #progma</h3>
<ul>
<li>一种特殊的预处理器指令，用于向编译器发出特殊指令或特定于实现的功能。</li>
<li><code>#progma</code> 的行为完全取决于编译器。</li>
</ul>
<pre><code>#progma 记号序列
// -------------
#progma once // 非标准但广泛使用，确保头文件只被编译一次，防止重复包含错误。
// 不是C标准的一部分，但是几乎所有的现代编译器(GCC, Clang, MSVC)都支持。
#progma STDC // C99/C11 标准用于控制浮点运算和线程。

#progma pack(n) // 控制结构体对齐
// 改变结构体的内存对齐方式
struct DefaultStruct {
  char c;
  int i; // 4 字节，可能有三字节的填充
};

// 设置对齐为 1字节
#progma pack(push, 1)

struct PackedStruct {
  char c; // 1字节
  int i; // 4 字节，紧跟在 c 之后，没有填充
};

#progma pack(pop) // 恢复默认对齐设置
</code></pre>
<h1>🎶 输入/输出函数</h1>
<ul>
<li>ANSI C和早期C相比的最大优点之一就是它在规范里所包含的函数库。每个ANSI编译器必须支持一组规定的函数，并具备规范所要求的接口，而且按照规定的行为工作。</li>
</ul>
<h2>15.1 错误报告</h2>
<p><code>perror</code>函数以一种简单、统一的方式报告错误。（原型定义于stdio.h）</p>
<pre><code>void perror(char const *message);
</code></pre>
<blockquote>
<p>标准库函数在程序存在错误时在一个外部整型变量<code>errno</code>（在errno.h中定义）中保存错误代码后把这个信息传递给用户程序，提示操作失败的准确原因。</p>
<blockquote>
<p>perror最大的优点就是容易使用。</p>
</blockquote>
</blockquote>
<h2>15.2 终止执行</h2>
<p><code>exit</code>函数用于终止一个程序的执行。（原型定义于stdlib.h）</p>
<pre><code>void exit(int status);
</code></pre>
<p><code>status</code>参数返回给操作系统，用于提示程序是否正常完成。</p>
<blockquote>
<p>预定义符号EXIT_SUCCESS 和 EXIT_FAILURE 分别提示程序的终止是成功还是失败。</p>
<blockquote>
<p>一般执行完<code>perror</code>后都会执行<code>exit</code></p>
</blockquote>
</blockquote>
<h2>15.3 标准I/O函数库</h2>
<ul>
<li>标准I/O函数库是在原先I/O库基础上的实现和扩展，例如为printf创建了不同的版本。且函数库引入了缓冲I/O的概念，提高了绝大多数程序的效率。</li>
</ul>
<blockquote>
<p>但是标准函数库是在某台特定类型机器上实现的，在其他不同类型的机器上运行相同的程序会出现无法运行的情况。</p>
</blockquote>
<ul>
<li>ANSI C函数库中的I/O函数在可移植性和完整性上更加完善。</li>
</ul>
<blockquote>
<p>ANSI C的一个主要优点就是这些修改是通过<strong>增加不同的函数</strong>方式实现，而不是通过对现存函数进行修改来实现，保证了程序的可移植性。</p>
</blockquote>
<h2>15.4 ANSI I/O概念</h2>
<ul>
<li>头文件<code>&lt;stdio.h&gt;</code>包含了与ANSI函数库的I/O部分有关的声明。</li>
</ul>
<blockquote>
<p>尽管不包含这个头文件也能使用某些I/O函数，但绝大多数函数都需要包含这个头文件。</p>
</blockquote>
<h3>15.4.1 流</h3>
<ul>
<li>ANSI C对I/O的概念进行抽象，所有的I/O操作只是简单的移入/移出字节。这种字节流便称为<strong>流(stream)</strong>。</li>
</ul>
<ol>
<li>核心概念：抽象(Abstraction)</li>
</ol>
<ul>
<li><strong>流的本质</strong>：流是对所有I/O操作的抽象</li>
<li><strong>统一接口</strong>：所有的I/O设备都被视为类似的设备。</li>
<li><strong>程序视角</strong>：对C程序而言，所有的I/O操作都只是在流上进行字节的移进或移出。</li>
<li><strong>细节隐藏</strong>：特定的I/O设备的细节对程序员是隐藏的。</li>
</ul>
<ol>
<li>核心机制：缓冲(Buffering)</li>
</ol>
<p>大多数流是<em><strong>完全缓冲的(fully buffered)</strong></em></p>
<ul>
<li><strong>读取操作</strong>：当进行"读取"时，实际上是从一块较大的缓冲区(buffer)中读取数据。当缓冲区空时，程序才通过设备或文件读取下一块较大的输入数据并重新填充缓冲区。</li>
<li><strong>写入操作</strong>："写入"也是先写入到内存中的缓冲区，直到缓冲区写满时，数据才被一次性写入(flush,冲洗或刷新)到设备或文件。</li>
<li><strong>效率优势</strong>：这种块状写入和读取操作由于减少了与设备或文件的交互次数，能够实现更快速的I/O。</li>
</ul>
<p>解决输出延迟</p>
<pre><code>printf("something or other");
fflush(stdout); // 立即将缓冲区内容写出
</code></pre>
<blockquote>
<p>在通常的编程测试中，stdout默认是行缓冲模式。</p>
</blockquote>
<pre><code>// 没有\n触发自动刷新，会暂停五秒后再执行printf
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; // for sleep

int main() {
    // 1. 没有 \n，数据进入缓冲区，但不会自动刷新
    printf("等待 5 秒，你可能看不到我...");
    
    // 2. 暂停执行
    sleep(5); 

    // 3. 补上 \n
    printf("\n我现在出来了。\n"); 
    return 0;
}
</code></pre>
<pre><code>// 有\n触发自动刷新，会先执行printf后等待五秒后执行另一个printf
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; // for sleep

int main() {
    printf("等待 5 秒，你应该能看到我...\n");
    
    // 2. 暂停执行
    sleep(5); 

    // 3. 补上 \n
    printf("\n我现在出来了。\n"); 
    return 0;
}
</code></pre>
<blockquote>
<p>stdin是类似的，都是行缓冲模式。</p>
</blockquote>
<ul>
<li>对于输入流来说，只有缓冲区空了，程序才会从外部设备获取新的数据来填充它。</li>
<li>对于输出流来说，只有缓冲区满了，缓冲区中的数据才会被写入到外部设备，进行刷新。</li>
</ul>
<h4>一、文本流(Text Stream)</h4>
<p>流分为两种，<strong>文本(text)流</strong> 和 <strong>二进制(binary)</strong> 流。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在<em><strong>MS-DOS</strong></em>系统中，文本文件约定以一个回车符和一个换行符（或称为行反馈符）结尾。但是<em><strong>UNIX</strong></em>系统只使用一个换行符结尾。</p>
<ul>
<li>核心特点：字符翻译</li>
</ul>
<p>文本流在数据传输中会引入一个<strong>翻译层</strong>，主要针对换行符(<code>\n</code>)：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>C程序中的表示</th>
<th>操作系统/文件中实际存储的表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>写入(<code>fprintf</code>,<code>fputs</code>)</td>
<td>写入一个换行符(<code>\n</code>)</td>
<td>操作系统可能会将其翻译成一个或多个字符序列(例如Windows下的<code>\r\n</code>)</td>
</tr>
<tr>
<td>读取(<code>fscanf</code>,<code>fgets</code>)</td>
<td>从文件中读取多个字符序列（例如Windows下的<code>\r\n</code>）</td>
<td>C运行时库会将这个序列翻译回单个换行符(<code>\n</code>)供C程序使用。</td>
</tr>
</tbody>
</table>
<ul>
<li>优点：保持了跨平台的<strong>文本文件兼容性</strong>。可以在任何系统上打开并正确显示用文本模式创建的文件。</li>
<li>缺点：传输的数据量可能与文件中实际存储的字节数<strong>不一致</strong>（因为翻译），且性能略低于二进制流。</li>
</ul>
<h4>二、二进制流(Binary Stream)</h4>
<p>二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且完全根据它们从文件或设备读取的形式读入到程序中。并未做任何改变。</p>
<ul>
<li>核心特点：无翻译</li>
</ul>
<p>二进制流是<strong>透明的</strong>，它绕过了C运行时库的任何翻译：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>C程序中的表示</th>
<th>操作系统/文件中实际存储的表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>写入(<code>fwrite</code>)</td>
<td>写入N个字节</td>
<td>文件中精确存储N个字节，不做任何修改。</td>
</tr>
<tr>
<td>读取(<code>fread</code>)</td>
<td>读取N个字节</td>
<td>从文件中读取N个原始字节到内存中，不做任何修改。</td>
</tr>
</tbody>
</table>
<ul>
<li>优点：1.精确性：文件中的字节数与程序处理的字节数总是精准匹配。适用于存储图片、音频、结构体、加密数据等。2.性能：由于没有翻译开销，I/O操作通常更快。</li>
<li>缺点：<strong>缺乏可移植性</strong>。如果直接将C结构体写入二进制文件，文件将依赖于机器的字节序(Endianness)和数据类型大小。</li>
</ul>
<h4>三、编程实现上的区别</h4>
<p>在C语言中，你通过<code>fopen()</code>函数的第二个参数（模式字符串）来指定使用哪种流模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"r"</code>/<code>"w"</code>/<code>"a"</code></td>
<td>文本模式(默认)</td>
</tr>
<tr>
<td><code>"rb"</code>/<code>"wb"</code>/<code>"ab"</code></td>
<td>二进制模式(加<code>b</code>)</td>
</tr>
</tbody>
</table>
<h3>15.4.2 文件</h3>
<p><code>stdio.h</code>所包含的声明之一就是<code>FILE</code>结构。<code>FILE</code>是一个数据结构，用于访问一个流。如果同时激活几个流每个流都有一个相应的<code>FILE</code>与它关联。</p>
<ul>
<li>对于每个ANSI C程序，运行时系统必须提供至少三个流：<strong>标准输入(standard input)</strong>、<strong>标准输出(standard output)<strong>和</strong>标准错误(standard error)</strong>。名字分别为<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。这三个流都是指向<code>FILE</code>结构的指针。</li>
</ul>
<blockquote>
<p>标准输入是缺省输入来源，标准输出是缺省输出设置，标准错误是缺省错误设置。通常标准输入为键盘设置，标准输出为终端或屏幕。
可以将标准输入和标准输出设置为其他设备。</p>
</blockquote>
<h3>15.4.3 标准I/O常量</h3>
<p><code>EOF</code>是许多函数的返回值，提示达到了文件尾。<strong>EOF所选择的实际值比一个字符多几位，这是为了避免二进制被错误地解释为EOF。</strong></p>
<ul>
<li>输入函数返回<code>int</code>类型：<code>getchar()</code>和<code>fgetc()</code>等函数被设计为返回<code>int</code>(32位或16位)，而不是<code>char</code>(8位)。</li>
<li>EOF的值：一般为负整数<code>-1</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>返回值</th>
<th>位宽利用</th>
</tr>
</thead>
<tbody>
<tr>
<td>成功读取有效字符</td>
<td>返回值是一个0到255之间的整数</td>
<td>仅使用了<code>int</code>的低8位来存储字符代码，其余位是0。</td>
</tr>
<tr>
<td>遇到文件结束(EOF)</td>
<td>返回值是一个负整数(-1)</td>
<td><code>int</code>的所有位都被设置成-1的二进制表示(所有32位都是1)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一个程序至少可以打开<strong>FOPEN_MAX</strong>个文件，至少是8。有一个常量<strong>FILENAME_MAX</strong>提示字符数组应该多大以便容纳编译器所支持的最长合法文件名。</p>
</blockquote>
<h2>15.5 流I/O总览</h2>
<p>对于文件流或设备流</p>
<ol>
<li>使用<code>FILE*</code>将处于活动状态的文件选择使用。</li>
<li>流通过调用<code>fopen</code>函数打开。为了打开一个流必须指定要访问的文件或设备以及他们的访问方式。<code>fopen</code>和操作系统验证文件或设备确实存在并初始化FILE结构。</li>
<li>对文件或设备读取写入。</li>
<li>最后调用<code>fclose</code>函数关闭流。防止被再次访问，保证任何存储于缓冲区的数据被正确地写到文件中，并且释放FILE结构使它可以用于另外的文件。</li>
</ol>
<blockquote>
<p>标准流不需要打开或关闭。</p>
</blockquote>
<p><strong>执行字符、文本行和二进制I/O的函数</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符</td>
<td>getchar</td>
<td>putchar</td>
<td>读取(写入)单个字符</td>
</tr>
<tr>
<td>文本行</td>
<td>gets/scanf</td>
<td>puts/printf</td>
<td>文本行未格式化的输入(输出)/格式化的输入(输出)</td>
</tr>
<tr>
<td>二进制数据</td>
<td>fread</td>
<td>fwrite</td>
<td>读取(写入)二进制数据</td>
</tr>
</tbody>
</table>
<blockquote>
<p>带f前缀的输入输出函数可以用于所有流。</p>
</blockquote>
<h2>15.6 打开流</h2>
<p><code>fopen</code>函数用于创建并打开一个新流。</p>
<pre><code>FILE *fopen(char const *name, char const *mode);
</code></pre>
<p><code>mode</code>参数上面编程实现给出</p>
<blockquote>
<p>在mode 中添加 <code>a+</code>表示该文件打开用于更新，并且流既允许读也允许写。
但是在向流写入数据前必须调用其中一个文件定位函数(<code>fseek</code>、<code>fsetpos</code>、<code>rewind</code>)。
在写后又想读取数据首先必须调用<code>fflush</code>函数或文件定位函数之一。</p>
</blockquote>
<p>应该始终检查<code>fopen</code>函数的返回值！如果函数失败，它会返回一个NULL值。</p>
<pre><code>FILE *input;
input = fopen("data3", "r"); // 文本只读
if (input == NULL)
{
  perror("failed to open file data3, Quitting...");
  exit(EXIT_FAILURE);
}
// 在终端报错类似：data3: No such file or directory
</code></pre>
<p><code>freopen</code>函数用于打开（或重新打开）一个特定的文件流。原型如下：</p>
<pre><code>FILE* freopen(char const *filename, char const *mode, FILE *stream);
</code></pre>
<p>最大的作用是改变流的输入输出</p>
<blockquote>
<p><code>freopen</code>函数在执行成功时，它返回的指针和传入的第三个参数<code>stream</code>是同一个指针，即它们都指向同一个<code>FILE</code>结构体。</p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; // 用于 EXIT_FAILURE

int main() {
    // 1. 初始状态：printf 输出到终端
    printf("--- 程序开始 ---\n");
    printf("这条信息应该显示在终端上。\n");

    // =======================================================
    // 2. 使用 freopen 重定向标准输出 (stdout)
    //    参数: 
    //      "log.txt": 新的文件名
    //      "w": 写入模式 (会覆盖文件原有内容)
    //      stdout: 要重定向的目标流
    // =======================================================
    FILE *original_stdout = freopen("log.txt", "w", stdout);

    // 检查重定向是否成功
    if (original_stdout == NULL) {
        // 如果重定向失败，通常是文件路径问题
        perror("freopen 失败");
        return EXIT_FAILURE;
    }

    // 3. 重定向后的状态：printf 输出到 log.txt 文件
    printf("这条信息不会显示在终端，而是写入 log.txt。\n");
    printf("freopen 成功地将标准输出改变了方向。\n");
    printf("--- 程序结束 ---\n");

    // 4. 关闭文件流并返回
    // freopen 已经关闭了旧的 stdout（终端），并打开了新的文件。
    // 程序结束时会自动关闭 log.txt，但明确关闭是好习惯
    if (fclose(stdout) != 0) {
        perror("关闭 stdout 失败");
    }
    
    // 注意：程序不会输出任何成功信息到终端，因为它被重定向了
    return 0;
}
</code></pre>
<h2>15.7 关闭流</h2>
<p>使用<code>fclose</code>关闭流</p>
<pre><code>int fclose(FILE *f);
</code></pre>
<p><code>fclose</code>函数在文件关闭前刷新缓冲区。执行成功返回0值，否则返回EOF。</p>
<blockquote>
<p>是否应该对fclose(或其他操作)进行错误检查？</p>
<blockquote>
<ol>
<li>如果操作成功应该执行什么？</li>
<li>如果操作失败应该执行什么？</li>
</ol>
<blockquote>
<p>如果这两个答案是不同的，应该进行错误检查；如果是相同的，跳过错误检查才是合理的。</p>
</blockquote>
</blockquote>
</blockquote>
<h2>15.8 字符I/O</h2>
<p>字符输入</p>
<pre><code>int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);
</code></pre>
<p>字符输出</p>
<pre><code>int fputc(int character,FILE* stream);
int putc(int character,FILE* stream);
int putchar(int character);
</code></pre>
<h3>15.8.1 字符I/O宏</h3>
<p>除了<code>fgetc</code>和<code>fputc</code>其他都是<code>#define</code>指令定义的宏，两种实现为了不同的场景，但是实际两种操作相差甚微。</p>
<h3>15.8.2 撤销字符I/O</h3>
<p>在流读取时总有一个不想读取的字符，但使用流逐个读取没有条件判断一定会读到一个不满足的字符，为了不丢弃这个字符，使用<code>ungetc</code>函数将这个字符从参数中推回stream中。</p>
<blockquote>
<p><code>ungetc</code>函数主要的应用场景是<strong>超前扫描</strong>或<strong>令牌解析</strong></p>
</blockquote>
<p>读取一个整数，直到遇到非数字或EOF</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt; // 用于 isdigit()

// 函数：从标准输入读取一个整数
int read_integer(FILE *stream) {
    int ch;
    int value = 0;

    // 1. 跳过开始的空白字符
    do {
        ch = fgetc(stream);
    } while (isspace(ch));

    // 2. 检查第一个非空白字符是否是数字
    if (!isdigit(ch)) {
        // 如果第一个字符不是数字，就把它放回流中
        if (ch != EOF) {
            ungetc(ch, stream);
        }
        return 0; // 或者返回一个错误代码
    }

    // 3. 读取数字部分
    while (isdigit(ch)) {
        value = value * 10 + (ch - '0');
        ch = fgetc(stream); // 超前读取下一个字符
    }

    // 4. 【核心步骤】
    // 循环停止是因为 ch 遇到了第一个非数字字符（或者 EOF）。
    // 这个非数字字符（例如一个字母 'A'）不属于当前的整数，它属于流的下一个部分。
    if (ch != EOF) {
        ungetc(ch, stream); // 将这个超前读取的字符放回流中
    }
    
    return value;
}

int main() {
    int num1, num2;
    
    printf("请输入数据 (例如: 123ABC456)\n");
    
    // 假设用户输入: 123ABC456\n

    // 第一次调用：读取 123
    num1 = read_integer(stdin); 
    printf("读取到第一个整数: %d\n", num1); 
    // 此时字符 'A' 被 read_integer 读走后又放回了 stdin。

    // 第二次调用：读取下一个字符，它将是 'A'
    printf("下一个字符是: %c\n", fgetc(stdin)); 
    
    // 第三次调用：读取 456
    // read_integer 会消耗 'B', 'C'，直到 456
    // num2 = read_integer(stdin); // 错误：会消耗 'B', 'C'
    
    printf("流中剩余字符:\n");
    // 清空并打印剩余部分，以验证 ungetc 后的字符 'A' 确实被读取了
    int ch;
    while ((ch = getchar()) != EOF) {
        putchar(ch);
    }
    
    return 0;
}
</code></pre>
<blockquote>
<p>退回字符和流的当前位置有关，如果使用<code>fseek</code>,<code>fsetpos</code>或<code>rewind</code>函数改变了流的位置，所有退回的字符都要被丢弃。</p>
</blockquote>
<h2>15.9 未格式化的行I/O</h2>
<p>行I/O可以使用两种方式执行————未格式化的和格式化的。这两种形式都用于操作字符串。</p>
<pre><code>char *fgets(char* buffer, int buffer_size, FILE *stream);
char *gets(char *buffer);

int fputs(char const *buffer, FILE* stream);
int puts(char const *buffer);
</code></pre>
<p><code>fgets</code>从指定的stream读取字符并把它们复制到buffer中。在读取到换行符或缓冲区内存储的字符达到<code>buffer_size - 1</code>时停止读取。</p>
<blockquote>
<p>gets在C99后不推荐使用，C11后已经完全抛弃！在任何情况下<code>fgets</code>都会在末尾添加NUL字节表示字符串结束；puts会自动在尾部添加换行符；fputs不会添加换行符。</p>
</blockquote>
<p>常见错误</p>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    char data[5];

    // 错误操作：数组只有5个字节，但写入了6个字符，没有留空间给 '\0'
    // 实际上是写入了 'H', 'e', 'l', 'l', 'o'，'\0' 溢出到了 data 之外
    // 但在这个例子中，我们假设用 memcpy 或其它方式精确地填满 data，没有 \0
    data[0] = 'A';
    data[1] = 'B';
    data[2] = 'C';
    data[3] = 'D';
    data[4] = 'E'; // &lt;--- 数组已满，没有空终止符

    printf("尝试写入一个非终止字符串...\n");

    // fputs 将会从 data[0] 开始一直读到内存中找到 \0 为止
    // 这将是 UB！
    fputs(data, stdout); 

    printf("\n程序可能崩溃，或者输出了乱码。\n");

    return 0;
}
</code></pre>
<blockquote>
<p><code>fgets</code>第二个参数虽然能指定传入的元素个数，但是如果参数过大溢出它的缓冲区，<code>fgets</code>不会引起错误。</p>
</blockquote>
<p>一个例子</p>
<pre><code>/*
  把标准输入读取的文本行逐行复制到标准输出。
*/
#include &lt;stdio.h&gt;

#define MAX_LINE_LENGTH 1024

void copylines(FILE *input, FILE *output)
{
  char buffer[MAX_LINE_LENGTH];
  
  while( fgets(buffer, MAX_LINE_LENGTH, input) != NULL)
    fputs(buffer, output);
}
</code></pre>
<h2>15.10 格式化的行I/O</h2>
<ul>
<li>“格式化的行I/O”这个名字从某种意义上并不准确，因为 <code>scanf</code> 和 <code>printf</code> 函数家族并不仅限于单行。它们也可以在行的一部分或多行上执行I/O操作。</li>
</ul>
<h3>15.10.1 scanf家族</h3>
<pre><code>int fscanf(FILE *stream, char const *format, ...);
int scanf(char const *format, ...);
int sscanf(char const *string, char const *format, ...);
</code></pre>
<p><em><strong>函数无法验证对应的指针参数输入是否是对应格式代码的正确类型。函数会假定它们是正确的，于是继续执行并使用它们。</strong></em></p>
<h3>15.10.2 scanf格式代码</h3>
<ul>
<li><strong>空白字符</strong>————与输入中的零个或多个空白字符相匹配，在处理过程中将被忽略。</li>
<li><strong>格式代码</strong>————它们指定函数如何解释接下来的输入字符。</li>
<li><strong>其他字符</strong>————当任何其他字符出现在格式字符串时，下一个输入字符必须与它匹配。如果匹配，该输入字符随后被丢弃；如果不匹配，函数就不再读取直接返回。</li>
</ul>
<h4>格式代码格式</h4>
<ul>
<li>
<p>格式代码都是以一个百分号开头，后面可以是</p>
<ul>
<li>一个可选的星号（赋值抑制符）</li>
<li>一个可选的宽度</li>
<li>一个可选的限定符</li>
<li>格式代码</li>
</ul>
</li>
<li>
<p>可选的星号具体使用方法
假输入流中有数据：<code>Item_A: 100, Item_B: 200</code></p>
</li>
</ul>
<pre><code>int val_b;
// 使用 %*s 跳过 "Item_A:"
// 使用 %*d 跳过 100
// 使用 %*c 跳过 逗号和空格
// Item_B: 选项被匹配后丢弃
// 只读取Item_B 的值
scanf("%*s %*d, Item_B: %d",&amp;val_b);

// 结果：val_b 将被赋值为 200，流中的 "Item_A: 100, "部分被跳过
</code></pre>
<h4>scanf限定符</h4>
<table>
<thead>
<tr>
<th>限定符</th>
<th>作用 (用于指定参数大小)</th>
<th>适用的类型码</th>
<th>对应的 C 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>h</code></strong></td>
<td>读取短整数（Half word size）</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>short int</code>, <code>unsigned short int</code></td>
</tr>
<tr>
<td><strong><code>hh</code></strong></td>
<td>读取字符大小的整数</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>signed char</code>, <code>unsigned char</code></td>
</tr>
<tr>
<td><strong><code>l</code></strong></td>
<td>读取长整数</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>long int</code>, <code>unsigned long int</code></td>
</tr>
<tr>
<td><strong><code>ll</code></strong></td>
<td>读取超长整数</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>long long int</code>, <code>unsigned long long int</code></td>
</tr>
<tr>
<td><strong><code>l</code></strong></td>
<td>读取双精度浮点数</td>
<td><code>f</code>, <code>e</code>, <code>g</code>, <code>a</code></td>
<td><code>double</code> (注意：<code>%f</code> 读取 <code>float</code>)</td>
</tr>
<tr>
<td><strong><code>L</code></strong></td>
<td>读取超长双精度浮点数</td>
<td><code>f</code>, <code>e</code>, <code>g</code>, <code>a</code></td>
<td><code>long double</code></td>
</tr>
<tr>
<td><strong><code>z</code></strong></td>
<td>读取 <code>size_t</code> 类型（无符号）</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>size_t</code></td>
</tr>
<tr>
<td><strong><code>j</code></strong></td>
<td>读取最大宽度整数</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>intmax_t</code>, <code>uintmax_t</code></td>
</tr>
<tr>
<td><strong><code>t</code></strong></td>
<td>读取指针差值类型</td>
<td><code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, <code>n</code></td>
<td><code>ptrdiff_t</code></td>
</tr>
</tbody>
</table>
<p>一个不能总是正确接收参数的<code>fscanf()</code></p>
<pre><code>  int a, b, c;
  a = b = c = 0;
  FILE *f = (FILE *)fopen("./test.txt", "r+");
  FILE *f1 = (FILE *)fopen("./testout.txt", "r+");
  if (f == NULL || f1 == NULL) {
    perror("Failed to read from stream test.txt.\n");
    return EXIT_FAILURE;
  }

  if (fscanf(f, "%d %d", &amp;a, &amp;b) ==
      2) { // 这里如果接收的不是两个整型变量就会导致循环终止，且fscanf跳过空白字符，
           // 所以它没有办法验证这两个值是位于同一行还是分属于两个不同的输入行
    fprintf(stdout, "Two number i got from stream f to stdout is %d - %d\n", a,
            b);
  }

  // 重置文件指针到文件开头
  rewind(f);

  int nfield = fscanf(f, "%4d %4d %4d", &amp;a, &amp;b, &amp;c);
  if (nfield == 2)
    fprintf(f1, "Two number i got from stream f to f1 is %d - %d", a, b);
  else if (nfield == 3)
    fprintf(f1, "Three number i got from stream f to f1 is %d - %d - %d", a, b,
            c);

  fclose(f1);
  fclose(f); 
</code></pre>
<p>一个更为可靠的方法读取这种类型的<code>fscanf()</code></p>
<pre><code>#include &lt;stdio.h&gt;

#define BUFFER_SIZE 100

void function(FILE *input)
{
  int a, b, c, d, e;
  char buffer[BUFFER_SIZE];
  
  while (fgets(buffer, BUFFER_SIZE, input) != NULL){
    if (sscanf(buffer,"%d %d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d, &amp;e) != 4)
    {
      fprintf(stderr,"Bad input skipped: %s", buffer);
      continue;
    }
  }
  // 处理这组输入
}
</code></pre>
<h3>15.10.3 printf家族</h3>
<pre><code>int fprintf(FILE *stream, char const *format, ...);
int printf(char const *format, ...);
int sprintf(char *buffer, char const *format, ...);
</code></pre>
<blockquote>
<p><code>sprintf()</code>被认为是有缺陷的(不安全的)，主要因为它存在固有的缓冲区溢出(Buffer Overflow)风险。</p>
<p>当 buffer被设置为一个固定大小的缓冲区时会有可能超出限制，且无法阻止其<strong>继续覆盖相邻的内存</strong>。</p>
<blockquote>
<p>C99 标准引入了 <code>snprintf</code> 解决<code>sprintf</code>的安全问题。</p>
</blockquote>
</blockquote>
<pre><code>int snprintf(char *str, size_t size, const char *format, ...);
</code></pre>
<h3>15.10.4 printf 格式代码</h3>
<p><strong><code>printf</code>家族格式代码和<code>scanf</code>格式代码类似</strong></p>
<p>几个使用<code>printf</code>格式代码的例子</p>
<ol>
<li>用<code>printf</code>格式字符串</li>
</ol>
<table>
<thead>
<tr>
<th>格式代码</th>
<th>转换后的字符串</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>A</td>
<td>ABC</td>
<td>ABCDEFGH</td>
</tr>
<tr>
<td>%5s</td>
<td>[][][][]A</td>
<td>[][]ABC</td>
<td>ABCDEFGH</td>
</tr>
<tr>
<td>%.5s</td>
<td>A</td>
<td>ABC</td>
<td>ABCDE</td>
</tr>
<tr>
<td>%5.5s</td>
<td>[][][][]A</td>
<td>[][]ABC</td>
<td>ABCDE</td>
</tr>
<tr>
<td>%-5s</td>
<td>A[][][][]</td>
<td>ABC[][]</td>
<td>ABCDEFGH</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>%.5s</code> 中的<code>.5</code>是限制精度(限制字符数)，<code>%.5d</code>中的<code>.5</code>是限制宽度的，而<code>%5d</code>是限制精度(限制数字位数)。</p>
</blockquote>
<ol>
<li>用<code>printf</code>格式化整数</li>
</ol>
<table>
<thead>
<tr>
<th>格式代码</th>
<th>转换后的数值</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>1</td>
<td>-12</td>
<td>12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%6d</td>
<td>[][][][][]1</td>
<td>[][][]-12</td>
<td>[]12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%.4d</td>
<td>0001</td>
<td>-0012</td>
<td>12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%6.4d</td>
<td>[][]0001</td>
<td>[]-0012</td>
<td>[]12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%-4d</td>
<td>1[][][][]</td>
<td>-12[]</td>
<td>12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%04d</td>
<td>0001</td>
<td>-012</td>
<td>12345</td>
<td>123456789</td>
</tr>
<tr>
<td>%+d</td>
<td>+1</td>
<td>-12</td>
<td>+12345</td>
<td>+123456789</td>
</tr>
</tbody>
</table>
<ol>
<li>用<code>printf</code>格式化浮点数</li>
</ol>
<table>
<thead>
<tr>
<th>格式代码</th>
<th>转换后的数值</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>.01</td>
<td>.00012345</td>
<td>12345.6789</td>
</tr>
<tr>
<td>%f</td>
<td>1.000000</td>
<td>0.010000</td>
<td>0.000123</td>
<td>12345.678900</td>
</tr>
<tr>
<td>%10.2f</td>
<td>[][][][][][]1.00</td>
<td>[][][][][][]0.01</td>
<td>[][][][][][]0.00</td>
<td>[][]12345.67</td>
</tr>
<tr>
<td>%e</td>
<td>1.000000e+00</td>
<td>1.000000e-02</td>
<td>1.234500e-04</td>
<td>1.234568e+04</td>
</tr>
<tr>
<td>%.4e</td>
<td>1.0000e+00</td>
<td>1.0000e-02</td>
<td>1.2345e-04</td>
<td>1.2346e+04</td>
</tr>
<tr>
<td>%g</td>
<td>1</td>
<td>0.01</td>
<td>0.00012345</td>
<td>12345.7</td>
</tr>
</tbody>
</table>
<ol>
<li>用<code>printf</code>格式化大浮点值</li>
</ol>
<table>
<thead>
<tr>
<th>格式代码</th>
<th>转换后的数值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>6.023e23</td>
</tr>
<tr>
<td>%f</td>
<td>6.02299999999999975882752.000000</td>
</tr>
<tr>
<td>%10.2f</td>
<td>6.02299999999999975882752.000000</td>
</tr>
<tr>
<td>%e</td>
<td>6.023000e+23</td>
</tr>
<tr>
<td>%.4e</td>
<td>6.0230e+23</td>
</tr>
<tr>
<td>%g</td>
<td>6.023e+23</td>
</tr>
</tbody>
</table>
<h2>15.11 二进制I/O</h2>
<ul>
<li>把数据写到文件效率最高的方法是用二进制形式写入。二进制输出<strong>避免了在数值转换为字符串过程中所涉及的开销和精度损失</strong>。但二进制数据并非人眼所能阅读，所以这个技巧只有<strong>当数据将被另一个程序按顺序读取时</strong>才能使用。</li>
</ul>
<p><code>fread</code>函数用于读取二进制数据，<code>fwrite</code>函数用于写入二进制数据。</p>
<pre><code>size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
size_t fwrite(void *buffer, size_t size, size_t count, FILE* stream);
</code></pre>
<p><code>buffer</code>是一个指向用于保存数据的内存位置的指针，<code>size</code>是缓冲区中每个元素的字节数，<code>count</code>是读取或写入的元素数，当然<code>stream</code>是数据读取或写入的流。</p>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// 1. 定义一个存储数据的结构体
typedef struct {
  int id;
  char name[20];
  float salary;
} Employee;

// 辅助函数：打印结构体内容
void print_employee(const Employee *e) // const *类型 指向常量的指针
{
  fprintf(stdout, "ID: %d, Name: %-20s, Salary: %.2f\n", e-&gt;id, e-&gt;name,
          e-&gt;salary);
}

// 定义文件名
#define DATA_FILE "employees.bin"

int main(void) {
  // 2. 准备数据：一个结构体数组
  Employee staff_data[] = {{101, "Alice Johnson", 60000.00f},
                           {102, "Bob Smith", 75000.50f},
                           {103, "Charlie Brown", 50000.25f}};
  const size_t num_employees = sizeof(staff_data) / sizeof(Employee);

  // ------------------------------------------------------------------------
  // 第一步：使用 fwrite 将结构体数组写入文件（输出流）
  // ------------------------------------------------------------------------

  FILE *output_file = fopen(DATA_FILE, "wb"); // write binary
  if (output_file == NULL) {
    perror("Error opening output file");
    return EXIT_FAILURE;
  }

  // fwrite(ptr, size, count, stream)
  // ptr: 要写入的数据块的起始地址
  // size: 每个数据块的大小（这里是 Employee 结构体的大小）
  // count: 要写入的数据块的数量（这里是数组元素的数量）
  // stream: 文件流指针

  size_t written_count =
      fwrite(staff_data, sizeof(Employee), num_employees, output_file);

  if (written_count == num_employees) {
    fprintf(stdout, "成功将 %zu 个 Employee 记录写入文件：%s\n", written_count,
            DATA_FILE);
  } else {
    fprintf(stderr, "警告：写入失败或部分失败。\n");
  }

  fclose(output_file);

  // ------------------------------------------------------------------------
  // 第二步：使用 fread 从文件中读取结构体数组（输入流）
  // ------------------------------------------------------------------------

  FILE *input_file = fopen(DATA_FILE, "rb"); // read binary
  if (input_file == NULL) {
    perror("Error opening input file for reading");
    return EXIT_FAILURE;
  }

  // 3. 准备接收数据的缓冲区（创建一个新的数组来存储读取的数据）
  Employee read_data[num_employees];

  fprintf(stdout, "\n从文件读取数据并输出到标准输出(stdout)：\n");
  printf("--------------------------------------------------------\n");

  // fread(ptr, size, count, stream)
  // ptr: 存储读取数据的内存地址
  // size: 每个数据块的大小（这里是 Employee 结构体的大小）
  // count: 尝试读取的数据块的数量
  // stream: 文件流指针
  size_t read_count =
      fread(read_data, sizeof(Employee), num_employees, input_file);

  if (read_count == num_employees) {
    printf("成功读取 %zu 个 Employee 记录。\n", read_count);

    // 4. 将读取到的结构体数组元素输出到标准输出
    for (size_t i = 0; i &lt; read_count; i++) {
      printf("Record %zu: ", i + 1);
      print_employee(&amp;read_data[i]);
    }
  } else {
    fprintf(stderr, "警告：尝试读取 %zu 个记录，但只读取了 %zu 个。\n",
            num_employees, read_count);
  }

  fclose(input_file);

  // 清理创建的文件（可选）
  // remove(DATA_FILE);

  return EXIT_SUCCESS;
}
</code></pre>
<h2>15.12 刷新和定位数据</h2>
<p>当我们需要立即把输出缓冲区的数据进行物理写入时，应该使用<code>fflush</code>这个函数。例如，调用<code>fflush</code>函数保证调试信息实际打印出来，而不是保存在缓冲区中直到以后才打印。</p>
<pre><code>int fflush(FILE *stream);
</code></pre>
<p>在正常情况下，数据以线性的方式写入，这意味着后面写入的数据在文件中的位置是在以前所有写入数据的后面。C同时支持随机访问I/O，也就是以任意顺序访问文件的不同位置。
<code>ftell</code>和<code>fseek</code>函数支持上面的操作。</p>
<pre><code>long ftell(FILE *stream);
int fseek(FILE *stream, long offset, int from);
</code></pre>
<p><code>ftell</code>返回流的当前位置，也就是说，下一个读取或写入将要开始的位置距离文件起始位置的偏移量(offset)。这个函数允许你保存一个文件的当前位置，这样你可能在将来回到这个位置。在二进制流中这个值就是当前位置距离文件其实位置之间的字节数。</p>
<p>在文本流中这个值表示一个位置，但它并不一定准确地表示当前位置和文件起始位置之间的字符数，因为有些系统将对行末字符进行翻译转换。但是，<code>ftell</code>函数返回的值总是可以用于<code>fseek</code>函数中，作为一个距离文件起始位置的偏移量。</p>
<p><code>fseek</code>函数运行你在一个流中定位。这个操作将改变下一个读取或写入操作的位置。它的第一个参数是需要改变的流，第二个和第三个参数标识文件中需要定位的位置。</p>
<p>试图定位到一个文件的起始位置之前是一个错误。定位到文件尾之后并进行写入将扩展这个文件。定位到文件尾之后并进行读取将导致返回一条“到达文件尾”的信息。在二进制流中，从<strong>SEEK_END</strong>进行定位可能不被支持，所以应该避免。在文本流中，如果from是<strong>SEEK_CUR</strong>或<strong>SEEK_END</strong>，offset必须是零。如果from是<strong>SEEK_SET</strong>，offset必须是一个从同一个流中以前调用<code>ftell</code>所返回的值。</p>
<table>
<thead>
<tr>
<th>如果from是</th>
<th>你将定位到...</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEEK_SET</td>
<td>从流的起始位置起offset个字节，offset必须是一个非负值</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>从流的当前位置起offset个字节，offset可正可负</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>从流的尾部位置起offset个字节，offset可正可负。如果是正值它将定位到文件尾的后面</td>
</tr>
</tbody>
</table>
<p>另外还有三个额外的函数，用一些限制更严的方式指执行相同的任务。</p>
<pre><code>void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *position);
int fsetpos(FILE *stream, fpos_t const *position);
</code></pre>
<p><code>rewind</code>函数将读/写指针设置回指定流的起始位置。它同时清除流的错误提示标志。<code>fgetpos</code>和<code>fsetpos</code>函数分别是<code>ftell</code>和<code>fseek</code>函数的替代方案。</p>
<p>它们的主要区别在于这对函数接受一个指向<code>fpos_t</code>的指针作为参数。<code>fgetpos</code>在这个位置存储文件的当前位置，<code>fsetpos</code>把文件位置设置为存储在这个位置的值。</p>
<p>一个使用这些定位函数的例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define FILENAME "demo_file.txt"

int main(void) {
  FILE *fp;

  // ===================================================================
  // 1. 打开文件并写入数据 (使用 "w+" 模式允许读写)
  // ===================================================================

  fp = fopen(FILENAME, "w+");
  if (fp == NULL) {
    perror("Error opening file");
    return EXIT_FAILURE;
  }

  printf("--- 开始写入和控制文件指针 ---\n");

  // 写入第一个字符串
  fputs("ABCDEFGHIJKLMNOP", fp);
  printf("1. 写入 'ABCDEFGHIJKLMNOP'\n");

  // -- fflush 示例 --
  // 尽管没有换行符，fflush 也会强制将数据从缓冲区写入磁盘
  fflush(fp); // fputs没有写入换行符，这里本来fputs的
              // 第一个参数写入到缓冲区还未到fp中，但是
              // 执行fflush可以强制从缓冲区写入磁盘
  printf("2. 使用fflush 强制刷新数据到文件。\n");

  // -- ftell 和 fgetpos 示例 --

  long initial_pos = ftell(fp); // 记录当前位置 （通常是16，即字符串末尾）
  fpos_t saved_fpos;
  fgetpos(fp, &amp;saved_fpos); // 记录当前位置到 fpos_t 结构体中

  printf("3. 当前文件指针位置(ftell): %ld\n", initial_pos);

  // 写入第二个字符串
  fputs("XYZ", fp);
  printf("4. 写入 'XYZ'。\n");

  // -- fssek 示例 --
  // fseek(stream, offset, origin);
  // origin: SEEK_SET 从文件开头， SEEK_CUR 从当前位置，SEEK_END 从文件末尾

  // 将指针 重新定位到第五个字符(索引5)
  fseek(fp, 5, SEEK_SET);
  printf("5. 使用 fseek(5, SEEK_SET) 跳转到索引5。\n");

  // 写入新数据 ，会覆盖掉原有的 'FGHI'
  fputs("1234", fp);
  printf("6. 写入 '1234' (覆盖掉原有的 'FGHI').\n");

  // -- fsetpos 示例 --

  // 将指针重新定位回之前 fgetpos 记录的位置 (initial_pos = 16)
  fsetpos(fp, &amp;saved_fpos);
  printf("7. 使用 fsetpos 跳转回保存的位置(%ld)。\n", initial_pos);

  // 写入数据，会在 16 处 继续 写入
  fputs("999", fp);
  printf("8. 写入'999'。\n");

  // --- rewind 示例 ---
  rewind(fp);
  printf("9. 使用 rewind 将指针 重置到文件开头。\n");

  // ===================================================================
  // 2. 从开头读取最终文件内容
  // ===================================================================

  printf("\n--- 读取文件内容进行验证 ---\n");
  char buffer[50];

  // 尝试从头读取整个文件
  if (fgets(buffer, sizeof(buffer), fp) != NULL)
    printf("文件最终内容：%s\n", buffer);
  else
    printf("读取文件失败\n");

  fclose(fp);

  return EXIT_SUCCESS;
}
</code></pre>
<h2>15.13 改变缓冲方式</h2>
<p>两种改变流缓冲方式的函数</p>
<pre><code>void setbuf(FILE* stream, char *buf);
int setvbuf(FILE* stream, char *buf, int mode, size_t size);
</code></pre>
<p><code>setbuf</code> 设置了另一个数组，用于对流进行缓冲。这个数组的字符长度必须为BUFSIZ(在stdio.h中定义)。为一个流自行指定缓冲区可以防I/O函数库为它动态分配一个缓冲区。如果用一个NULL参数调用这个函数，<code>setbuf</code>函数将关闭流的所有缓冲方式。字符准确地将程序所规定的方式进行读取和写入。</p>
<blockquote>
<p>一个流缓冲区使用一个自动数组是很危险的。</p>
</blockquote>
<p><code>setvbuf</code>函数更为通用。<code>mode</code>参数用于指定缓冲的类型。<strong>_IONBF</strong>指定一个不缓冲的流，<strong>_IOLBF</strong>指定一个行缓冲流，<strong>_IOLBF</strong>指定一个行缓冲流。所谓行缓冲，就是每当一个换行符写入到缓冲区时，缓冲区便进行刷新。</p>
<p><code>buf</code>和<code>size</code>参数用于指定需要使用的缓冲区。如果<code>buf</code>为NULL，那么<code>size</code>的值必须是0。
一般而言，最好用一个长度为BUFSIZ的字符数组作为缓冲区。</p>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define FILENAME "big_buffer_test.txt"
#define CUSTOM_BUF_SIZE 4096 * 4 // 16 KB 的缓冲区大小

int main(void) {
  FILE *fp;
  char custom_buffer[CUSTOM_BUF_SIZE]; // 声明自定义的内存缓冲区

  // 1. 打开文件进行写入
  fp = fopen(FILENAME, "w");
  if (fp == NULL) {
    perror("Error opening file.");
    return EXIT_FAILURE;
  }

  // 2. 使用 setvbuf 设置为全缓冲模式， 并指定自定义缓冲区
  // 目标：只有当 16KB 缓冲区写满时，才进行一次磁盘写入操作
  int result = setvbuf(fp, custom_buffer, _IOFBF, CUSTOM_BUF_SIZE);

  if (result != 0) {
    fprintf(stderr, "setvbuf 设置失败!\n");
    fclose(fp);
    return EXIT_FAILURE;
  }

  printf("文件流已设置为 %zu 字节的全缓冲模式。\n", (size_t)CUSTOM_BUF_SIZE);

  // 3. 写入数据
  for (int i = 0; i &lt; 100; i++) {
    fprintf(fp, "Line %d : This is buffered data.\n", i);
  }

  printf("数据已写入缓冲区，但可能尚未写入磁盘。\n");
  // 此时，数据仍在内存中的 custom_buffer 中，直到缓冲区满或关闭。

  // 4. 关闭文件(关闭时会自动冲刷缓冲区)
  fclose(fp);
  printf("文件已关闭，缓冲区内容已冲刷到磁盘。\n");

  // remove(FILENAME); // 清理原文件(可选)

  return EXIT_FAILURE;
}
</code></pre>
<h2>15.14 流错误函数</h2>
<p>下面的函数用于判断和管理流的状态</p>
<pre><code>int feof(FILE *stream);
int ferror(FILE *stream);
void clearerr(FILE* stream);
</code></pre>
<p>如果流当前处于文件尾，<code>feof</code>函数返回真。这个状态可以通过对流执行<code>fseek</code>、<code>rewind</code>或<code>fsetpos</code>函数来清除。<code>ferror</code>函数报告流的错误状态，如果出现任何读/写错误函数就返回真。最后<code>clearerr</code>函数对指定流的错误标志进行重置。</p>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define FILENAME "status_demo.txt"

// 辅助函数：检查并报告文件状态
void report_status(FILE *fp, const char *message);

int main(void) {
  FILE *fp = NULL;
  int c;

  // 1. 创建并初始化文件
  fp = fopen(FILENAME, "w");
  if (fp == NULL)
    return EXIT_FAILURE;
  fputs("Hello C I/O.\n", fp);
  fclose(fp);

  // ===================================================================
  // 步骤 A: 正常读取直到 EOF (feof 示例)
  // ===================================================================

  fp = fopen(FILENAME, "r");
  if (fp == NULL)
    return EXIT_FAILURE;

  printf("1. 首次打开文件，指针位于开头。\n");
  report_status(fp, "状态A - 读取前");

  // 读取所有字符直到文件结束
  while ((c = fgetc(fp)) != EOF) {
    // 确保所有数据都被消耗
  }

  printf("\n2. 已读取文件所有内容(fgetc 返回 EOF)。\n");

  // 此时，文件指针越界，EOF标志被设置
  report_status(fp, "状态B - 读取到 EOF 之后");

  // ===================================================================
  // 步骤 B: 制造错误并清除 (ferror 和 clearerr 示例)
  // ===================================================================

  // 使用 fseek 强制将指针移动到文件末尾（但文件仍然是只读模式）
  // 尝试在只读文件上写入数据，在某些系统上会设置错误标志。
  fseek(fp, 0, SEEK_END);

  // 尝试写入数据，由于文件以 "r" 模式打开（只读），这将失败，并设置错误标志
  // 注意：虽然不能写入，但 ferror 通常在尝试一个非法操作后被设置。
  // 在本例中，我们尝试在只读文件上使用 fputc，它会失败并设置 ferror 标志。
  c = fputc('X', fp);

  // 检查 fputc 是否失败(通常返回 EOF)
  if (c == EOF) {
    printf("\n3. 尝试在只读流上写入数据(fputc)失败。\n");
  }

  // 此时，错误标志 ferror 被设置
  report_status(fp, "状态C - 尝试非法写入后");

  // clearerr 示例
  clearerr(fp);
  printf("4. 使用 clearerr() 清除了 EOF 和错误标志。\n");

  report_status(fp, "状态D - clearerr() 之后");

  fclose(fp);
  remove(FILENAME); // 清理文件

  return EXIT_FAILURE;
}

void report_status(FILE *fp, const char *message) {
  printf("\n--- %s ---\n", message);

  // feof(fp): 检测是否到达文件末尾
  if (feof(fp)) {
    printf("FE_EOF: 文件流已到达文件末尾 (EOF)。\n");
  } else {
    printf("FE_EOF: 文件流未到达文件末尾。\n");
  }

  // ferror(fp)：检测是否发生了 I/O 错误
  if (ferror(fp)) {
    printf("F_ERROR: 文件流发生 I/O 错误。\n");
  } else {
    printf("F_ERROR: 文件流状态正常。\n");
  }
}
</code></pre>
<h2>15.15 临时文件</h2>
<p>使用<code>tempfile()</code>函数创建一个以<code>wb+</code>模式打开的文本文件用来临时保存数据。当程序结束时这个文件便被删除<code>自动被执行remove()</code>函数。</p>
<pre><code>FILE *tmpfile(void);
</code></pre>
<blockquote>
<p>如果想要文件以只读模式打开或不以<code>wb+</code>模式打开必须使用<code>fopen()</code>函数操作</p>
</blockquote>
<p>可以使用<code>tmpnam()</code>函数为临时文件创建一个文件名</p>
<blockquote>
<p>tmpnam() 仅仅是生成一个唯一的文件名字符串，但不创建文件。你需要手动使用 fopen() 来创建和打开文件，并负责在程序结束时手动删除它。且<strong>tmpnam</strong>不安全！</p>
</blockquote>
<pre><code>char *tmpnam(char *name);
</code></pre>
<p>两个例子</p>
<pre><code># include &lt;stdio.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;
int main(void) {
  FILE *tmp_fp;
  char write_data[] = "Temporary data buffer";
  char read_buffer[100];

  // 1. 创建临时文件流
  // FILE* tmpfile(void);
  tmp_fp = tmpfile();

  if (tmp_fp == NULL) {
    perror("Failed to open tmpfile.\n");
    return EXIT_FAILURE;
  }

  printf("成功创建临时文件流。该文件将在程序退出时自动删除。\n");

  // 2. 写入数据到临时文件
  if (fputs(write_data, tmp_fp) != EOF) {
    printf("写入数据成功：\"%s\"\n", write_data);
  } else {
    perror("Error writing to temporary file");
  }

  // 3. 将文件指针重置到开头
  rewind(tmp_fp);

  // 4. 从临时文件读取数据
  if (fgets(read_buffer, sizeof(read_buffer), tmp_fp) != NULL) {
    printf("从临时文件读取数据：\"%s\"\n", read_buffer);
  } else {
    perror("Error reading from temporary file");
  }

  // 5. 关闭文件流
  // 当文件流关闭时，操作系统会自动删除这个临时文件

  if (fclose(tmp_fp) == 0) {
    printf("\n临时文件流关闭成功，临时文件已被删除。\n");
  } else {
    perror("Error closing temporary file");
  }

  return EXIT_SUCCESS;
}
</code></pre>
<pre><code># include &lt;stdio.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;
# include &lt;time.h&gt;

int main(void) {
  char
      temp_filename[L_tmpnam]; // L_tmpnam 是 &lt;stdio.h&gt; 中的宏，保证缓冲区足够大
  FILE *fp;

  // 1. 生成一个唯一的文件名
  // 如果传入NULL， tmpnam 会使用 内部静态缓冲区，但我们使用局部数组更安全
  if (tmpnam(temp_filename) != NULL) {
    printf("生成的临时文件名是：%s\n", temp_filename);
  } else {
    fprintf(stderr, "tmpnam failed to generate temporary file.");
    return EXIT_FAILURE;
  }

  // 2. 手动创建和打开文件
  fp = fopen(temp_filename, "w");
  if (fp == NULL) {
    perror("Error opening the generated temporary file");
    return EXIT_FAILURE;
  }

  printf("手动创建并打开了文件。\n");

  // 3. 写入和关闭文件...
  fprintf(fp, "This is manually managed temporary data.\n");
  fclose(fp);

  // 4. 【重要】手动删除文件
  if (remove(temp_filename) == 0) {
    printf("手动删除了临时文件：%s\n", temp_filename);
  } else {
    perror("Error deleting temporary file");
  }
  return EXIT_SUCCESS;
}
</code></pre>
<h2>15.16 文件操纵函数</h2>
<p>有两个函数用于操纵文件但不执行任何输入/输出操作。</p>
<pre><code>int remove(char const *filename);
int rename(char const *oldname, char const *newname);
</code></pre>
<p><code>remove</code>函数删除一个指定的文件。如果当remove被调用时文件处于打开状态，其结果取决于编译器。</p>
<p><code>rename</code>函数用于改变一个文件的名字，从<strong>oldname</strong>改为<strong>newname</strong>。如果已经有一个<strong>newname</strong>的文件存在，其结果取决于编译器。</p>
<blockquote>
<p>Tips</p>
<blockquote>
<ol>
<li>调试用<code>printf</code>后加<code>fflush</code></li>
<li>检查<code>fopen</code>返回值</li>
<li>改变文件的位置将<strong>丢弃</strong>任何被退回到流的字符</li>
<li>在使用<code>fgets</code>时指定较大的缓冲区</li>
<li><code>gets</code>,<code>sprintf</code>溢出检测</li>
<li>使用自动数组作为流的缓冲区时应多加小心</li>
<li>使用<code>mkstemp</code>替代<code>tmpnam</code></li>
</ol>
</blockquote>
</blockquote>
<h1>🤤 标准函数库</h1>
<h2>16.1 整型函数</h2>
<ul>
<li>这组函数返回整型值。这些函数分为三类：<strong>算术</strong>、<strong>随机数</strong>和<strong>字符串转换</strong>。</li>
</ul>
<h3>16.1.1 算数&lt;stdlib.h&gt;</h3>
<p>标准库函数包含了4个整型算数函数。</p>
<pre><code>int abs(int value);
long int labs(long int value);
div_t div(int numerator, int denominator);
ldiv_t ldiv(long int numer, long int denom);
</code></pre>
<p><code>abs</code>函数返回它的参数的绝对值。如果其结果不能用一个整数表示，这个行为是未定义的。
<code>labs</code>用于执行相同的任务，但它作用的对象是长整数。</p>
<p><code>div</code>函数把它的第二个参数(分母)除以第一个参数(分子)，产生商和余数，用一个<code>div_t</code>结构返回。这个结构包含下面两个字段。</p>
<pre><code>int quot; // 商
int rem; // 余数 
</code></pre>
<blockquote>
<p>这两个字段并不一定以这个顺序出现。</p>
</blockquote>
<h3>16.2.1 随机数&lt;stdlib.h&gt;</h3>
<p>两个函数可以产生<strong>伪随机数(pseudo-random number)</strong>。</p>
<pre><code>int rand(void);
void srand(unsigned int seed);
</code></pre>
<p><code>rand</code> 返回一个 范围在 0 和 RAND_MAX(至少为32767)之间的伪随机数。
使用<code>srand</code> 获取随机数数列。</p>
<p>常见用法</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt; 

int main(void)
{
  int i, n;
  time_t t; // &lt;time.h&gt;
  
  n = 5;
  
  // 初始化随机数发生器 
  srand((unsigned) time(&amp;t));

  // 输出 0 到 49 之间的 5 个随机数
  for (i = 0; i &lt; n; i++)
  {
    printf("%d\n", rand() % 50);
  }

  return 0;
}
</code></pre>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define TRUE 1
#define FALSE 1

#define PRINT_ARR(ARR, SIZE)                                                   \
  do {                                                                         \
    int __i;                                                                   \
    for (__i = 0; __i &lt; (SIZE); __i++) {                                       \
      printf("%-4d", (ARR)[__i]);                                              \
    }                                                                          \
    printf("\n");                                                              \
  } while (0)

void shuffle(int *deck, int n_cards);

int main(void) {

  int cards[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  fputs("Before shuffle: ", stdout);
  PRINT_ARR(cards, sizeof(cards) / sizeof(cards[0]));

  shuffle(cards, 10);

  fputs("After shuffle: ", stdout);
  PRINT_ARR(cards, sizeof(cards) / sizeof(cards[0]));
  return 0;
}

void shuffle(int *deck, int n_cards) {
  int i;
  static int first_time = TRUE;

  // 如果尚未初始化，用当天的当前时间作为随机数发生器
  if (first_time) {
    first_time = FALSE;
    srand((unsigned int)time(NULL));
  }

  // 通过交换随机对的牌进行 "洗牌"
  for (i = n_cards - 1; i &gt; 0; i -= 1) {
    int where;
    int temp;

    where = rand() % i;
    temp = deck[where];
    deck[where] = deck[i];
    deck[i] = temp;
  }
}
</code></pre>
<h3>16.1.3 字符串转换 &lt;stdlib.h&gt;</h3>
<p>字符串转换函数把字符串转换为数值。其中最简单的函数<code>atoi</code>和<code>atol</code>。</p>
<pre><code>int atoi(char const *string);
long int atol(char const *string);
long int strtol(char const *string, char **unused, int base);
unsigned long int strtoul(char const *string, char **unused, int base);
</code></pre>
<blockquote>
<p>对于上面四个函数第一个参数来说，如果包含了前导空白字符将被跳过；函数把剩余的合法字符转换为指定类型的值。在尾部存在非法缀尾字符也将被忽略。</p>
</blockquote>
<blockquote>
<p><code>atoi</code>和<code>atol</code>分别把字符转换为整数和长整数值。<code>strtol</code>和<code>atol</code>一样把参数字符串转换为long。但是<code>strtol</code>保存一个指向转换值后面第一个字符的指针。如果函数的第二个参数并非NULL，这个指针便保存在第二个参数所指向的位置。<code>strtoul</code>和<code>strtol</code>的执行方式相同，但它产生一个无符号长整数。</p>
</blockquote>
<blockquote>
<p>后两个函数的第三个参数是转换所指向的基数(即进制数)。如果基数为0，任何在程序中用于书写整数字面值的形式都将被接收如<code>0x2af4</code>和<code>0377</code>。</p>
</blockquote>
<pre><code>x = strtol("    590bear", next, 12);
</code></pre>
<p>上面的表达式x的值为9947，并把一个指向字母e的指针保存在next所指向的变量中。</p>
<h4>strtol 和 strtoul 返回的错误值</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>strtol</td>
<td>如果值太大且为负数，返回LONG_MIN。如果值太大且为正数，返回LONG_MAX</td>
</tr>
<tr>
<td>strtoul</td>
<td>如果值太大返回ULONG_MAX</td>
</tr>
</tbody>
</table>
<h2>16.2 浮点型函数</h2>
<ul>
<li>头文件<code>math.h</code>包含了函数库中剩余的数学函数的声明。这些函数的返回值以及绝大多数参数都是double类型。</li>
</ul>
<p>几种错误</p>
<pre><code>1. 未包含头文件math.h

double x;
x = sqrt(5.5);

// 编译器在此之前未曾见到过sqrt函数的原型。

2. 定义域错误(domain error)

sqrt(-5.0);

3. 范围错误(range error)
exp(DBL_MAX);
// 因为结果值太大，这种情况函数会返回HUGE_VAL
</code></pre>
<h3>16.2.1 三角函数&lt;math.h&gt;</h3>
<p>标准函数库提供了常见的三角函数。</p>
<pre><code>double sin(double angle);
double cos(double angle);
double tan(double angle);
double asin(double value);
double acos(double value);
double atan(double value);
double atan2(double x, double y);
</code></pre>
<p><code>sin</code>,<code>cos</code>和<code>tan</code>函数的参数是一个用弧度表示的角度，这些函数分别返回这个角度的正弦、余弦和正切值。</p>
<p><code>asin</code>,<code>acos</code>和<code>atan</code>函数分别返回它们参数的反正弦、反余弦和反正切值。也会出现定义域错误(比如<code>asin</code>和<code>acos</code>的参数并不位于-1和1之间，就会出现一个定义域错误)。</p>
<h3>16.2.2 双曲函数&lt;math.h&gt;</h3>
<pre><code>double sinh(double angle);
double cosh(double angle);
double tanh(double angle);
</code></pre>
<p>这些函数分别返回它们的参数的双曲正弦、双曲余弦和双曲正切值。</p>
<h3>16.2.3 对数和指数函数&lt;math.h&gt;</h3>
<pre><code>double exp(double x);
double log(double x);
double log10(double x);
</code></pre>
<p><code>exp</code>函数返回e值的x次幂，也就是$e^x$<br />
<code>log</code>函数返回x以e为底的对数，也就是自然对数${\ln x}$；<code>log10</code>函数返回x以10为底的对数，也就是${\lg x}$</p>
<blockquote>
<p>任何一个以<code>b</code>为底的对数可以通过下面的公式转换</p>
</blockquote>
<p>$log_b x = \frac{\ln x} {\ln b}$</p>
<p>$log_b x = \frac{\log_e x} {\log_e b}$</p>
<blockquote>
<p>如果它们的参数为负数，两个对数函数都将出现定义域错误。</p>
</blockquote>
<h3>16.2.4 浮点表示形式&lt;math.h&gt;</h3>
<pre><code>double frexp(double value, int *exponent);
double ldexp(double fraction, int exponent);
double modf(double value, double *ipart);
</code></pre>
<p><code>frexp</code>函数计算一个<strong>指数(exponent)<strong>和</strong>小数(fraction)</strong>，这样$\text{fraction} \times 2^
\text{exponent} = \text{value}$，其中 $0.5 &lt;= fraction &lt; 1$，<code>exponent</code>是一个整数。exponent存储于第二个参数所指向的内存的位置。函数返回fraction的值。与它相关的函数<code>ldexp</code>的返回值是$\text{fraction} \times 2^\text{exponent}$也就是它原先的值。当需要在那些浮点格式不兼容的机器之间传递浮点数时，这些函数非常有用。</p>
<p><code>modf</code>函数把一个浮点值分成整数和小数两个部分，每个部分都具有和原值一样的符号。整数部分以double类型存储于第二个参数错指向的内存位置，小数部分作为函数的返回值返回。</p>
<blockquote>
<p>frexp 和 ldexp 函数通常用于浮点数的内部处理，例如实现快速幂或进行高精度计算。</p>
</blockquote>
<h3>16.2.5 幂&lt;math.h&gt;</h3>
<pre><code>double pow(double x, double y);
double sqrt(double x);
</code></pre>
<p><code>pow</code>函数会返回$\text{x}^\text{y}$的值。由于在计算这个值时可能要用到对数，如果x是一个负数且y不是一个整数会出现一个定义域错误。</p>
<p><code>sqrt</code>函数返回其参数的平方根。如果参数为负，就会出现一个定义域错误。</p>
<h3>16.2.6 底数、顶数、绝对值和余数&lt;math.h&gt;</h3>
<pre><code>double floor(double x);
double ceil(double x);
double fabs(double x);
double fmod(double x, double y);
</code></pre>
<p>这些函数都是用来处理浮点数的函数，分别用于取整和求模运算。</p>
<p><code>floor</code>函数为传入的double值向下取整，<code>ceil</code>向上取整，<code>fmod</code>返回x除以y所产生的余数，
<code>fabs</code>返回双精度浮点数绝对值。</p>
<h3>16.2.7 字符串转换 &lt;stdlib.h&gt;</h3>
<pre><code>double atof(char const *string);
double strtod(char const *string, char **unused);
</code></pre>
<p>和<code>strtol</code>,<code>atol</code>类似，任一函数参数包含了前导空白字符，这些字符将被忽略。函数随后将合法的字符转换为一个double值并忽略任何缀尾的非法字符。</p>
<p><code>strtod</code>函数把参数字符串转换为一个double值，其方法和<code>atof</code>类似，但保存一个指向字符串中被转换的值后面的第一个字符的指针。</p>
<blockquote>
<p>值太大会返回 HUGE_VAL，值太小会返回0。这两种情况<code>errno</code>都会被设置为<code>ERANGE</code></p>
</blockquote>
<h2>16.3 日期和时间函数</h2>
<p>函数库提供了一组非常丰富的函数，用于简化日期和时间的处理。它们的原型位于<code>time.h</code>。</p>
<h3>16.3.1 处理器时间 &lt;time.h&gt;</h3>
<p><code>clock</code>函数返回从程序开始执行起处理器所消耗的时间。</p>
<pre><code>clock_t clock(void);
</code></pre>
<p><code>clock</code>函数返回一个数字，由编译器定义。通常是处理器时钟滴答的次数，将这个值除以<strong>CLOCKS_PER_SEC</strong>可以得到秒数。</p>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

// 设置一个工作的函数
void run_program_logic() {
  long long sum = 0;
  for (int i = 0; i &lt; 500000000; i++) {
    sum += i;
  }
  printf("计算结果: %lld\n", sum);

  // 模拟程序执行过程中可能发生的 I/O等待
  // sleep(1); // 如果加上这行，CPU时间不会等待但实际时间会增加1秒
}

// clock不是一个常用的计算墙上时钟时间的好方法
// time() 适用于秒级精度
// gettimeofday() POSIX: 适用于微秒级精度(更常用)
// clock_gettime() POSIX/C11: 更现代，支持纳秒级精度和
// 多种时钟类型(推荐用于高性能测量)

// clock返回的是处理器时钟滴答的次数。把这个值转换成秒要
// 除以常量 CLOCKS_PER_SEC
int main(void) {
  clock_t start_time, end_time;
  double cpu_time_used;
  // 1. 记录开始时间
  start_time = clock();

  // 运行程序
  run_program_logic();

  // 2. 记录结束时间
  end_time = clock();

  // 3. 计算CPU耗时（以秒为单位）
  // 要将clock_t 转换为 double 才能进行浮点除法
  cpu_time_used = ((double)(end_time - start_time)) / CLOCKS_PER_SEC;

  printf("\n--- 运行时间结果 ---\n");
  printf("总的 CPU 滴答数：%ld\n", (long)(end_time - start_time));
  printf("每秒滴答数(CLOCKS_PER_SEC)： %ld\n", (long)CLOCKS_PER_SEC);
  printf("程序 CPU 运行时间：%f 秒\n", cpu_time_used);
  return EXIT_SUCCESS;
}
</code></pre>
<h3>16.3.2 当天时间&lt;time.h&gt;</h3>
<p><code>time</code>函数返回当前的日期和时间。</p>
<pre><code>time_t time(time_t *returned_value);
</code></pre>
<p>如果参数是一个非NULL的指针，时间值也将通过这个指针进行存储。<br />
如果机器无法提供当前日期和时间或时间值太大无法用<code>time_t</code>变量表示，函数返回-1。</p>
<ul>
<li>标准并未规定时间的编码方式，所以不应该使用字面值常量。因为它们在不同的编译器中可能具有不同的含义。</li>
<li>一种常见的表示形式是返回从一个任意选定的时刻开始流逝的秒数。在<strong>MS-DOS</strong>和<strong>UNIX</strong>中，这个时刻是<em>1970年1月1日 00:00:00</em></li>
</ul>
<blockquote>
<p>调用time函数两次并把两个值相减由此判断时间是很有诱惑力的。但这个技巧是很危险的，因为标准<strong>并未要求函数的结果用秒表示</strong>。使用<code>difftime</code>函数计算两次时间差值。</p>
</blockquote>
<h4>日期和时间的转换&lt;time.h&gt;</h4>
<p>用于操作<code>time_t</code>的函数</p>
<pre><code>char *ctime(time_t const *time_value);
double difftime(time_t time1, time_t time2);
</code></pre>
<p><code>ctime</code>函数的参数是一个指向<code>time_t</code>的指针，并返回一个指向字符串的指针，字符串格式为<code>Sun Jul 4 04:02:48 1976\n\0</code>。字符串内部空格是固定的。</p>
<blockquote>
<p>ctime 返回的是一个存储在由编译器分配的静态字符数组的首地址，也就是存储在一个外部静态缓冲区(运行时库的静态/全局区域)，不是由调用者定义和分配的空间。</p>
</blockquote>
<blockquote>
<p>ctime 的设计模式在多线程中存在数据覆盖的风险。</p>
</blockquote>
<p>将调用<code>ctime</code>函数的返回值立即拷贝到一个由调用者分配的字符数组中</p>
<pre><code>char my_buffer[50];
memset(mybuffer,0,sizeof(my_buffer) / sizeof(my_buffer[0]));
time_t t = time(NULL);
char *s = ctime(&amp;t); // 这里的指针s 只是指向了由编译器分配的一个静态字符数组并不是创建了一个新的存储区域
strcpy(my_buffer,s,sizeof(my_buffer) / sizeof(my_buffer[0]));
</code></pre>
<blockquote>
<p>ctime 也可能以 <code>asctime(localtime(time_value))</code>实现。</p>
</blockquote>
<p><code>difftime</code>函数计算$time1 - time2$的差，并把结果值转换为秒。返回值是<strong>double</strong>类型</p>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt; // POSIX sleep() 函数

// 模拟一段耗时的操作
void heavy_operation() {
    printf("开始执行耗时操作...\n");
    
    // 让程序暂停 2 秒，模拟实际经过的时间
    // time() 和 difftime 测量的是这个实际暂停的时间
    sleep(2); 
    
    printf("操作完成。\n");
}

int main() {
    time_t start_time, end_time;
    double elapsed_time;

    // 1. 记录开始时间
    time(&amp;start_time); 

    // 执行需要计时的程序段
    heavy_operation();

    // 2. 记录结束时间
    time(&amp;end_time);

    // 3. 计算时间差
    // difftime(结束时间, 开始时间)
    elapsed_time = difftime(end_time, start_time);

    printf("\n--- 计时结果 ---\n");
    printf("开始时间 (time_t): %ld\n", (long)start_time);
    printf("结束时间 (time_t): %ld\n", (long)end_time);
    printf("实际经过时间 (秒): %.2f\n", elapsed_time);

    return 0;
}
</code></pre>
<p>两个把time_t值转换为一个tm结构的函数，tm结构更方便访问日期和时间的各个组成部分。</p>
<pre><code>struct tm *gmtime(time_t const *time_value);
struct tm *localtime(time_t const *time_value);
</code></pre>
<p><code>gmtime</code>函数把时间值转换为<strong>世界协调时间(Coordinated Universal Time, UTC)</strong>。<strong>UTC</strong>以前被称为<strong>格林尼治标准时间(Greenwich Mean Time)</strong>，这也是gmtime这个名字的来历。
<code>localtime</code>函数把一个时间值转换为当地时间。</p>
<p><code>struct tm</code>结构体成员(字段)</p>
<table>
<thead>
<tr>
<th>成员名</th>
<th>类型</th>
<th>含义</th>
<th>范围/备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>tm_sec</code></strong></td>
<td><code>int</code></td>
<td><strong>秒</strong></td>
<td>$0$ 到 $60$ (允许 $60$ 来处理闰秒)</td>
</tr>
<tr>
<td><strong><code>tm_min</code></strong></td>
<td><code>int</code></td>
<td><strong>分</strong></td>
<td>$0$ 到 $59$</td>
</tr>
<tr>
<td><strong><code>tm_hour</code></strong></td>
<td><code>int</code></td>
<td><strong>时</strong></td>
<td>$0$ 到 $23$</td>
</tr>
<tr>
<td><strong><code>tm_mday</code></strong></td>
<td><code>int</code></td>
<td><strong>月中的第几天（日期）</strong></td>
<td>$1$ 到 $31$</td>
</tr>
<tr>
<td><strong><code>tm_mon</code></strong></td>
<td><code>int</code></td>
<td><strong>月</strong></td>
<td>$0$ 到 $11$ ( $0$ 代表一月， $11$ 代表十二月)</td>
</tr>
<tr>
<td><strong><code>tm_year</code></strong></td>
<td><code>int</code></td>
<td><strong>年</strong></td>
<td><strong>从 1900 年开始计算的年数</strong>。例如，如果年份是 2025，则 <code>tm_year</code> 为 $125$。</td>
</tr>
<tr>
<td><strong><code>tm_wday</code></strong></td>
<td><code>int</code></td>
<td><strong>周中的第几天</strong></td>
<td>$0$ 到 $6$ ( $0$ 代表星期日， $6$ 代表星期六)</td>
</tr>
<tr>
<td><strong><code>tm_yday</code></strong></td>
<td><code>int</code></td>
<td><strong>年中的第几天</strong></td>
<td>$0$ 到 $365$ ( $0$ 代表 1 月 1 日)</td>
</tr>
<tr>
<td><strong><code>tm_isdst</code></strong></td>
<td><code>int</code></td>
<td><strong>夏令时标志</strong></td>
<td>如果夏令时生效，值为正；如果未生效，值为 $0$；如果信息不可用，值为负（通常是 $-1$）。</td>
</tr>
</tbody>
</table>
<p>当有了一个tm结构之后，既可以直接使用tm结构变量内成员值，也可以把它作为参数传递给下面的函数之一。</p>
<pre><code>char *asctime(struct tm const *tm_ptr);
size_t strftime(char *string, size_t maxsize, char const *format,
                struct tm const *tm_ptr);
</code></pre>
<p><code>asctime</code>函数把参数所表示的时间值转换为一个以<code>Sun Jul 4 04:02:48 1976\n\0</code>格式表示的字符串。</p>
<p><code>strftime</code>函数把一个tm结构转换为一个根据某个格式字符串而定的字符串。<em>这个函数在格式化日期方面提供了令人难以置信的灵活性</em>。如果转换结果字符串的长度小于<code>maxsize</code>参数，那么该字符就被复制到第一个参数所指向的数组中，<code>strftime</code>函数返回字符串的长度。否则，函数返回-1且数组的内容是未定义的。</p>
<p>格式字符串包含了普通字符和格式代码。普通字符被复制到它们原先在字符串中出现的位置。
格式代码则被一个日期或时间值代替。格式代码包含一个<code>%</code>字符，后面跟一个表示所需值的字符。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
<th>示例输出</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>年/世纪</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>带世纪的年份</td>
<td><code>2025</code></td>
<td>四位数字</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>不带世纪的年份</td>
<td><code>25</code></td>
<td>两位数字 (00-99)</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>世纪数</td>
<td><code>20</code></td>
<td>(2025 年属于第 20 世纪)</td>
</tr>
<tr>
<td><strong>月</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%m</code></td>
<td>月份</td>
<td><code>11</code></td>
<td>两位数字 (01-12)</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>完整的月份名称</td>
<td><code>November</code></td>
<td>依赖本地环境 (Locale)</td>
</tr>
<tr>
<td><code>%b</code>, <code>%h</code></td>
<td>缩写的月份名称</td>
<td><code>Nov</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><strong>日/周</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%d</code></td>
<td>月份中的日期</td>
<td><code>15</code></td>
<td>两位数字 (01-31)</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>完整的星期几名称</td>
<td><code>Saturday</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><code>%a</code></td>
<td>缩写的星期几名称</td>
<td><code>Sat</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><code>%w</code></td>
<td>周中的第几天</td>
<td><code>6</code></td>
<td>数字 (0=Sunday, 6=Saturday)</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>ISO 8601 周中的第几天</td>
<td><code>6</code></td>
<td>数字 (1=Monday, 7=Sunday)</td>
</tr>
<tr>
<td><code>%j</code></td>
<td>年中的第几天</td>
<td><code>319</code></td>
<td>三位数字 (001-366)</td>
</tr>
<tr>
<td><strong>时</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%H</code></td>
<td>小时 (24 小时制)</td>
<td><code>17</code></td>
<td>两位数字 (00-23)</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>小时 (12 小时制)</td>
<td><code>05</code></td>
<td>两位数字 (01-12)</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>上午/下午标志</td>
<td><code>PM</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><strong>分/秒</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%M</code></td>
<td>分钟</td>
<td><code>12</code></td>
<td>两位数字 (00-59)</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>秒</td>
<td><code>26</code></td>
<td>两位数字 (00-60)</td>
</tr>
<tr>
<td><strong>日期/时间组合</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%x</code></td>
<td>本地日期表示</td>
<td><code>11/15/25</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>本地时间表示</td>
<td><code>17:12:26</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>本地日期和时间</td>
<td><code>Sat Nov 15 17:12:26 2025</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><strong>时区/其他</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>%Z</code></td>
<td>时区名称</td>
<td><code>JST</code> 或 <code>CST</code></td>
<td>依赖本地环境</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分号符号</td>
<td><code>%</code></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>格式字符串</th>
<th>示例输出</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"%Y-%m-%d %H:%M:%S"</code></td>
<td><code>2025-11-15 17:12:26</code></td>
<td>国际通用日期和时间格式</td>
</tr>
<tr>
<td><code>"%a, %b %d, %Y"</code></td>
<td><code>Sat, Nov 15, 2025</code></td>
<td>英文习惯日期格式</td>
</tr>
<tr>
<td><code>"%I:%M %p"</code></td>
<td><code>05:12 PM</code></td>
<td>12 小时制时间</td>
</tr>
</tbody>
</table>
<p><code>mktime</code>函数用于把一个tm结构转换为一个time_t值。</p>
<pre><code>time_t mktime(struct tm *tm_ptr);
</code></pre>
<p>一个例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
  // 1. mktime 手动构建时间结构体
  struct tm time_info = {
      .tm_year = 2025 - 1900, // 年份从 1900 开始算
      .tm_mon = 10 - 1,       // 月份 0 - 11
      .tm_mday = 27,          // 日
      .tm_hour = 23,
      .tm_min = 14,
      .tm_sec = 30,
      .tm_isdst = -1 // 自动判断夏令时
  };

  time_t timestamp = mktime(&amp;time_info);
  printf("mktime生成的时间戳：%ld\n", timestamp);

  // 2. asctime：时间结构体转字符串(固定格式)
  char *ascii_time = asctime(&amp;time_info);
  printf("asctime输出：%s", ascii_time); // 自带换行

  // 3. strftime：自定义格式化时间(最常用)
  char buffer[100];
  strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S 星期%w", // 格式串自由组合
           &amp;time_info);
  printf("strftime自定义：%s\n", buffer);

  return EXIT_SUCCESS;
}

</code></pre>
<blockquote>
<p>其实在这个例子里面使用 asctime非常危险，在编写C语言代码时遇到返回值为指针类型的函数多半要小心是否是返回了一个编译器分配的静态数组指针给你，这会导致在下一次调用这个函数时修改你用指针接收的值，也就是线程不安全的函数，遇到这种情况要及时将静态内存的内容复制出来。</p>
</blockquote>
<pre><code>time_t time1 = time(NULL);
char buffer[26];
strncpy(buffer, asctime(&amp;time1), sizeof(buffer)); // 以后直接使用buffer就不会变化了
</code></pre>
<h2>16.4 非本地跳转&lt;setjmp.h&gt;</h2>
<p><code>setjmp</code>和<code>longjmp</code>函数提供了一种类似goto语句的机制，但它并不局限于一个函数的作用域之内。这些函数常用于深层嵌套的函数调用链。如果在某个低层的函数中检测到一个错误，可以立即返回到顶层函数，不必向调用链中的每个中间层函数返回一个错误标志。</p>
<p>为了使用这些函数必须包含包含头文件&lt;setjmp.h&gt;</p>
<pre><code>int setjmp(jmp_buf state);
void longjmp(jmp_buf state, int value);
</code></pre>
<p>声明一个<code>jmp_buf</code>变量，调用<code>setjmp</code>函数初始化，<code>setjmp</code>返回值为零。<code>setjmp</code>把程序的状态信息（例如，堆栈指针的当前位置和程序的计数器）保存到跳转缓冲区。调用<code>setjmp</code>时所处的函数便称为“顶层”函数。</p>
<p>以后，在顶层函数或其他任何它所调用的函数内的任何地方调用<code>longjmp</code>函数，将导致这个被保存的状态重新恢复。<code>longjmp</code>的效果就是使执行流通过再次从<code>setjmp</code>函数返回，从而立即跳回到顶层函数。</p>
<p>区分<code>setjmp</code>函数的两种不同返回方式，当<code>setjmp</code>函数第一次被调用时，返回0。当<code>setjmp</code>作为<code>longjmp</code>的执行结果再次返回时，它的返回值是<code>longjmp</code>的第二个参数，它必须是个非0值。通过检查它的返回值可以判断是否调用<code>longjmp</code>以及存在多个<code>longjmp</code>可以判断是哪个<code>longjmp</code>被调用。</p>
<h3>16.4.1 实例</h3>
<pre><code>#include &lt;setjmp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 1. 声明一个 jmp_buf 变量，用于在不同函数之间共享执行环境
// 必须在 setjmp 和 longjmp 都能访问到的作用域内声明（通常是全局或静态）
jmp_buf environment;

// 错误代码定义
#define ERROR_FILE_NOT_FOUND 1
#define ERROR_DATA_CORRUPTED 2

// 模拟一个可能失败的深层函数
void process_data(int step);
// 模拟一个中介函数
void intermediate_function();

int main(void) {

  // 第一次调用 setjmp, 设置跳转恢复点。
  int jump_val = setjmp(environment);

  if (jump_val == 0) {
    // 路径A：正常执行
    printf("【Main】：第一次调用 setjmp，设置了错误处理点。\n");
    intermediate_function(); // 开始执行正常业务逻辑
    printf("【Main】：所有功能正常完成。\n");

  } else {
    // 路径B，从longjmp跳转回来
    printf("\n【Main】：发生了非局部跳转！\n");

    switch (jump_val) {
    case ERROR_DATA_CORRUPTED:
      printf("错误处理：代码%d，数据处理失败，程序安全终止。\n", jump_val);
      break;
    case ERROR_FILE_NOT_FOUND:
 printf("错误处理：代码%d，文件未找到。\n", jump_val);
      break;
    default:
      printf("错误处理：发生了未知错误。\n");
      break;
    }
  }
  return EXIT_SUCCESS;
}

void process_data(int step) {
  printf("--- Function: process_data ---\n");

  if (step == 1) {
    printf("Step 1: 正在读取配置文件...\n");
  } else if (step == 2) {
    printf("Step 2: 正在处理数据块...\n");

    // 假设这里发生了致命错误！
    printf("致命错误：数据损坏！\n");
    // 立即跳转回 setjmp的位置，并将 ERROR_DATA_CORRUPTED 作为返回值传递
    longjmp(environment, ERROR_DATA_CORRUPTED);

    // 注意：longjmp 后的代码不会被执行
    printf("这行代码永远不会被执行。\n");
  }
}

void intermediate_function() {
  printf("\n--- Function: intermediate_function ---\n");
  process_data(1);
  process_data(2); // 这一步将触发 longjmp
  printf("Intermediate Function 正常结束。\n");
}
</code></pre>
<h3>16.4.2 何时使用非本地跳转</h3>
<p><code>setjmp</code>和<code>longjmp</code>并不是绝对必需的，因为总是可以通过返回一个错误代码并在调用函数中对其进行检查来实现相同的效果。返回错误代码的方法有时候不是很方便，特别是当函数已经返回了一些值的时候。</p>
<blockquote>
<p>使用setjmp和longjmp必须要遵循某些戒律。不然会像goto一样使用一多会让代码难以理解。</p>
</blockquote>
<h2>16.5 信号</h2>
<p>程序中所发生的事件绝大多数都是由<strong>程序本身所引发的</strong>，例如执行各种语句和请求输入。但是，有些程序必须遇到的事件却不是程序本身所引发的。一个常见的例子就是用户中断了程序。如果部分计算好的结果必须进行保存以避免数据的丢失，程序必须预备对这类事件做出反应，虽然它并没有办法预测什么时候会发生这种情况。</p>
<p>信号就是用于这种目的。<strong>信号(Signal)</strong> 表示一种事件，它可能异步发生，也就是并不与程序执行过程的任何事件同步。如果程序并未安排怎样处理一个特定信号，那么当该信号出现时程序就做出一个缺省的反应。标准并未定义这个缺省反应是什么，但绝大多数编译器都选择终止程序。另外，程序可以调用signal函数，或者忽略这个信号，或者设置一个<strong>信号处理函数(signal handler)</strong>，当信号发生时程序就调用这个函数。</p>
<h3>16.5.1 信号名 &lt;signal.h&gt;</h3>
<table>
<thead>
<tr>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序请求异常终止</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>发生一个算数错误</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测到非法指令</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>检测到对内存的非法访问</td>
</tr>
<tr>
<td>SIGINT</td>
<td>收到一个交互性注意信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>收到一个终止程序的请求</td>
</tr>
</tbody>
</table>
<p><strong>SIGABRT</strong>是一个由<code>abort</code>函数所引发的信号，用于终止程序。</p>
<p>至于哪些错误将引发<strong>SIGFPE</strong>信号则取决于编译器。常见的有算术上溢或下溢以及除零错误。有些编译器对这个信号进行了扩展，提供了关于引发这个信号的操作的特定信息。可能对可移植性有影响。</p>
<p><strong>SIGILL</strong>信号提示CPU试图执行一条非法的指令。这个错误可能由于不正确的编译器设置导致。</p>
<p><strong>SIGSEGV</strong>信号提示程序试图非法访问内存。有两个最常见的原因：一个是程序试图访问未安装于机器上的内存或者访问操作系统未曾分配给这个程序的内存；另一个是程序违反了内存访问的边界要求。后者可能在那些要求数据边界对齐的机器上发生。</p>
<p>前几个信号是<em>同步</em>的，因为它们都是<em>在程序内部发生的</em>。尽管无法预测一个算数错误何时将会发生，如所使用相同的数据反复运行这个程序，每次都会在相同的地方发生相同的错误。</p>
<p>最后两个信号<strong>SIGINT</strong>和<strong>SIGTERM</strong>则是<em>异步</em>的。它们在<em>程序的外部产生</em>，通常是由程序的用户所触发，表示用户试图向程序传达一些信息。</p>
<p><strong>SIGINT</strong>信号在绝大多数机器中都是当用户试图中断程序时发生的。</p>
<p><strong>SIGTERM</strong>则是另一种用于请求终止程序的信号。</p>
<p>一种常用的策略是为<strong>SIGINT</strong>定义一个信号处理函数，目的是执行一些日常维护工作并在程序退出前保存数据。但<strong>SIGTERM</strong>则不配备信号处理函数，这样当程序终止时便不必执行这些日常维护工作。</p>
<h3>16.5.2 处理信号 &lt;signal.h&gt;</h3>
<p>通常我们关心的是怎样处理那些自主发生的信号，也就是无法预测其什么时候会发生的信号。<strong>raise</strong>函数用于显式地引发一个信号。</p>
<pre><code>int raise(int sig);
</code></pre>
<p>调用这个函数将引发它的参数所指定的信号。程序对这类信号的反应和那些自主发生的信号是相同的。可以调用这个函数对信号处理函数进行测试。</p>
<blockquote>
<p>如果误用可能会实现一种非局部的goto效果。</p>
</blockquote>
<p>当一个信号发生时，程序可以使用三种方式对它做出反应。缺省的反应是由编译器定义的，通常是终止程序。程序也可以指定其他行为对信号做出反应：信号可以被忽略，或者程序可以设置一个信号处理函数，当信号发生时调用这个函数。signal函数用于指定程序希望采取的反应。</p>
<pre><code>void (*signal(int sig, void (*handler)(int)))(int);
</code></pre>
<p>分析这个函数原型，首先省略返回类型，对参数进行研究。</p>
<pre><code>signal(int sig, void (*handler)(int));
</code></pre>
<p>第一个参数是信号类型，第二个参数是希望为这个信号设置的信号处理函数。这个处理函数是一个函数指针，它所指向的函数接受一个整型参数且没有返回值。当信号发生时，信号的代码作为参数传递给信号处理函数。这个参数运行一个处理函数处理几种不同的信号。</p>
<p>现在将从原型中的去掉参数</p>
<pre><code>void (*signal())(int);
</code></pre>
<p><strong>signal</strong>是一个函数，它返回一个函数指针，后者所指向的函数接受一个整型参数且无返回值。事实上signal函数返回一个指向该信号以前的处理函数的指针（被替换前的信号处理函数指针）。如果调用signal失败，例如由于非法的信号代码所致，函数将返回SIG_ERR值。这个值是个宏，在<code>signal.h</code>头文件中定义。</p>
<p><code>signal.h</code>头文件海定义了另外两个宏，<strong>SIG_DFL</strong>和<strong>SIG_IGN</strong>，它们可以作为signal函数的第二个参数。<strong>SIG_DFL</strong>恢复对该信号的缺省反应，<strong>SIG_IGN</strong>使该信号被忽略。</p>
<p>总之信号处理函数原型<code>void (*signal(int sig, void (*handler)(int)))(int);</code>声明了一个名为signal的函数，它：</p>
<ol>
<li>接受一个信号编号<code>int sig</code></li>
<li>接受一个指向信号处理函数的函数指针<code>void (*handler)(int)</code></li>
<li>返回一个指向旧的信号处理函数的函数指针</li>
</ol>
<p>用途就是利用<code>signal()</code>函数来设置新的信号处理方式，并保留旧的处理函数地址，方便之后恢复。</p>
<h3>16.5.3 信号处理函数</h3>
<p>当一个已经设置了信号处理函数的信号发生时，系统首先恢复对该信号的缺省行为。这样做是为了防止如果信号处理函数内部也发生这个信号可能导致的无限循环。然后，信号处理函数被调用，信号代码作为参数传递给函数。</p>
<pre><code>void my_handler(int sig){
    // 假设在这里执行了很复杂的操作，并意外再次触发了 SIGINT
    // 如果系统没有恢复缺省行为，my_handler 就会再次被调用，
    // 可能导致堆栈溢出或无限递归，喵！
}

int main(){
  // 第一次调用signal(), 设置 my_handler
  signal(SIGINT, my_handler);
  // ...
}
</code></pre>
<ul>
<li>安全机制：当<strong>SIGINT</strong>发生时，系统内部会执行类似<code>signal(SIGINT,SIG_DFL);</code>的操作，然后再调用<code>my_handler</code>。</li>
<li>如果要保持处理：在信号处理函数的第一行或某处重新调用<code>signal()</code></li>
</ul>
<pre><code>void my_handler(int sig){
  signal(sig,my_handler);
  // 其他处理逻辑
}
</code></pre>
<p>信号处理函数可能执行的工作类型是非常有限的。如果信号是异步的，也就是说不是由于调用<code>abort</code>或<code>raise</code>函数引起的，信号处理函数便不应该调用除signal之外的任何库函数，因为在这种情况下是未定义的。而且信号处理函数除了能向一个类型为<code>volatile sig_atomic_t</code>的静态变量赋一个值以外，可能无法访问其他任何静态数据。为了保证真正的安全，信号处理函数所能做的就是对这些变量之一进行设置然后返回。程序的剩余部分必须定期检查变量的值，看看是否有信号发生。</p>
<p>如果信号是异步的（比如硬件错误、来自操作系统的中断，而不是自己调用 raise() 或 abort() 触发的），那么您的信号处理函数几乎不能调用任何标准库函数，除了 signal() 自身。</p>
<pre><code>void unsafe_handler(int sig){
    // 🚨 危险！在异步信号处理中，调用 printf 是未定义行为！
    // 运行时环境可能不安全，可能破坏 stdio 库的内部状态。
    printf("Oops! Signal %d received.\n", sig); 
    
    // 🚨 危险！
    malloc(10); // 堆栈可能处于不完整状态，malloc内部状态可能混乱！
    
    // 应该调用什么？只有极少数函数安全，比如 _Exit 或 signal 本身。
}
</code></pre>
<p>这些严格的限制是由于信号处理的本质产生的。信号通常用于提示发生了错误。在这些情况下，CPU的行为是精确定义的，在程序中，错误所处的上下文环境可能很不相同，因为它们并不一定能够良好定义。例如当<code>strcpy</code>函数正在执行时如果产生一个信号，可能当时目标字符串暂时未以NUL字节终结；或者当一个函数被调用时如果产生一个信号，当时堆栈可能处于不完整的状态。如果依赖这种上下文环境的库函数被调用它们就可能以不可预料的方式失败，很可能引发另一个信号。</p>
<p>访问限制定义了在信号处理函数中保证能够运行的最小功能。类型<code>sig_atomic_t</code>定义了一种CPU可以以原子方式访问的数据类型，也就是不可分割的访问单位。例如一台16位的机器可以以原子方式访问一个16位整数，但访问一个32位整数可能需要两个操作。在访问非原子数据的中间步骤时如果产生一个信号可能导致不一致的结果，在信号处理函数中把数据访问限制为原子单位可以消除这种可能性。</p>
<ul>
<li>对特定类型静态变量<code>volatile sig_atomic_t</code>的测试</li>
</ul>
<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 🐱 最佳实践：使用 volatile sig_atomic_t
// 保证了原子性 (CPU 一次操作完成) 和可见性 (防止编译器优化)。
volatile sig_atomic_t g_signal_flag = 0;
// 静态变量默认是0，但如果变量在别的文件，需要声明为 static volatile
// sig_atomic_t

void safe_handler(int sig) {
  // 这是信号处理函数唯一应该做的事情：设置标志并快速返回
  g_signal_flag = sig; // 赋值是原子性的
  // 最好不要做其他事情了！
}

int main(void) {
  signal(SIGINT, safe_handler);

  while (1) {
    // 程序的其余部分必须定期检查这个标志！
    if (g_signal_flag != 0) {
      fprintf(stdout, "\n捕捉到信号 %d, 正在安全退出...\n", g_signal_flag);
      // 安全地调用库函数进行清理工作
      exit(g_signal_flag);
    }
    // 程序正常运行逻辑
  }
  return 0;
}
</code></pre>
<blockquote>
<p>标准表示信号处理函数可以通过调用exit终止程序。用于处理除了<strong>SIGABRT</strong>之外的所有信号的处理函数也可以通过调用abort终止程序。但是由于这两个都是库函数，所以当它们被异步信号处理函数调用时可能无法正常运行。如果必须用这种方式终止程序，注意仍然存在一种微小的可能性导致它失败。如果发生这种情况，函数的失败可能破坏数据或者表现出奇怪的症状，但程序最终将终止。</p>
</blockquote>
<h2>16.6 打印可变参数列表&lt;stdarg.h&gt;</h2>
<p>这组函数可用于可变参数列表必须被打印的场合。要求包含头文件<code>&lt;stdio.h&gt;</code> <code>&lt;stdarg.h&gt;</code></p>
<pre><code>int vprintf(char const *format, va_list arg);
int vfprintf(FILE *stream, char const *format, va_list arg);
int vsprintf(char *buffer, char const *format, va_list arg);
</code></pre>
<blockquote>
<p>推荐使用内存更安全的<code>int vsnprintf(char *str, size_t size, const char *format, va_list ap)</code>而不是<code>vsprintf</code></p>
</blockquote>
<h4>例子</h4>
<p>用<code>vprintf</code>实现打印格式化的log</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

void my_log(const char *format, ...){
  va_list args;
  va_start(args,format);
  
  // 使用vprintf 将格式化字符串和参数列表打印到标准输出
  printf("LOG: ");
  vprintf(format,args);
  printf("\n");
  
  va_end(args);
}
</code></pre>
<p>用<code>vfprintf</code>实现打印格式化log到文本流</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void file_log(FILE *stream, const char *format, ...);

void remove_line(char *str);

int main(void){
  const char *log = "app.log";
  FILE *fp = fopen(log,"w");
  if (fp == NULL){
    fprintf(stdout,"Failed to open file %s,exit...",log);
    fclose(fp);
    exit(1);
  }

  char name[20],passwd[20];
  memset(name,0,sizeof(name)); 
  memset(passwd,0,sizeof(passwd));
  fputs("Please input your Loginname: \n",stdout);
  fgets(name,sizeof(name) / sizeof(name[0]), stdin);
  remove_line(name);
  fputs("Please input your Loginpasswd: \n",stdout);
  fgets(passwd,sizeof(passwd) / sizeof(passwd[0]), stdin);
  remove_line(passwd);

  file_log(fp, "Everything I found great was sunfaded.");
  file_log(fp, "LoginName: %s", name);
  file_log(fp, "LoginPasswd: %s", passwd);
  fclose(fp);
  return 0;
}

void file_log(FILE *stream, const char *format, ...){
  va_list args;
  va_start(args,format);
  fprintf(stream,"LOG: ");
  vfprintf(stream,format,args);
  fprintf(stream,"\n");

  va_end(args);
}

void remove_line(char *str){
  int size = strlen(str);
  if (size &gt; 0 &amp;&amp; str[size - 1] == '\n')
    str[size - 1] = '\0';
}
</code></pre>
<p>使用<code>vsnprintf</code> 将格式输出到字符数组内</p>
<pre><code># include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX_BUFFER 256

// 封装函数：将格式化输出写入到字符串
/*
 *  @brief package function and write down output format to string
 *  @param  buffer is the container of format string
 *  @param  format is the requirement value of vsprintf function
 *  @param  ... is variables argument list
 *  @return return actual format with va_list length
 * */
int format_message(char *buffer, const char *format, ...);

int main(void) {

  char output[MAX_BUFFER];
  memset(output, 0, sizeof(output));

  format_message(output, "%d is the real value of world!\n", 42);
  fprintf(stdout, "%s", output);
  return EXIT_SUCCESS;
}
int format_message(char *buffer, const char *format, ...) {
  va_list args;
  va_start(args, format);

  // 使用 vsnprintf 代替 vsprintf，因为它接受缓冲区大小参数，更安全
  // vsnprintf 是 vprintf 系列中用于写入字符串的最佳实践
  int result = vsnprintf(buffer, MAX_BUFFER, format, args);

  va_end(args);
  return result;
}
</code></pre>
<h2>16.7 执行环境</h2>
<h3>16.7.1 终止执行&lt;stdlib.h&gt;</h3>
<p>这三个函数与正常或不正常的程序终止有关。</p>
<pre><code>void abort(void);
void atexit(void (*func)(void));
void exit(int status);
</code></pre>
<p><code>abort</code>函数用于不正常地终止一个正在执行的程序。由于这个函数将引发SIGABRT信号，可以在程序中为这个信号设置一个信号处理函数。</p>
<p><code>atexit</code>函数可以把一些函数注册为<strong>退出函数(exit function)</strong>。当程序将要正常终止时（或者由于调用exit，或者由于main函数返回），退出函数将被调用，退出函数不能接受任何参数。</p>
<p><code>exit</code>函数用于正常终止程序。</p>
<p>当<code>exit</code>函数被调用时，所有被<code>atexit</code>函数注册为退出函数的函数将按照它们所注册的顺序被反序依次调用。然后所有用于流的缓冲区被刷新，所有打开的文件被关闭。用<code>tmpfile</code>函数创建的文件被删除。然后，退出状态返回给宿主环境，程序停止执行。</p>
<blockquote>
<p>不要在atexit注册的退出函数内再次调用exit函数，其效果未定义会导致一个无限循环，很可能只有当堆栈的内存耗尽后才会终止。</p>
</blockquote>
<h3>16.7.2 断言&lt;assert.h&gt;</h3>
<p>断言就是声明某种东西应该为真。ANSI C实现了一个assert宏，在调试程序时很有用。</p>
<pre><code>void assert(int expression);
</code></pre>
<p>当它被执行时，这个宏对表达式参数进行测试。如果它的值为假（零），它就向标准错误打印一条诊断信息并终止程序。这条信息格式是由编译器定义的，为真则则不打印任何东西继续执行。</p>
<p>这个宏提供了一种方便的方法，对应该是真的东西进行检。例如，如果一个函数必须用一个不为NULL的指针参数进行调用，那么函数可以用断言验证这个值：</p>
<pre><code>assert(value != NULL);
</code></pre>
<p>如果函数错误地接受了一个<strong>NULL</strong>参数，程序就会打印一条类型下面形式的信息：</p>
<pre><code>Assertion failed: value != NULL, file.c line 274
</code></pre>
<blockquote>
<p>用这种方法使用断言使调试变得更容易，因为一旦出现错误，程序就会停止。而且，这条信息准确地提示了症状出现地点。</p>
</blockquote>
<blockquote>
<p>asser只适用于验证必须为真的表达式。</p>
</blockquote>
<p>可以在编译时通过定义<strong>NDEBUG</strong>消除所有的断言。使用编译器命令<code>-DNDEBUG</code>或在源文件头文件<code>&lt;assert.h&gt;</code>被包含前增加下面这个定义。</p>
<pre><code>#define NDEBUG
</code></pre>
<h3>16.7.3 环境&lt;stdlib.h&gt;</h3>
<p>**环境(environment)**就是一个由编译器定义的名字/值对的列表，它由操作系统进行维护（就是系统的环境变量）。<code>getenv</code>函数在这个列表中查找一个特定的名字，如果找到，返回一个指向其对应值的指针。程序不能修改返回的字符串。如果名字未找到，函数就返回一个NULL指针。</p>
<pre><code>char *getenv(char const *name);
</code></pre>
<h4>使用两种不同的方法分配内存并输出映射的环境变量</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_ENV_LEN 128

void safe_getenv_copy(const char *env_name);

void process_env_dup(const char *env_name);

int main(void) {
  safe_getenv_copy("HOME");
  process_env_dup("SHELL");
  return 0;
}

void safe_getenv_copy(const char *env_name) {
  char *env_value = getenv(
      env_name); // 这里env_value
                 // 指向的是在静态存储区中有操作系统维护的一个环境变量表的内存

  if (env_value != NULL) {
    // 1. 在栈上分配缓冲区
    char local_buffer[MAX_ENV_LEN];

    // 2. duplicate: use strncpy function to ensure local_buffer not to
    // overflow. attention:strncpy may lose end symbol \0, so you need to make
    // sure manually
    strncpy(local_buffer, env_value, MAX_ENV_LEN - 1);
    local_buffer[MAX_ENV_LEN - 1] = '\0'; // ensure empty terminate
    printf("Safely copied %s: %s\n", env_name, local_buffer);
    // 3. local_buffer will automatically released when leave function.

  } else {
    printf("%s not found", env_name);
  }
}

void process_env_dup(const char *env_name) {
  char *env_value = getenv(env_name);
  char *heap_copy = NULL;

  if (env_value != NULL) {
    // 1. duplicate: use strdup (or strncpy + malloc) to duplicate to heap
    // strdup can automatically allocate enough memory and copy string
    heap_copy = strdup(env_value);

    if (heap_copy != NULL) {
      printf("Safely duplicated %s: %s\n", env_name, heap_copy);

      free(heap_copy);
    }
  }
}
</code></pre>
<h3>16.7.4 执行系统命令&lt;stdlib.h&gt;</h3>
<p><code>system</code>函数把它的字符串参数传递给宿主操作系统，这样它就可以作为一条命令，由系统的命令处理器执行。</p>
<pre><code>void system(char const *command);
</code></pre>
<p>这个任务执行的准确行为因编译器而异，返回值也是一样。</p>
<pre><code>int val = system(NULL);
</code></pre>
<p>一种用于查询命令处理器是否存在的调用，如果存在返回非零值，不存在则返回零。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {

  printf("1. Listing files using system():\n");
  // 调用 ls 命令列出当前目录文件
  system("ls -l --color=auto");

  printf(
      "\n2. Changing terminal background to BLUE using system() and 'tput'\n");

  printf("Press Any key to continue...\n");
  getchar();
  // 使用 tput 命令
  // setab 4 = Set Background Color to Blue (ANSI color 4)
  system("tput setab 4");

  // 清屏
  system("clear");

  printf("The background should now be BLUE.\n");
  printf("This was done by invoking the 'tput' and 'clear' shell commands.\n");
  printf("\n3. Resetting using ANSI escape codes (via echo):\n");
  printf("(Press Enter to reset...)\n");
  getchar();

  // 使用 echo 发送 ANSI 转义字符 (SGR 0 重置属性)
  // \033[0m 是重置所有属性的转移码
  system("echo -e \"\\033[0m\"");
  system("clear");

  printf("Back to normal!\n");
  return 0;
}
</code></pre>
<h3>16.7.5 排序和查找&lt;stdlib.h&gt;</h3>
<p><code>qsort</code>函数在一个数组中以升序的方式对数据进行排序。由于它是和类型无关的，所以可以使用qsort排序任意类型的数据，只是数组中元素的长度是固定的。</p>
<pre><code>void qsort(void *base,size_t n_elements, size_t el_size,
           int (*compare)(void const *,void const*));
</code></pre>
<p>第一个参数指向需要排序的数组，第二个参数指定数组中元素的数目，第三个参数指定每个元素的长度（以字符为单位），第四个参数是一个函数指针，用于对需要排序的元素进行比较。在排序时，<code>qsort</code>调用这个函数对数组中的数据进行比较。通过传递一个指向合适的比较函数的指针，可以用<code>qsort</code>排序任意类型值的数组。</p>
<p>比较函数接受两个参数，它们是指向两个需要进行比较的值的指针。函数应该返回一个整数，大于零、等于零和小于零分别表示第一个参数大于、等于和小于第二个参数。</p>
<h4>使用 qsort 对结构体数组按照结构体内成员进行排序</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
static int strlen_my(const char *str);

static void remove_line(char *str);

static int strcmp_my(const char *s1, const char *s2);

#define INITMY_ARR(ARR, SIZE)                                                  \
  do {                                                                         \
    int __i;                                                                   \
    for (__i = 0; __i &lt; (SIZE); __i++) {                                       \
      fprintf(stdout, "put No %d key string:\n", __i);                         \
      fgets((ARR)[__i].key, sizeof((ARR)[__i].key), stdin);                    \
      remove_line((ARR)[__i].key);                                             \
      (ARR)[__i].other_data = rand() % 100 + 1;                                \
    }                                                                          \
  } while (0)

#define PRINT_ARR(ARR, SIZE)                                                   \
  do {                                                                         \
    int __i;                                                                   \
    for (__i = 0; __i &lt; (SIZE); __i++) {                                       \
      fprintf(stdout, "%s -&gt; %d\n", (ARR)[__i].key, (ARR)[__i].other_data);    \
    }                                                                          \
  } while (0)

typedef struct {
  char key[10];   // 数组的排序关键字
  int other_data; // 与关键字关联的数据
} Record;

// 比较函数，只比较关键的值。
/*
 *  @brief compare function：only compare key value
 *  @param two void const* variable can execute force transfer for val
 *  @return positive means val1 large than val2 zero means val1 equals to val2
 * negative means val1 less than val2
 * */
static int r_compare(void const *a, void const *b);

int main(void) {
  time_t t;
  srand((unsigned)time(&amp;t));
  const int length = 5;

  Record array[length];
  INITMY_ARR(array, length);

  fputs("before qsort:\n", stdout);
  PRINT_ARR(array, length);
  qsort(array, length, sizeof(Record), r_compare);

  fputs("after qsort:\n", stdout);
  PRINT_ARR(array, length);

  Record target;
  Record *result;

  // 查找
  printf("\n请输入要查找的字符串：\n");
  fgets(target.key, sizeof(target.key), stdin);
  remove_line(target.key);

  // 使用 bsearch 执行二分查找
  result = (Record *)bsearch(&amp;target, array, length, sizeof(Record), r_compare);

  if (result != NULL) {
    printf("找到！key: %s, other_data: %d\n", result-&gt;key, result-&gt;other_data);
    printf("在数组中内存地址偏移量: %ld\n", result - array);
  } else {
    printf("未找到 key 为 %s 的元素\n", target.key);
  }

  return EXIT_SUCCESS;
}

static int strlen_my(const char *str) {
  const char *p = str;
  while (*p != '\0')
    p++;
  return p - str;
}

static int strcmp_my(const char *s1, const char *s2) {
  while (*s1 != '\0' &amp;&amp; *s1 == *s2) {
    s1++;
    s2++;
  }

  // 为什么强制转换为 unsigned char？
  // C 语言标准规定 strcmp 比较时应将字符视为 unsigned char。
  // 如果不转，对于扩展 ASCII 码（如大于 127 的字符），
  // 可能会被当成负数，导致比较结果错误。

  return *(unsigned char *)s1 - *(unsigned char *)s2;
}

static void remove_line(char *str) {
  int size = strlen_my(str);
  if (size != 0 &amp;&amp; str[size - 1] == '\n') {
    str[size - 1] = '\0';
  }
}

static int r_compare(void const *a, void const *b) {
  return strcmp_my(((const Record *)a)-&gt;key, ((const Record *)b)-&gt;key);
}
</code></pre>
<h2>16.8 locale</h2>
<p>为了使C语言在全世界的范围内更为通用，标准定义了locale，这是一组特定的参数，每个国家可能不同。在缺省的情况下是 <strong>"C"locale</strong>，编译器也可以定义其他的locale。修改locale可能影响库函数的运行方式。</p>
<p><code>setlocale</code>函数的原型如下所示，它用于修改整个或部分locale</p>
<pre><code>char *setlocale(int category, char const *locale);
</code></pre>
<p><code>category</code>参数指定locale的哪个部分需要进行修改。所允许出现的值于下表</p>
<p>&lt;strong&gt;&lt;center&gt;setlocale 类型&lt;/center&gt;&lt;/strong&gt;</p>
<table>
<thead>
<tr>
<th>值</th>
<th>修改</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_ALL</td>
<td>整个locale</td>
</tr>
<tr>
<td>LC_COLLATE</td>
<td>对照序列，它将影响strcoll和strxfrm函数的行为</td>
</tr>
<tr>
<td>LC_CTYPE</td>
<td>定义于ctype.h中的函数所使用的字符类型分类信息</td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>在格式化货币值时使用的字符</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>在格式化非货币值时使用的字符。同时修改由格式化输入/输出函数和字符串转换函数所使用的小数点符号</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>strftime函数的行为</td>
</tr>
</tbody>
</table>
<p>如果<code>setlocale</code>的第二个参数为NULL，函数将返回一个指向给定类型的当前的locale的名字的指针。这个值可能被保存并在后续的<code>setlocale</code>函数中使用，用来恢复以前的locale的值。</p>
<blockquote>
<p>这里<code>setlocale</code>函数返回的也是一个静态内存中的值，和ctime，strftime一样最好用一个字符数组接收当前返回的值，否则后续调用<code>setlocale</code>函数这个值可能会发生改变。</p>
</blockquote>
<blockquote>
<p>使用<code>strdup</code>或<code>strncpy</code>复制到堆内存或栈内存上。</p>
</blockquote>
<pre><code>#include &lt;locale.h&gt; // setlocale
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // strdup (POSIX)

// 打印浮点数，观察小数点是 '.' 还是 ','
inline static void print_number();

int main(void) {
  // 1. 显式设置初始环境为 "C" (标准 C 模式，小数点是点)
  setlocale(LC_NUMERIC, "C");
  printf("1. Initial state (C locale):\n");
  print_number();

  // 获取当前 locale 名称
  char *current_ptr = setlocale(LC_NUMERIC, NULL);

  // 必须拷贝字符串
  char *saved_locale = strdup(current_ptr);

  printf("\n[System] Saved old locale: '%s'\n", saved_locale);

  // 切换到新环境
  char *new_loc = setlocale(LC_NUMERIC, "de_DE.UTF-8");
  if (new_loc == NULL) {
    printf("\n(de_DE.UTF-8 not found, trying system default...)\n");
    new_loc = setlocale(LC_NUMERIC, ""); // 尝试系统默认
  }

  printf("\n2. Temporary state (Changed to '%s'):\n", new_loc);
  print_number();

  // 恢复原来的环境
  printf("\n[System] Restoring previous locale...\n");
  setlocale(LC_NUMERIC, saved_locale);

  printf("\n3. Restored state:\n");
  print_number();

  // 别忘了释放拷贝字符串的内存
  free(saved_locale);

  return 0;
}

inline static void print_number() { printf(" Current Output: %.2f\n", 3.14); }
</code></pre>
<h3>16.8.1 数值和货币格式 &lt;locale.h&gt;</h3>
<p><code>localeconv</code>函数用于获得根据当前的<code>locale</code>对非货币值和货币值进行合适的格式化所需要的信息。这个函数并不实际执行格式化任务，它只是提供一些如何进行格式化的信息。</p>
<pre><code>struct lconv *localeconv(void);
</code></pre>
<p><code>lconv</code>结构包含两种类型的参数：字符和字符指针。</p>
<h3>16.8.2 字符串和 locale&lt;string.h&gt;</h3>
<p>一台机器的字符集的对照序列是固定的，但locale提供了一种方法指定不同的序列。当你必须使用一个并非缺省的对照序列时，可以使用下列两个函数。</p>
<pre><code>int strcoll(char const *s1, char const *s2);
size_t strxfrm(char *s1, char const *s2, size_t size);
</code></pre>
<p><code>strcoll</code>函数用法和<code>strcmp</code>类似，对两个字符串根据当前的locale的LC_COLLATE类型参数指定的字符串进行比较。它返回一个大于、等于或小于零的值。</p>
<blockquote>
<p>这个比较函数所需的计算量可能比<code>strcmp</code>需要多的多的计算量。因为它需要遵循一个并非是本地机器的对照序列。</p>
</blockquote>
<p>当字符串必须以这种方式反复进行比较时，可以使用<code>strxfrm</code>函数减少计算量。它根据当前的locale解释的第二个参数转换为另一个不依赖于locale的字符串。尽管转换后的字符串的内容是未确定的。</p>
<pre><code>#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  // set local environment （to let program know the language habit now）
  setlocale(LC_ALL, "");

  const char *s1 = "apple";
  const char *s2 = "Banana";

  printf("Comparing '%s' and '%s' :\n\n", s1, s2);

  // 1. 使用 strcmp (only compare ASCII code)
  // 'a' = 97, 'B' = 66, 97 &gt; 66
  int res_cmp = strcmp(s1, s2);
  printf("[strcmp] Result: %d\n", res_cmp);
  if (res_cmp &gt; 0)
    printf(" -&gt; 'apple' come AFTER 'Banana' (ASCII order)\n");
  else
    printf(" -&gt; 'apple' comes BEFORE 'Banana'\n");

  printf("-------------------------\n");

  // 2. 使用 strcoll （compare with dictionary order ）
  // in the habit of eng, a comes before b unless the lower and upper
  int res_coll = strcoll(s1, s2);
  printf("[strcoll] Result: %d\n", res_coll);
  if (res_coll &gt; 0)
    printf(" -&gt; 'apple' comes AFTER 'Banana'\n");
  else
    printf(" -&gt; 'apple' comes BEFORE 'Banana' (Dictionary order)\n");

  // 3. strxfrm showcase
  printf("\n--- strxfrm Demo ---\n");
  char buf1[100], buf2[100];

  // transform natural language into the compare 'key' used by strcmp
  strxfrm(buf1, s1, sizeof(buf1));
  strxfrm(buf2, s2, sizeof(buf2));

  // the converted content might be a bunch of gibberish or a
  // specific sequence
  // the content after transform maybe a mess of damaged code
  // or specific sequence we only care about the result of strcmp
  int res_xfrm = strcmp(buf1, buf2);
  printf("strcmp(xfrm(s1),xfrm(s2)) Result: %d\n", res_xfrm);

  if (res_coll &lt; 0 &amp;&amp; res_xfrm &lt; 0) {
    printf("Verification: strxfrm result matches strcoll result!\n");
  }
  return 0;
}
</code></pre>
<blockquote>
<p><code>strcoll</code>在只需比较少次数的字符串比<code>strxtrm</code>快，<code>strxtrm</code> + <code>strcmp</code>用空间换时间的策略。</p>
</blockquote>
<pre><code>详细对比：为什么会这样？

  假设我们要排序 1000 个中文名字。

  1. 只用 strcoll (慢)
  排序算法（如 qsort）需要进行约 10,000 次比较 ($N \log N$)。
   * 第 1 次比较：strcoll 查阅复杂的字典规则，算出 "张三" &lt; "李四"。
   * 第 2 次比较：strcoll 再次查阅规则，算出 "张三" &gt; "安二"。
   * ...
   * 第 10,000 次比较：strcoll 第 N 次查阅规则...
   * 结果：同一个字符串的规则被重复解析了无数次，浪费大量 CPU。

  2. 用 strxfrm + strcmp (快)
  这是“空间换时间”的策略。
   * 预处理阶段：调用 1000 次 strxfrm。
       * 把 "张三" 转换成二进制键值 \x05\x01... (假设值)。
       * 把 "李四" 转换成二进制键值 \x08\x02...。
       * 这步虽然有开销，但每个字符串只做一次。
   * 排序阶段：进行 10,000 次 strcmp。
       * strcmp 只需要比较 \x05 和 \x08，极其快（CPU 指令级别）。
   * 结果：最耗时的“查规则”只做了 N 次，而不是 $N \log N$ 次。

  总结公式

   * 如果你只比较一次（比如 if (strcoll(a, b) &gt; 0)）：
       * 直接用 strcoll 更快。因为 strxfrm 需要分配内存、转换，这本身也是开销。
   * 如果你要排序（比较次数远多于元素个数）：
       * strxfrm + strcmp 是王道。
</code></pre>
<blockquote>
<p><code>strxfrm</code>就是为了把昂贵的的逻辑判断“缓存”成廉价的二进制数据。</p>
</blockquote>
<h3>16.8.3 改变locale的效果</h3>
<ol>
<li>
<p>locale可能向正在执行的程序所使用的字符集增加字符（但可能不会改变现存字符的含义）。
例如许多欧洲语言使用了能够提示重音、货币符号和其他特殊符号的扩展字符集。</p>
</li>
<li>
<p>打印的方向可能会改变。尤其是，locale决定一个字符应该根据前面一个被打印的字符的那个方向进行打印。</p>
</li>
<li>
<p>printf和scanf函数家族使用当前locale定义的小数点符号。</p>
</li>
<li>
<p>如果locale扩展了正在使用的字符集，isalpha、islower、isspace和isupper函数可能比以前包括更多的字符。</p>
</li>
<li>
<p>正在使用的字符集的对照序列可能会改变。这个序列由strcoll函数使用，用于字符串之间的相互比较。</p>
</li>
<li>
<p>strftime函数所产生的日期和时间格式的许多方面都是特定于locale的。</p>
</li>
</ol>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="C"></category>
  </entry>
  <entry>
    <title>Useful FFmpeg commands</title>
    <link href="https://love.nagisadaisuki.icu/posts/ffmepg_related/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/ffmepg_related/</id>
    <published>2025-09-02T00:00:00.000Z</published>
    <updated>2025-09-02T00:00:00.000Z</updated>
    <summary>Was it a cat i saw!?</summary>
    <content type="html"><![CDATA[<h2>FFmpeg 是音、视频处理的一个强大开源工具，它包含许多组件和扩展库，在视频网站和商业软件被大量应用。它还有一个命令行工具，在很多场景下直接使用FFmpeg命令行工具比桌面视频处理软件更简洁高效</h2>
<p>使用 <code>ffmpeg</code> 前，可先简单了解下视频处理的一些基本概念：</p>
<p><strong>封装(Container)格式</strong>：也可翻译为容器，里面包括了视频、音频、字幕等内容。对视频来说，封装格式是mp4、avi、mkv等格式。</p>
<p><strong>流(Stream)</strong>：stream是指媒体文件中的一个单独的数据通道。一个媒体文件可以包含多个流，如视频、音频、字幕等。ffmpeg本质上是操作和处理这些媒体流，比如提取、分离、合并、转码等。你可以选择特定的流进行处理，或者将多个流合并成一个新的媒体文件。</p>
<p><strong>帧(Frame)</strong>：帧代表最小数据单元，也是编解码器真正处理的最小处理单元。对于视频来说，帧(Frame)是编码器编码后的一个图像；对于音频来说，帧(Frame)是编码器编码后的一个声音。帧分为：I帧:关键帧、P帧:预测帧、B帧:双向预测帧。编解码(Codec)：编码是指对图像和声音的打包或压缩方法；解码就是把编码后的东西还原为原来的状态。编码格式：视频和音频都需要经过编码，才能保存成文件。不同的编码格式，有不同的压缩率，会导致文件大小和清晰度的差异。常用的编码格式有H.264、H.265等。</p>
<h1>🎞 视频处理</h1>
<h2>1.转码为MP4</h2>
<pre><code>ffmpeg -i input.mov -vcodec libx264 -acodec aac output.mp4
</code></pre>
<p>也可以添加额外参数</p>
<pre><code>ffmpeg -i input.mov -c:v libx264 -c:a aac -preset medium -crf 23 output.mp4
</code></pre>
<ul>
<li><code>-c:v</code>和<code>-c:a</code>分别是<code>-vcodec</code>和<code>-acodec</code>的alias</li>
<li><code>libx264</code>：转换为H.264（兼容性最好）</li>
<li><code>aac</code>：音频转为AAC（兼容广泛）</li>
<li><code>-crf 23</code>：保持较好画质，文件不会太大</li>
<li><code>-preset medium</code>：转码速度与压缩比的平衡</li>
</ul>
<h2>2.裁剪视频(不重新编码)</h2>
<pre><code>ffmpeg -ss 00:00:10 -i input.mp4 -t 00:00:20 -c copy output.mp4
</code></pre>
<p><code>-ss</code>是起始时间，<code>-t</code>是持续时间，<code>-c copy</code>表示不改变音频和视频的编码格式，直接拷贝</p>
<h2>3.修改分辨率</h2>
<pre><code>ffmpeg -i input.mp4 -vf scale=1280:720 output_720p.mp4
</code></pre>
<h2>4.提取指定时间段的视频(并重新编码)</h2>
<pre><code>ffmpeg -ss 00:01:00 -to 00:02:00 -i input.mp4 -c:v libx264 -c:a aac output.mp4
</code></pre>
<h2>5.加快或减慢播放速度</h2>
<ul>
<li>快两倍：</li>
</ul>
<pre><code>ffmpeg -i input.mp4 -vf "setpts=0.5*PTS" output_fast.mp4
</code></pre>
<pre><code>- 慢0.5倍：
ffmpeg -i input.mp4 -vf "setpts=2.0*PTS" output_slow.mp4
</code></pre>
<h1>🔊 音频处理</h1>
<h2>1.提取音频</h2>
<pre><code>ffmpeg -i input.mp4 -vn -acodec copy output.aac
</code></pre>
<ul>
<li><code>vn</code>: 不处理视频流（只提取音频）</li>
<li><code>c:a aac</code>: 指定音频编码为 AAC（与 .aac 容器兼容）</li>
</ul>
<h2>2.转换为MP3</h2>
<pre><code>ffmpeg -i input.aac output.mp3
</code></pre>
<h2>3.调整音量(放大一倍)</h2>
<pre><code>ffmpeg -i input.mp3 -filter:a "volume=2.0" output.mp3
</code></pre>
<h2>4.混合多个音轨</h2>
<pre><code>ffmpeg -i audio1.mp3 -i audio2.mp3 -filter_complex amix=inputs=2:duration=longest output.mp3
</code></pre>
<h1>🖼 图片处理</h1>
<h2>1.从视频中导出每秒一张图片</h2>
<pre><code>ffmpeg -i input.mp4 -vf fps=1 image_%03d.jpg
</code></pre>
<h2>2.将图片序列合成为视频</h2>
<pre><code>ffmpeg -framerate 24 -i image_%03d.jpg -c:v libx264 -pix_fmt yuv420p output.mp4
</code></pre>
<h2>3.提取视频的第一帧为封面图</h2>
<pre><code>ffmpeg -i input.mp4 -vf "select=eq(n\,0) -q:v 3 output.jpg"
</code></pre>
<h2>extra. FFmpeg 在指定时间区间内按帧提取截图</h2>
<pre><code>ffmpeg -ss 00:00:05 -to 00:00:10 -i input.mp4 -vsync 0 -q:v 2 frame_%04d.png
</code></pre>
<h2>extra1. FFmpeg 指定NVIDIA GPU时间区间内按帧提取截图</h2>
<pre><code>ffmpeg -hwaccel cuda -ss 00:00:30 -to 00:00:40 -i input.mp4 -vf fps=1 output/frame_%04d.jpg
</code></pre>
<h3>📌 参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-hwaccel cuda</code></td>
<td>使用 NVIDIA GPU 加速视频解码（通过 CUDA）</td>
</tr>
<tr>
<td><code>-i input.mp4</code></td>
<td>输入视频</td>
</tr>
<tr>
<td><code>-vf fps=1</code></td>
<td>每秒截一帧</td>
</tr>
<tr>
<td><code>output/frame_%04d.jpg</code></td>
<td>输出图像路径</td>
</tr>
</tbody>
</table>
<h2>extra2. av1转码为 H.264，再截图（兼容 + 可加速）</h2>
<pre><code>ffmpeg -c:v libdav1d -i video.mp4 -c:v h264_nvenc -crf 23 -preset fast output_h264.mp4
</code></pre>
<p>然后截图：</p>
<pre><code>ffmpeg -hwaccel cuda -ss 00:00:30 -to 00:00:40 -i output_h264.mp4 -vf fps=1 output/frame_%04d.jpg
</code></pre>
<p>这样截图过程可以启用 GPU 加速（因为 H.264 你支持 NVENC/NVDEC）</p>
<p>✅ 可选：如果转码中出现 OBU 报错，使用 libaom-av1：</p>
<pre><code>ffmpeg -c:v libaom-av1 -i video.mp4 -c:v h264_nvenc -preset fast output_h264.mp4
</code></pre>
<h2>4.图片格式转换</h2>
<pre><code>ffmpeg -i input.jfif output.png
</code></pre>
<ul>
<li><code>-i input.jfif</code>：指定输入文件</li>
<li><code>output.png</code>：自动根据后缀选择PNG编码器</li>
</ul>
<h2>5.修改图片尺寸</h2>
<pre><code>ffmpeg -i input.jfif -vf scale=800:600 output.png
</code></pre>
<ul>
<li><code>scale=宽度:高度</code>，可用<code>-1</code>自动按比例缩放，比如：</li>
</ul>
<pre><code>-vf scale=800:-1
</code></pre>
<h2>6.调整输出图片质量(对有压缩的格式如JPEG更有用)</h2>
<ul>
<li>虽然 PNG 是无损格式，没压缩等级设置，但你可以用<code>-compression_level</code>控制压缩（越高体积越小，速度越慢）：</li>
</ul>
<pre><code>ffmpeg -i input.jfif -compression_level 9 output.png
</code></pre>
<p>范围：<code>0</code>(最快)到<code>9</code>压缩最强</p>
<h2>7.裁剪图片</h2>
<pre><code>ffmpeg -i input.jfif -vf "crop=width:height:x:y" output .png
</code></pre>
<p>例如从左上角开始裁剪300x300区域：</p>
<pre><code>-vf "crop=300:300:0:0"
</code></pre>
<h2>8.添加水印/叠加图层</h2>
<pre><code>ffmpeg -i input.jfif -i logo.png -filter_complex "overlay=10:10" output.png
</code></pre>
<p>将<code>logo.png</code>叠加到输入图像的左上角(x=10,y=10)</p>
<h2>9.转换为带透明背景(alpha)的PNG</h2>
<p>如果原图没有alpha，但你希望创建带alpha通道的图(比如用于抠图后保存)：</p>
<pre><code>ffmpeg -i input.jfif -vf "format=rgba" output.png
</code></pre>
<h2>10.更改颜色格式</h2>
<pre><code>ffmpeg -i input.jfif -pix_fmt rgb24 output.png
</code></pre>
<p>常用像素格式:</p>
<ul>
<li><code>gray</code>：灰度图</li>
<li><code>rgb24</code>：24位真彩色</li>
<li><code>rgba</code>：含透明度通道</li>
<li><code>pal8</code>：8位索引色(低色图)</li>
</ul>
<h1>✅ 示例：高质量转换 + 改尺寸 + 添加水印</h1>
<pre><code>ffmpeg -i input.jfif -i watermark.png -filter_complex "[0][1]overlay=W-w-10:H-h-10,scale=1024:-1" -compression_level 9 output.png
</code></pre>
<h1>🔍 本地帮助手册</h1>
<pre><code>ffmpeg -h           # 简略帮助
ffmpeg -filter      # 所有滤镜
ffmpeg -codecs      # 所有编解码器
ffmpeg -pix_fmts    # 所有像素格式  
ffmpeg -formats     # 所有支持的格式
</code></pre>
<h1>📌 补充说明</h1>
<p>如果你要批量转换多个 .jfif 为 .png，也可以用批处理命令（例如在 Windows 批处理脚本中）：</p>
<pre><code>for %%f in (*.jfif) do ffmpeg -i "%%f" "%%~nf.png"
</code></pre>
<p>✅ 如果你直接在命令行中运行（不是 .bat 文件），要用 %f 而不是 %%f</p>
<h2>1. 图片转换选项</h2>
<h3>PNG(Portable Network Graphics) 可选的选项</h3>
<p><code>-pix_fmt</code>：<strong>控制像素格式</strong></p>
<p>这个选项决定了输出 PNG 文件的颜色深度和通道数。它直接影响文件大小和颜色精度。</p>
<ul>
<li><code>rgba</code>: 这会创建一个带有 Alpha 通道（透明度）的真彩色 PNG 文件。如果你的输入图片包含透明度信息，这是最佳选择，因为它能完整保留透明度。</li>
<li><code>rgb24</code>: 这会创建一个没有 Alpha 通道的真彩色 PNG 文件。文件会比 rgba 小，因为没有透明度数据。如果你不需要透明度，这是个好选择。</li>
<li><code>gray</code>: 这会创建一个灰度 PNG 文件。文件最小，但会丢失所有颜色信息。</li>
<li><code>graya</code>: 灰度文件，但包含一个 Alpha 通道。</li>
</ul>
<p><strong>示例</strong></p>
<p>如果你想将一张 JPG 图片转换为带透明度的 PNG，你可以这样做：</p>
<pre><code>ffmpeg -i input.jpg -pix_fmt rgba output.png
</code></pre>
<p><strong>注意:</strong> 如果输入图片没有透明度，<code>rgba</code>格式会添加一个全不透明的Alpha通道</p>
<p>滤镜(<strong><code>-vf</code></strong>)：<strong>图像处理选项</strong></p>
<p>在将图片保存为PNG之前，你可以使用各种视频滤镜来处理图像</p>
<ul>
<li><code>scale</code>: 调整图片大小
<ul>
<li><code>ffmpeg -i input.jpg -vf "scale=800:600" output.png</code></li>
</ul>
</li>
<li><code>crop</code>: 裁剪图片
<ul>
<li><code>ffmpeg -i input.jpg -vf "crop=500:500:100:100" output.png</code></li>
</ul>
</li>
<li><code>format</code>: 类似于<code>-pix_fmt</code>,但更灵活，允许你强制转换像素格式
<ul>
<li><code>ffmpeg -i input.jpg -vf "format=rgba" output.png</code></li>
</ul>
</li>
</ul>
<h3>JPEG(Joint Photographic Experts Group) 可选的选项</h3>
<p><code>-q:v</code>或<code>-qscale:v</code>：<strong>控制质量(常用)</strong></p>
<p>这是最常用的选项，用于直接控制 JPG 输出的质量。其值范围通常是 <em>2</em> 到 <em>31</em>。</p>
<ul>
<li><code>ffmpeg -i input.png -q:v 2 output.jpg</code>: <code>2</code>是最高质量，文件最大。</li>
<li><code>ffmpeg -i input.png -q:v 31 output.jpg</code>: <code>31</code>是最低质量，文件最小。</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li><strong>高质量输出</strong>：使用 <code>-q:v 2</code> 到 <code>-q:v 5</code>，这个范围能提供极好的画质，但文件较大。</li>
<li><strong>平衡质量与大小</strong>：使用 <code>-q:v 6</code> 到 <code>-q:v 10</code>，这是一个很好的折衷方案。</li>
</ul>
<p><code>-pix_fmt</code>：<strong>像素格式</strong></p>
<p>这个选项决定了输出JPG文件的颜色格式</p>
<ul>
<li><code>yuvj444p</code>: 提供了最好的颜色质量，是最高级别的色度采样(4:4:4)。文件最大。</li>
<li><code>yuvj422p</code>: 提供了中等的颜色质量（4:2:2）。在大多数情况下画质和文件大小之间达到了很好的平衡。</li>
<li><code>yuvj420p</code>: 提供了最低的颜色质量（4:2:0）。这是最常见的格式，文件最小，适用于网络传输。</li>
</ul>
<p><strong>示例：</strong></p>
<p>以最高质量的像素格式输出 JPG。</p>
<pre><code>ffmpeg -i input.png -pix_fmt yuvj444p -q:v 2 output.jpg
</code></pre>
<p><code>-ss</code>和<code>-t</code>：<strong>从视频中提取帧</strong></p>
<p>如果你从视频中提取帧并保存为 JPG，可以使用这两个选项来指定时间范围。</p>
<ul>
<li><code>-ss</code>: 指定开始时间，格式为<code>hh:mm:ss.sss</code>。</li>
<li><code>-t</code>: 指定持续时间。</li>
<li><code>-frame:v</code>: 指定要提取的帧数。</li>
</ul>
<p><strong>示例：</strong></p>
<p>从 <code>video.mp4</code> 的第 <strong>5</strong> 秒开始，提取 <strong>10</strong> 帧并保存为 <code>frame%02d.jpg</code>。</p>
<pre><code>ffmpeg -ss 5 -i video.mp4 -t 1 -frames:v 10 frame%02d.jpg
</code></pre>
<h3>WebP可选的选项</h3>
<p>WebP是一种为网络优化的新一代图片格式，支持有损和无损压缩，以及透明度。</p>
<ul>
<li><code>lossless 1</code>: 启用无损压缩模式。WebP的无损压缩通常比<strong>PNG</strong>更高效，文件更小。
<ul>
<li><code>ffmpeg -i input.png -lossless 1 output.webp</code></li>
</ul>
</li>
<li><code>-q:v</code> 或 <code>-qscale:v</code>: 控制有损压缩的质量。值范围是 <strong>0</strong> 到 <strong>100</strong>，<strong>100 是最高质量</strong>。这与 JPEG 的质量选项类似，但范围相反。
<ul>
<li><code>ffmpeg -i input.jpg -q:v 80 output.webp</code></li>
</ul>
</li>
<li><code>-compression_level</code>: 控制压缩速度与文件大小的平衡。值范围是 0 到 6，<strong>6 是最慢、压缩率最高</strong>。
<ul>
<li><code>ffmpeg -i input.png -compression_level 6 output.webp</code></li>
</ul>
</li>
</ul>
<p>WebP 格式的<em><strong>独特之处</strong></em>在于它能在一个文件中同时处理有损和无损压缩，并且透明度支持比 <strong>JPEG</strong> 更好。</p>
<h3>AVIF可选的选项</h3>
<p>AVIF 是一种基于 AV1 视频编码的图片格式，旨在提供比 JPEG 和 WebP 更高的压缩效率。</p>
<ul>
<li><code>-crf</code>: 控制压缩质量。与 H.264 编码器类似，值越低，质量越高，文件越大。
<ul>
<li><code>ffmpeg -i input.jpg -c:v libsvtav1 -crf 20 output.avif</code></li>
</ul>
</li>
<li><code>-tile-columns</code> 和 <code>-tile-rows</code>: 决定图像如何被分割成瓦片进行并行编码，可以提高编码速度。</li>
</ul>
<h3>TIFF可选的选项</h3>
<p>TIFF是一种灵活且兼容性强的无损(lossless)格式，常用于印刷和专业图像编辑。</p>
<ul>
<li><code>-compression_algo</code>: 控制压缩算法。TIFF 支持多种无损压缩算法，如 LZW、Deflate 和 RLE。
<ul>
<li><code>lzw</code>: 常用，无损压缩。</li>
<li><code>deflate</code>: 常用，通常比 LZW 效率更高。</li>
<li><code>none</code>: 无压缩，文件最大。</li>
<li><code>rle</code>: 适用于包含大片相同颜色的图像（如黑白图像）。</li>
<li><code>ffmpeg -i input.png -compression_algo lzw output.tif</code></li>
</ul>
</li>
<li><code>-pix_fmt</code>: 支持广泛的像素格式，包括 48-bit RGB、浮点数等，这使得它在专业领域非常有用。
<ul>
<li><code>ffmpeg -i input.png -pix_fmt rgb48 output.tif</code></li>
</ul>
</li>
</ul>
<h3>BMP可选的选项</h3>
<p>BMP 是一种无压缩的位图格式，主要用于 Windows 系统，文件体积通常很大。</p>
<ul>
<li><code>pix_fmt</code>: BMP 支持多种像素格式，但通常没有压缩选项。
<ul>
<li><code>ffmpeg -i input.jpg -pix_fmt bgra bmp_with_alpha.bmp</code></li>
</ul>
</li>
</ul>
<p>BMP 格式的独特之处在于它几乎没有压缩，因此转换速度快，但文件巨大。</p>
<h1>💨其它补充</h1>
<h3>🚀 1. 启用多线程（自动或手动指定）</h3>
<p>FFmpeg 默认会根据系统核心数自动使用多线程，但你也可以手动指定：</p>
<pre><code>ffmpeg -i input.mp4 -threads 8 -c:v libx264 -preset fast output.mp4
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>-threads 8</code>：手动指定使用 8 个线程（可设为 auto）</li>
<li><code>libx264</code> 本身是支持多线程的（默认会启用）</li>
<li>一些滤镜（如 scale, hqdn3d）也会自动启用多线程</li>
</ul>
<p>📌 注意：某些滤镜不支持多线程，比如 drawtext，即使你开了 -threads 也可能没明显效果。</p>
<h3>🧠 2. 使用转码预设：<code>-preset</code></h3>
<p>用于 libx264 和 libx265 编码器，会影响速度和压缩比：</p>
<pre><code>-preset ultrafast
-preset superfast
-preset veryfast
-preset fast
-preset medium     # 默认值
-preset slow
</code></pre>
<p>越“fast”，编码越快，但文件体积越大、画质压缩越弱</p>
<h3>😎 3. FFmpeg纯音频合成黑场视频</h3>
<pre><code>ffmpeg -i your_audio.mp3 -f lavfi -i color=c=black:s=640x480:r=30 -c:v libx264 -pix_fmt yuv420p -c:a copy -shortest output_black_video.mp4
</code></pre>
<ul>
<li><code>-i your_audio.mp3</code>: 指定你的输入音频文件。替换 <code>your_audio.mp3</code> 为你的实际音频文件路径。</li>
<li><code>-f lavfi</code>:　告诉 FFmpeg 使用 <code>lavfi</code> (libavfilter input) 虚拟设备。</li>
<li><code>-i color=...</code>: 这是 <code>lavfi</code>的一个源滤镜，用于生成一个纯色视频流。
<code>c=black</code>: 设置颜色为黑色。你也可以使用其他颜色名称（如 white, red）或十六进制 RGB 值（如 c=0x000000）。
<code>s=1920x1080</code>: 设置视频分辨率为 1920x1080 (Full HD)。你可以根据需要更改这个值，例如 1280x720 (HD)。
<code>r=30</code>: 设置视频帧率为 30 fps。你也可以设置为其他帧率，例如 r=25 或 r=60。
<code>-c:v libx264</code>: 指定视频编码器为 libx264，这是最常用的 H.264 编码器。
<code>-pix_fmt yuv420p</code>: 指定像素格式为 yuv420p。这是 H.264 的标准像素格式，具有广泛的兼容性。
<code>-c:a copy</code>: 复制音频流，不重新编码。这样可以保持原始音频的音质和编码格式（例如，如果你的输入是 AAC，输出的 MP4 中音频也会是 AAC）。
<code>-shortest</code>: 这个非常重要！它告诉 FFmpeg 输出的视频时长应与最短的输入流（在这里就是你的音频文件）的持续时间保持一致。如果没有这个，FFmpeg 会生成一个无限长的黑屏视频。
<code>output_black_video.mp4</code>: 指定输出的 MP4 文件名。</li>
</ul>
<h3>✨ 4. 使用FFmpeg提取指定视频时间区域制作成GIF</h3>
<p><strong>基本命令(质量较低)</strong></p>
<pre><code>ffmpeg -ss [开始时间] -to [结束时间] -i input.mp4 -vf "fps=10,scale=320:-1" output.git
</code></pre>
<ul>
<li><code>ss [开始时间]</code>: 指定视频的开始时间。格式可以是<code>HH:MM:SS</code>(小时:分钟:秒)或(SS)秒。例如：<code>00:00:10</code> 表示从视频的第 10 秒开始，<code>5</code> 表示从视频的第 5 秒开始。</li>
<li><code>to [结束时间]</code>：指定视频的结束时间。格式与<code>-ss</code>相同。</li>
<li><code>i input.mp4</code>：指定输入视频文件。请将<code>input.mp4</code>替换为你的视频文件路径。</li>
<li><code>-vf "fps=10,scale=320:-1"</code>是视频滤镜选项：
<ul>
<li><code>fps=10</code>：设置 GIF 的帧率（每秒帧数）为 10。较低的帧率可以减小 GIF 的文件大小。你可以根据需要调整此值。</li>
<li><code>scale=320:-1</code>：设置 GIF 的宽度为 320 像素，高度会自动根据原始视频的宽高比进行调整（-1 表示保持宽高比）。你可以调整宽度来控制 GIF 的尺寸和文件大小。</li>
<li><code>output.gif</code>：指定输出 GIF 文件的名称。</li>
</ul>
</li>
</ul>
<p><strong>高质量 GIF（两步法 - 推荐）</strong></p>
<ol>
<li><strong>生成调色板 (palettegen)：</strong> FFmpeg 会分析视频中的颜色，生成一个最优的 256 色调色板。GIF 格式限制为 256 种颜色，所以使用一个定制的调色板可以显著提高图像质量。</li>
<li><strong>使用调色板生成 GIF (paletteuse)：</strong> 使用上一步生成的调色板来渲染 GIF。</li>
</ol>
<p><strong>步骤 1: 生成调色板</strong></p>
<pre><code>ffmpeg -ss [开始时间] -to [结束时间] -i input.mp4 -vf "fps=10,scale=320:-1:flags=lanczos,palettegen" palette.png
</code></pre>
<p><strong>与基本命令相比，新增和修改的参数：</strong></p>
<ul>
<li><code>flags=lanczos</code>：在缩放时使用 Lanczos 算法，通常能提供更好的缩放质量。</li>
<li><code>palettegen</code>：这是一个滤镜，用于生成调色板。</li>
<li><code>palette.png</code>：输出的调色板文件（临时文件）。
<strong>步骤 2: 使用调色板生成 GIF</strong></li>
</ul>
<pre><code>ffmpeg -ss [开始时间] -to [结束时间] -i input.mp4 -i palette.png -filter_complex "fps=10,scale=320:-1:flags=lanczos[x];[x]:[1:v]paletteuse" output.gif
</code></pre>
<p><strong>新增和修改的参数：</strong></p>
<ul>
<li><code>-i palette.png</code>：将上一步生成的调色板文件作为第二个输入。</li>
<li><code>-filter_complex "fps=10,scale=320:-1:flags=lanczos[x];[x][1:v]paletteuse"</code>：这是一个复杂的滤镜链：
<ul>
<li><code>fps=10,scale=320:-1:flags=lanczos</code>：与第一步相同，对视频进行帧率和尺寸调整，并将结果命名为 [x]。</li>
<li><code>[x][1:v]</code>：将处理后的视频流 [x] 和第二个输入（<code>palette.png</code>，即 <code>[1:v]</code> 视频流）作为输入。</li>
<li><code>paletteuse</code>：使用调色板将视频转换为 GIF。</li>
</ul>
</li>
</ul>
<p><strong>额外优化和注意事项</strong></p>
<ul>
<li><strong>文件大小</strong>： GIF 文件的主要影响因素是<strong>帧率(flame)</strong>、<strong>分辨率(resolution)<strong>和</strong>持续时间(durations)</strong>。降低帧率 (<code>fps</code>)、缩小尺寸 (<code>scale</code>) 和缩短持续时间可以显著减小文件大小。</li>
<li><strong>循环播放</strong>：GIF 默认是无限循环的。如果你想控制循环次数，可以在输出文件前添加<code>-loop</code>参数。</li>
<li><strong>开始时间<code>-ss</code>的位置：</strong></li>
<li>将 <code>-ss</code> 放在 <code>-i</code> 之前：这样 FFmpeg 会在读取输入文件之前先定位到指定时间，这通常更快，但可能会导致起始时间略微不准确（它会寻找最近的关键帧）。</li>
<li>将 <code>-ss</code> 放在 <code>-i</code> 之后：这样 FFmpeg 会从视频开头开始解码，然后在指定时间点开始处理，通常更精确，但对于大型视频文件可能会比较慢。对于 GIF 提取，通常精确度更重要，所以放在 <code>-i</code> 之后可能更合适。</li>
</ul>
<h3>😤 5. 使用FFmpeg为MP4视频格式文件压入封面和硬字幕（重新编码）</h3>
<p>使用 FFmpeg 为 MP4 视频添加封面和硬字幕是一个复杂但可行的操作，它涉及到多个输入文件和流映射（<code>map</code>）的正确使用。</p>
<p>要实现这个目标，你需要执行一个命令，该命令会同时处理以下三个流：</p>
<ol>
<li><strong>原始视频流</strong>（需要重新编码来烧录字幕）。</li>
<li><strong>原始音频流</strong>（可以直接复制）。</li>
<li><strong>封面图片流</strong>（需要作为附加图片流复制）。</li>
</ol>
<p><strong>完整命令</strong></p>
<p>三个文件：</p>
<ul>
<li><code>input.mp4</code>: 原始视频文件</li>
<li><code>cover.jpg</code>: 作为封面的图片</li>
<li><code>subtitle.ass</code>: 字幕文件</li>
</ul>
<p><strong>方法一：使用滤镜同时添加封面和字幕</strong></p>
<pre><code>ffmpeg -i input.mp4 -i cover.jpg -i subtitle.ass -filter_complex "[0:v]ass=subtitle.ass[v]" -map "[v]" -map 0:a -map 1:v -c:v libx264 -crf 18 -c:a copy -c:v:1 mjpeg -disposition:v:1 attached_pic output.mp4
</code></pre>
<ul>
<li>
<p><code>-filter_complex "[0:v]ass=subtitle.ass[v]"</code>: This is the best practice for applying the <code>ass</code> filter.It explicitly takes the main video stream from the first input([0:v]), applies the <code>ass</code> filter (which automatically reads from <code>subtitle.ass</code>), and names the resulting filtered video stream <code>[v]</code>.This is much clearer and less prone to error</p>
</li>
<li>
<p><code>-map [v]</code>: We then map this newly filtered video stream (<code>[v]</code>) to the output.This ensures that only the main video with the burned-in subtitles is included.</p>
</li>
<li>
<p>The other <code>-map</code> flags remain the same: <code>-map 0:a</code> for the audio and <code>-map 1:v</code> for the cover image.The <code>-c:v:1 mjpeg -disposition:v:1 attached_pic</code> part is now correctly applied to the mapped cover image stream.</p>
</li>
</ul>
<p><strong>方法二：先压入字幕后压入封面</strong></p>
<p>STEP1</p>
<pre><code>ffmpeg -i input.mp4 -vf "ass=subtitle.ass" -c:v libx264 -crf 18 -c:a copy output.mp4
</code></pre>
<ul>
<li><code>-vf "ass=subtitle.ass"</code>: 这是关键的视频滤镜。ass 滤镜会读取.ass文件并将其内容绘制到视频帧上。</li>
</ul>
<p>STEP2</p>
<pre><code>ffmpeg -i input.mp4 -i cover.jpg -map 0:v -map 0:a -map 1:v -c:v copy -c:a copy -c:v:1 mjpeg -disposition:v:1 attached_pic output.mp4
</code></pre>
<ul>
<li><code>-c:v:1 mjpeg -disposition:v:1 attached_pic</code>：这些参数只作用于<strong>第二个视频流（v:1）</strong>，也就是你的封面图片，将其正确处理为内嵌封面。</li>
</ul>
<h3>😇 6. 使用FFmpeg为MKV视频格式文件压入软字幕（不重新编码）</h3>
<pre><code>ffmpeg -i input.mkv -i cover.jpg -i subtitle.ass -map 0:v -map 0:a -map 1:v -map 2:s -c copy -disposition:v:1 attached_pic output.mkv
</code></pre>
<ul>
<li>
<p><code>-i input.mkv</code>: 你的第一个输入文件。</p>
</li>
<li>
<p><code>-i cover.jpg</code>: 你的第二个输入文件，封面图片。</p>
</li>
<li>
<p><code>-i subtitle.ass</code>: 你的第三个输入文件，字幕文件。</p>
</li>
<li>
<p><code>-map 0:v</code>: 映射第一个输入文件（<code>input.mkv</code>）中的视频流。</p>
</li>
<li>
<p><code>-map 0:a</code>: 映射第一个输入文件（<code>input.mkv</code>）中的音频流。</p>
</li>
<li>
<p><code>-map 1:v</code>: 映射第二个输入文件（<code>cover.jpg</code>）中的视频流。</p>
</li>
<li>
<p><code>-map 2:s</code>: 映射第三个输入文件（<code>subtitle.ass</code>）中的字幕流。</p>
</li>
<li>
<p><code>-c copy</code>: 这是最重要的参数，它告诉 FFmpeg <strong>直接复制所有流</strong>，不进行任何重新编码。因为 MKV 容器支持将字幕和封面作为独立的流，所以无需进行耗时的转码。</p>
</li>
<li>
<p><code>-disposition:v:1 attached_pic</code>: 这个参数是关键，它告诉 FFmpeg 将第二个输入文件（你的封面图片）标记为“附加图片”，这样播放器就能识别并显示它作为封面。</p>
</li>
<li>
<p><code>output.mkv</code>: 最终输出的文件名。</p>
</li>
</ul>
<p>这个命令利用了 MKV 容器的灵活性，实现了<strong>快速、无损地</strong>添加封面和软字幕。</p>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="FFmpeg"></category>
  </entry>
  <entry>
    <title>删除etc目录后如何把备份的etc目录重新恢复</title>
    <link href="https://love.nagisadaisuki.icu/posts/record_etc_deleted/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/record_etc_deleted/</id>
    <published>2025-06-08T00:00:00.000Z</published>
    <updated>2025-06-08T00:00:00.000Z</updated>
    <summary>broken system recovery.</summary>
    <content type="html"><![CDATA[<h2>我是Retard</h2>
<h3>删除/etc目录后如何使用LiveCD和已经备份的/etc目录恢复</h3>
<ol>
<li><strong>准备一个 Linux Live CD/USB：</strong></li>
</ol>
<ul>
<li>下载一个你常用的 Linux 发行版（如 Ubuntu, Fedora, Debian）的 ISO 镜像文件。</li>
<li>使用工具（如 Rufus, Etcher, Ventoy, 或直接 dd 命令）将 ISO 镜像写入 USB 闪存盘，制作成启动盘。</li>
</ul>
<ol>
<li><strong>从 Live CD/USB 启动计算机：</strong></li>
</ol>
<ul>
<li>将制作好的 Live USB 插入计算机。
重启计算机，并进入 BIOS/UEFI 设置，将启动顺序设置为从 USB 启动。</li>
<li>选择“尝试 Ubuntu”（Try Ubuntu）或“救援模式”（Rescue Mode）等选项，进入 Live 环境。</li>
</ul>
<ol>
<li><strong>识别并挂载你的根文件系统：</strong></li>
</ol>
<ul>
<li>进入 Live 环境后，打开一个终端（通常在Applications -&gt; Utilities -&gt; Terminal）。</li>
<li>使用 <code>lsblk</code> 或 <code>fdisk -l</code> 命令查看你的磁盘分区。你需要找到你的 Linux 根分区（通常是 / 目录所在的分区）。例如，它可能是 <code>/dev/sda1</code>、<code>/dev/nvme0n1p2</code> 等。</li>
<li>创建一个挂载点，并挂载你的根分区。假设你的根分区是 <code>/dev/sda1</code>：</li>
</ul>
<pre><code>sudo mkdir /mnt/rootfs
sudo mount /dev/sda1 /mnt/rootfs
</code></pre>
<p><em>如果你的系统有单独的 <code>/boot</code>、<code>/var</code> 等分区，你可能也需要挂载它们到 <code>/mnt/rootfs</code> 下对应的位置。例如，如果 <code>/boot</code> 在 <code>/dev/sda2</code>：</em></p>
<pre><code>sudo mount /dev/sda2 /mnt/rootfs/boot
</code></pre>
<h3>挂载 @ 和 @home 子卷的步骤</h3>
<p><strong>挂载 <code>@</code> 子卷：</strong></p>
<p>你需要使用 subvol=@ 选项来指定挂载哪个子卷。</p>
<pre><code>sudo mount -o subvol=@ /dev/sda1 /mnt/rootfs
</code></pre>
<ul>
<li><code>-o subvol=@</code>：指定挂载名为 <code>@</code> 的子卷。</li>
<li><code>/dev/sda1</code>：你的 Btrfs 文件系统所在的物理分区设备。</li>
<li><code>/mnt/rootfs</code>：你为这个子卷创建的挂载点。</li>
</ul>
<p><strong>挂载 <code>@home</code> (主目录) 子卷：</strong></p>
<pre><code>sudo mount -o subvol=@home /dev/sda1 /mnt/rootfs/home
</code></pre>
<ul>
<li><code>-o subvol=@home</code>：指定挂载名为 <code>@home</code> 的子卷。</li>
<li><code>/dev/sda1</code>：同样是你的 Btrfs 文件系统所在的物理分区设备。</li>
<li><code>/mnt/rootfs/home</code>：这是 <code>@</code> 子卷内部的 <code>/home</code> 目录，现在 <code>@home</code> 子卷的内容会覆盖并显示在这个路径上。</li>
</ul>
<h3>看看Gemini给的删除/etc的后果</h3>
<p>删除 Linux 系统中的 <code>/etc</code> 目录是一个<strong>灾难性的操作</strong>，会导致系统立即或在下次重启时<strong>完全无法正常工作</strong>。<code>/etc</code> 目录包含了几乎所有系统级别的配置文件，这些文件定义了系统如何运行、用户如何认证、网络如何配置、服务如何启动等等。</p>
<h3>后续操作（恢复或备份）</h3>
<pre><code>sudo rm -rf /mnt/rootfs/etc # 确保旧的 /etc 被彻底清除（如果还有残余）
sudo tar -xzvpf /path/to/your/etc_backup.tar.gz -C /mnt/rootfs/
# 确保 /path/to/your/etc_backup.tar.gz 是你备份文件在 Live 环境下的实际路径
# 例如，如果备份在另一个U盘，它可能在 /media/ubuntu/YOUR_USB_LABEL/etc_backup.tar.gz
</code></pre>
<h2>删除 <code>/etc</code>目录后会发生的一些严重后果</h2>
<h4>1. 系统立即失效或行为异常</h4>
<ul>
<li><strong>服务崩溃</strong>： 大多数系统服务（如网络服务、SSH 服务器、Web 服务器、数据库等）的配置文件都存储在 <code>/etc</code> 中。删除 <code>/etc</code> 会导致这些服务无法找到其配置，从而停止运行或无法启动。</li>
<li><strong>网络中断</strong>： 你的网络配置（如 IP 地址、DNS 服务器、路由表）通常在 <code>/etc/network/interfaces</code> (Debian/Ubuntu) 或 <code>/etc/sysconfig/network-scripts</code>(CentOS/RHEL) 等文件中。删除后，网络连接会立即中断或无法建立。</li>
<li><strong>用户认证失败</strong>： 用户和组的信息（<code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>）以及 <code>sudo</code> 配置（<code>/etc/sudoers</code>）都位于 <code>/etc</code>。你将无法登录到系统，或者即使能登录，也无法使用 <code>sudo</code> 命令提升权限。</li>
<li><strong>Shell 行为异常</strong>： Shell 的配置文件（如 <code>/etc/bash.bashrc</code>, <code>/etc/profile</code>）也会丢失，导致命令行环境无法正常工作。</li>
<li>日志和系统监控停止： 日志配置（<code>/etc/rsyslog.conf</code>, <code>/etc/logrotate.d</code>）和各种监控工具的配置也会丢失。</li>
</ul>
<h4>2. 无法重启或启动失败</h4>
<ul>
<li><strong>启动脚本丢失</strong>： <code>/etc</code> 包含了系统启动时需要运行的大量脚本和配置，例如 <code>/etc/fstab</code>（文件系统挂载点）、<code>/etc/init.d</code> 或 <code>/etc/systemd</code>（服务启动配置）。没有这些文件，系统将无法正确挂载文件系统，也无法启动必要的系统服务。</li>
<li><strong>内核参数丢失</strong>： 内核启动参数（<code>/etc/default/grub</code>）也可能受影响，导致引导加载程序（GRUB）无法找到正确的启动参数。</li>
<li><strong>重要库和程序配置丢失</strong>： 许多程序和库也依赖 /etc 中的配置文件来正确加载和运行。</li>
</ul>
<h4>3. 数据恢复极其困难（通常不可行）</h4>
<ul>
<li><strong>没有简单的恢复方法</strong>： <code>/etc</code> 目录下的文件数量庞大且复杂，每个文件都对系统的正常运行至关重要。没有备份的情况下，几乎不可能手动重新创建或恢复所有丢失的配置。</li>
<li><strong>软件包管理系统受损</strong>： 像 <code>apt</code> (Debian/Ubuntu) 或 <code>yum/dnf</code> (CentOS/RHEL) 这样的包管理器本身也有很多配置在 <code>/etc</code> 下。即使你能勉强进入系统，包管理器也可能无法工作，导致无法通过重新安装软件包来恢复配置。</li>
<li><strong>唯一可靠的恢复方法是</strong>：
<ul>
<li><strong>从最近的备份中恢复</strong>： 如果你有 <code>/etc</code> 目录的完整备份（强烈推荐！），这是唯一可靠的恢复方法。你需要通过 Live CD/USB 启动系统，然后将备份恢复到 <code>/etc</code> 目录。</li>
<li><strong>重新安装操作系统</strong>： 在大多数情况下，删除 <code>/etc</code> 后，最现实的解决方案是完全重新安装操作系统。这意味着你将丢失所有系统级别的配置和已安装的软件包。</li>
</ul>
</li>
</ul>
<h4>4. 对其他分区的影响</h4>
<p>如果你的 <code>/home</code> 目录或其他数据分区是独立挂载的，那么这些数据本身不会被删除。但是，你将无法正常访问它们，因为文件系统的挂载信息 (<code>/etc/fstab</code>) 已经丢失。
应用程序的配置可能存储在用户的 <code>~/.config</code> 或 <code>~/</code> 目录中，这些不会丢失，但由于系统环境的破坏，它们可能无法正常运行。</p>
<h4>总结</h4>
<p><strong>删除 <code>/etc</code> 目录是 Linux 系统上最危险的操作之一，因为它会彻底破坏系统的核心配置，导致系统无法使用。</strong> 永远不要随意删除此目录或其中的文件，除非你非常清楚你在做什么并且有完整的备份。</p>
<p><strong>忠告</strong>： 在对 <code>/etc</code> 目录进行任何操作之前，务必进行备份！<code>sudo cp -a /etc /etc_backup</code> 是一个简单的备份方法。</p>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="linux"></category>
  </entry>
  <entry>
    <title>鸟哥Linux笔记</title>
    <link href="https://love.nagisadaisuki.icu/posts/shell_command/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/shell_command/</id>
    <published>2025-06-08T00:00:00.000Z</published>
    <updated>2025-06-08T00:00:00.000Z</updated>
    <summary>Linux 是什么!?</summary>
    <content type="html"><![CDATA[<h1>Linux文件、目录与磁盘格式</h1>
<h2>用户与用户组</h2>
<p><code>useradd</code>、<code>groupadd</code>、<code>chown</code>、<code>chgrp</code>、<code>chmod</code>、<code>usermod</code>、<code>userdel</code>、<code>groupdel</code></p>
<h3>🧑‍💻 一、useradd：添加用户</h3>
<pre><code>sudo useradd [选项] 用户名
</code></pre>
<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-m</code></td>
<td>自动创建用户主目录（如 <code>/home/用户名</code>）</td>
</tr>
<tr>
<td><code>-s /bin/bash</code></td>
<td>指定默认 shell</td>
</tr>
<tr>
<td><code>-g 组名</code></td>
<td>指定主组</td>
</tr>
<tr>
<td><code>-G 组1,组2</code></td>
<td>加入附加组</td>
</tr>
<tr>
<td>示例：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>sudo useradd -m -s /bin/bash -g users -G wheel,developers alice
</code></pre>
<p>然后设置密码：</p>
<pre><code>sudo passwd alice
</code></pre>
<h3>👥 二、groupadd：添加用户组</h3>
<pre><code>sudo groupadd 组名
</code></pre>
<p>示例：</p>
<pre><code>sudo groupadd developers
</code></pre>
<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-g GID</code></td>
<td>设置自定义的GID</td>
</tr>
<tr>
<td><code>-U users</code></td>
<td>设置组成员</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>如果设定的GID已经存在则强制覆盖原组</td>
</tr>
</tbody>
</table>
<h3>📂 三、chown：更改文件/目录的属主和属组（change owner）</h3>
<pre><code>sudo chown [选项] 用户[:组] 文件
</code></pre>
<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-R</code></td>
<td>递归更改目录下所有文件</td>
</tr>
<tr>
<td>示例：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>sudo chown alice file.txt # 改文件属主为 alice
sudo chown alice:developers file.txt # 改文件属主为 alice 属组为 developers 
sudo chown -R bob: /var/www/ # 递归更改整个目录
</code></pre>
<h3>👪 四、chgrp：只更改属组（change group）</h3>
<pre><code>sudo chgrp [选项] 组 文件
</code></pre>
<p>示例：</p>
<pre><code>sudo chgrp developers file.txt
sudo chgrp -R staff /opt/shared # 递归更改整个目录
</code></pre>
<h3>🔐 五、chmod：更改权限（change mode）</h3>
<pre><code>chmod [选项] 模式 文件
</code></pre>
<p>权限符号简记：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code></td>
<td>读权限（4）</td>
</tr>
<tr>
<td><code>w</code></td>
<td>写权限（2）</td>
</tr>
<tr>
<td><code>x</code></td>
<td>执行权限（1）</td>
</tr>
<tr>
<td>模式表示法：</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>数字表示法（常用）：</li>
</ol>
<pre><code>chmod 755 file
# 表示：
# owner: rwx (7), group: rx (5), others: rx (5)
</code></pre>
<ol>
<li>符号表示法：</li>
</ol>
<pre><code>chmod u+x file     # 给属主添加执行权限
chmod g-w file     # 移除属组写权限
chmod o=r file     # 设置其他用户为只读
</code></pre>
<p>递归修改目录：</p>
<pre><code>chmod -R 755 /some/dir
</code></pre>
<p>🎯 权限组合实例：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>数字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>777</code></td>
<td>rwxrwxrwx</td>
<td>所有人可读写执行（不安全）</td>
</tr>
<tr>
<td><code>755</code></td>
<td>rwxr-xr-x</td>
<td>常用于脚本或网站目录</td>
</tr>
<tr>
<td><code>700</code></td>
<td>rwx------</td>
<td>仅属主可读写执行</td>
</tr>
<tr>
<td><code>644</code></td>
<td>rw-r--r--</td>
<td>常用于文本配置文件</td>
</tr>
<tr>
<td><code>600</code></td>
<td>rw-------</td>
<td>私密文件（如密钥）</td>
</tr>
</tbody>
</table>
<h3>👤 六、usermod：修改用户信息</h3>
<pre><code>usermod [选项] 用户名
</code></pre>
<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-l 新用户名</code></td>
<td>修改用户名</td>
</tr>
<tr>
<td><code>-d /新路径</code></td>
<td>修改主目录（需配合 <code>-m</code> 移动内容）</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>移动用户主目录内容到新路径</td>
</tr>
<tr>
<td><code>-s /bin/bash</code></td>
<td>修改默认 shell</td>
</tr>
<tr>
<td><code>-g 组名</code></td>
<td>设置主组</td>
</tr>
<tr>
<td><code>-G 组1,组2,...</code></td>
<td>设置附加组（会覆盖原有附加组）</td>
</tr>
<tr>
<td><code>-aG 组名</code></td>
<td>追加附加组（不删除原有附加组）</td>
</tr>
<tr>
<td><code>-L</code> / <code>-U</code></td>
<td>锁定/解锁账号（禁止/恢复登录）</td>
</tr>
<tr>
<td>🧪 示例：</td>
<td></td>
</tr>
<tr>
<td>➤ 添加用户 alice 到 <code>sudo</code> 组：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>sudo usermod -aG sudo alice
</code></pre>
<p>➤ 修改用户 shell 为 bash：</p>
<pre><code>sudo usermod -s /bin/bash alice
</code></pre>
<p>➤ 改用户名 alice 为 alina：</p>
<pre><code>sudo usermod -l alina alice
</code></pre>
<h3>❌ 七、userdel：删除用户</h3>
<pre><code>userdel [选项] 用户名
</code></pre>
<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-r</code></td>
<td>同时删除用户主目录、邮箱等文件</td>
</tr>
<tr>
<td>🧪 示例：</td>
<td></td>
</tr>
<tr>
<td>➤ 删除用户但保留主目录：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>sudo userdel alice
</code></pre>
<p>➤ 删除用户并清理其主目录：</p>
<pre><code>sudo userdel -r alice
</code></pre>
<blockquote>
<p>⚠️ 注意：如果用户当前正在登录，userdel 会失败，需先 pkill -u alice 再删。</p>
</blockquote>
<h3>👥 八、groupdel：删除组</h3>
<pre><code>sudo groupdel 组名
</code></pre>
<blockquote>
<p>⚠️ 不能删除有用户主组为该组的情况，需先修改相关用户的主组。
🧪 示例：
➤ 删除 developers 组：</p>
</blockquote>
<pre><code>sudo groupdel developers
</code></pre>
<p><strong>🔍 用户和组信息查看补充命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id 用户名</code></td>
<td>查看用户 UID/GID 和所属组</td>
</tr>
<tr>
<td><code>groups 用户名</code></td>
<td>查看该用户所属所有组</td>
</tr>
<tr>
<td><code>getent passwd</code></td>
<td>列出所有用户</td>
</tr>
<tr>
<td><code>getent group</code></td>
<td>列出所有组</td>
</tr>
</tbody>
</table>
<p><strong>✅ 总结小贴士</strong></p>
<table>
<thead>
<tr>
<th>目的</th>
<th>命令示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>修改用户主目录</td>
<td><code>usermod -d /new/home -m user</code></td>
</tr>
<tr>
<td>添加附加组</td>
<td><code>usermod -aG group user</code></td>
</tr>
<tr>
<td>删除用户和主目录</td>
<td><code>userdel -r user</code></td>
</tr>
<tr>
<td>删除无用组</td>
<td><code>groupdel group</code></td>
</tr>
</tbody>
</table>
<h3>🧪 示例：设置目录权限给指定用户和组：</h3>
<pre><code>sudo useradd -m alice # -G devs
sudo groupadd devs # -U alice
sudo usermod -aG devs alice

sudo mkdir /data/project
sudo chown alice:devs /data/project
sudo chmod 770 /data/project
</code></pre>
<p>此时 <code>/data/project</code>：</p>
<ul>
<li>属主是 <code>alice</code>；</li>
<li>属组是 <code>devs</code>；</li>
<li>只有属主和组用户有读写执行权限，其他用户无权访问。</li>
</ul>
<h3>访问权限相关</h3>
<ul>
<li>对文件来讲，权限的功能为：
<ul>
<li><code>r</code>：可读取此一文件的实际内容，如读取文本文件的文字内容等；</li>
<li><code>w</code>：可以编辑、新增或是修改该文件的内容(但不删除该文件)；</li>
<li><code>x</code>：该文件具有可以被系统执行的权限。</li>
</ul>
</li>
<li>对目录来说，权限的功能为：
<ul>
<li><code>r</code>：读取目录中的内容；</li>
<li><code>w</code>：修改目录中的内容；</li>
<li><code>x</code>：访问目录。</li>
</ul>
</li>
</ul>
<hr />
<h2>目录与路径</h2>
<pre><code>.           代表此层目录。
..          代表上一层目录。
-           代表前一个工作目录。
~           代表目前使用者身份所在的家目录。
~username   代表username这个使用者的家目录
</code></pre>
<h3>😎 cd - change directory</h3>
<p>&lt;ins&gt;cd changes the current working directory.&lt;/ins&gt;</p>
<pre><code>cd /path/to/dir
</code></pre>
<h3>😋 pwd - output the current working directory</h3>
<p>&lt;ins&gt;pwd outputs (prints) the current working directory&lt;/ins&gt;</p>
<p><strong>SYNOPSIS(摘要)</strong></p>
<p><code>pwd [-P | --physical]</code>&lt;br&gt;
<code>pwd [-L | --logical]</code></p>
<pre><code>pwd # -p
</code></pre>
<h3>🆕 mkdir - make directories</h3>
<p>&lt;ins&gt; Create the DIRECTORY(ies), if they do not already exist.&lt;/ins&gt;</p>
<pre><code>mkdir [options] dirName
</code></pre>
<p><strong><strong>Common options(常见选项)：</strong></strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-p</code></td>
<td>递归创建多级目录，不存在时自动建父目录</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>设置file mode 而不是使用umask</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>verbose: print a message for each created directory</td>
</tr>
</tbody>
</table>
<h3>❌ rmdir - remove empty directories</h3>
<p>&lt;ins&gt;Remove the DIRECTORY(ies), if they are empty.&lt;/ins&gt;</p>
<pre><code>rmdir -p/-v emptyDir
</code></pre>
<p><strong>✅ 总结表：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>常见用法示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd</code></td>
<td>切换目录</td>
<td><code>cd /etc</code>, <code>cd ..</code></td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>显示当前路径</td>
<td><code>pwd</code></td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录</td>
<td><code>mkdir -p my/data/logs</code></td>
</tr>
<tr>
<td><code>rmdir</code></td>
<td>删除空目录</td>
<td><code>rmdir temp_dir</code></td>
</tr>
</tbody>
</table>
<h3>📁 一、文件与目录操作类</h3>
<p><strong>🔸ls：列出目录内容</strong></p>
<pre><code>ls [选项] [目录]
</code></pre>
<ul>
<li><code>-l</code>： 详细列表</li>
<li><code>-a</code>： 显示隐藏文件</li>
<li><code>-h</code>： 人类可读的文件大小</li>
<li><code>-R</code>：递归列出子目录</li>
</ul>
<p>例：</p>
<pre><code>ls -lah /etc
</code></pre>
<p><strong>🔸cp：复制文件或目录</strong></p>
<pre><code>cp [选项] 源文件 目标
</code></pre>
<ul>
<li><code>-r</code>：递归复制目录</li>
<li><code>-i</code>：覆盖前询问</li>
<li><code>-u</code>：仅复制较新文件</li>
</ul>
<p><strong><strong>其他选项：</strong></strong>
<code>-a</code>:将原有属性复制和链接文件原带复制，
<code>-p</code>:将文件属性一起复制，不复制链接文件(和<code>-a</code>的区别)，<code>-l</code>:硬链接文件建立，<code>-s</code>:软链接文件建立</p>
<p>例：</p>
<pre><code>cp -ri ~/docs /mnt/usb/
cp -rp ~/docs /mnt/usb/
cp -a ~/docs /tmp
</code></pre>
<p><strong>🔸rm：删除文件或目录</strong></p>
<pre><code>rm [选项] 文件/目录
</code></pre>
<ul>
<li><code>-r</code>：递归删除目录</li>
<li><code>-f</code>：强制删除</li>
<li><code>-i</code>：每次删除前确认</li>
</ul>
<p>例：</p>
<pre><code>rm -rf ~/temp/
</code></pre>
<p><strong>🔸mv：移动或重命名文件</strong></p>
<pre><code>mv [选项] 源 目标
</code></pre>
<ul>
<li><code>-i</code>：覆盖时提示</li>
<li><code>-u</code>：仅移动更新文件
例：</li>
</ul>
<pre><code>mv file.txt backup/file.txt
</code></pre>
<p><strong>🔸basename：获取路径中的文件名部分</strong></p>
<pre><code>basename 路径 [后缀]
</code></pre>
<p>例：</p>
<pre><code>basename /etc/passwd # 输出: passwd
basename /path/file.txt .txt # 输出: file
</code></pre>
<p><strong>🔸dirname：获取路径中的目录部分</strong></p>
<pre><code>dirname 路径
</code></pre>
<p>例：</p>
<pre><code>dirname /etc/passwd # 输出：/etc
</code></pre>
<p><strong>🔸touch：创建空文件或更新文件时间戳</strong></p>
<pre><code>touch [-acdmt] 文件
</code></pre>
<ul>
<li><code>-a</code>：仅自定义access time；</li>
<li><code>-t</code>：后面可以接自定义的日期而不用目前的日期，格式为[YYYYMMDDhhmm];</li>
<li><code>-d</code>：接自定义日期</li>
</ul>
<p>例：</p>
<pre><code>touch test
touch -d "2 days ago" bashrc
touch -t 202506051111 bashrc
</code></pre>
<blockquote>
<p>⚠修改的是mtime和atime</p>
</blockquote>
<hr />
<h3>📖 二、查看文件内容类</h3>
<p><strong>🔸cat：连接并显示文件内容</strong></p>
<pre><code>cat [-AbEnTv] files
</code></pre>
<ul>
<li><code>-A</code>：相当于-vET的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><code>-n</code>：打印出行号，连同空白行也有行号，与<code>-b</code>选项不同</li>
<li><code>-b</code>：列出行号，空白行不列</li>
</ul>
<p>例：</p>
<pre><code>cat file.txt
cat -n file.txt 
cat -b /etc/passwd
cat -A /etc/pacman.conf
</code></pre>
<p><strong>🔸tac：逆序显示文件内容</strong></p>
<pre><code>tac file
</code></pre>
<p><strong>🔸more：分页显示（不能向上滚动）</strong></p>
<blockquote>
<p>&lt;ins&gt;空格翻页，less同理&lt;/ins&gt;</p>
</blockquote>
<p><strong>🔸less：分页显示（支持上下滚动）</strong></p>
<blockquote>
<p>❤ 支持向上向下翻动一行，<code>/</code>查找字符串，<code>n</code>向下查找，<code>?</code>向上查找</p>
<blockquote>
<p>&lt;font color="red"&gt;善用<code>man</code>和<code>tldr</code>指令&lt;/font&gt;</p>
</blockquote>
</blockquote>
<p><strong>🔸head：显示前几行</strong></p>
<ul>
<li><code>-n</code>：最常用，代表显示前几行</li>
</ul>
<pre><code>head -n 10 /etc/pacman.conf
</code></pre>
<p>显示文件前十行</p>
<p><strong>🔸tail：显示末尾几行</strong></p>
<ul>
<li><code>-n</code>：显示末尾前几行</li>
<li><code>-f</code>：跟踪文件变化</li>
</ul>
<blockquote>
<p><code>-f</code>用于</p>
<blockquote>
<p>&lt;p style="color:pink"&gt;&lt;ins&gt;日志随时写入情况&lt;/ins&gt;&lt;/p&gt;</p>
</blockquote>
</blockquote>
<pre><code>tail -n 20 /etc/passwd
tail -f /var/log/syslog
</code></pre>
<blockquote>
<p>&lt;font color="#E3A212"&gt;&lt;ins&gt;tail常和head结合使用查找一个ascii文本文件区间范围文本&lt;/ins&gt;&lt;/font&gt;</p>
<blockquote>
<p><strong>显示/etc/pacman.conf文件11到20行</strong></p>
<blockquote>
<p><code>head -n 20 /etc/pacman.conf | tail -n 10</code></p>
<blockquote>
<p><em>先显示前20行后显示后10行</em> &lt;br&gt;</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p><code>cat -n /etc/passwd | head -n 10 | tail -n 5</code></p>
<blockquote>
<p><em>可以列出行号的截取</em></p>
</blockquote>
</blockquote>
<p><strong>🔸od（Octal Dump）：以八进制或十六进制显示文件内容（用于二进制分析）</strong></p>
<pre><code>od [-t type] 文件
</code></pre>
<p><code>-t</code>后面可以接各种类型的输出，例如：</p>
<p>a   ：利用默认字符来输出 &lt;br&gt;
c   ：使用ASCII字符来输出&lt;br&gt;
d [size]  ：使用十进制(decimal)来输出数据，每个整数占用size Bytes；&lt;br&gt;
f [size]  ：使用浮点数输出，其他同上&lt;br&gt;
o [size]  ：八进制&lt;br&gt;
x [size]  ：十六进制&lt;br&gt;</p>
<ul>
<li>范例一：将<code>/usr/bin/passwd</code>的内容使用ASCII方式来显示。</li>
</ul>
<pre><code>od -t c /usr/bin/passwd
</code></pre>
<ul>
<li>范例二：将<code>/etc/issue</code>这个文件内容以八进制列出存储值</li>
</ul>
<pre><code>od -t oCc /etc/issue
</code></pre>
<ul>
<li>范例三：用作ascii对照表查找字符的ASCII码</li>
</ul>
<pre><code>echo password | od -t oCc
</code></pre>
<blockquote>
<p>其实不用带<code>-t</code>也可以</p>
</blockquote>
<hr />
<h3>🔒 三、权限与属性管理</h3>
<p><strong>🔸chattr：改变文件属性（适用于 ext 和部分文件系统）</strong></p>
<pre><code>chattr [+-=] [ASacdistu] 文件或目录名称
</code></pre>
<ul>
<li><code>-i</code>：让一个文件「不能被删除，改名，设置链接也无法写入或新增数据」</li>
<li><code>-c</code>：设置这个属性会使文件自动被压缩，读取时解压缩</li>
</ul>
<pre><code>chattr +i file
chattr -i file
chattr +c file
chattr -c file
</code></pre>
<p><strong>🔸lsattr：查看文件属性</strong></p>
<pre><code>lsattr [-adR] 文件或目录
</code></pre>
<blockquote>
<p><strong>man chattr</strong> or <em>tldr lsattr</em></p>
</blockquote>
<p><strong>🔸umask：显示或设置默认权限掩码</strong></p>
<pre><code>umask / umask -S/s和-p都是显示隐藏的默认创建文件权限码
umask 022 设置创建文件时的文件权限
</code></pre>
<hr />
<h3>🧩 四、文件类型与状态</h3>
<p><strong>🔸file：识别文件类型</strong></p>
<pre><code>file /bin/ls
</code></pre>
<p><strong>🔸stat：查看详细状态（权限、大小、时间戳）</strong></p>
<pre><code>stat filename
</code></pre>
<hr />
<h3>🔎 五、文件查找与定位</h3>
<p><strong>🔸which：查命令路径（依赖 $PATH）</strong></p>
<pre><code>which bash
</code></pre>
<p><strong>🔸whereis：查命令、源码、man 手册位置</strong></p>
<pre><code>whereis ls
</code></pre>
<p><strong>🔸locate：快速查找文件（依赖数据库）</strong></p>
<pre><code>sudo updatedb
locate passwd
</code></pre>
<p><strong>🔸find：遍历文件系统查找文件(最常用)</strong>
<code>find 路径 条件 动作</code></p>
<ol>
<li><strong>与时间有关的选项：<code>-atime</code>,<code>-citme</code>,<code>mtime</code>，以<code>mtime</code>举例</strong></li>
</ol>
<ul>
<li><code>-mtime n</code>：n为数字，意义为在n天之前的「一天之内」被修改过内容的文件；</li>
<li><code>-mtime +n</code>：列出在n天之前(不含n天本身)被修改过内容的文件；</li>
<li><code>-mtime -n</code>：列出在n天之内(含n天本身)被修改过内容的文件；</li>
<li><code>-newer file</code>：file为一个存在的文件，列出比file还要新的文件</li>
</ul>
<p>范例一：将系统上24小时内有修改过的文件列出</p>
<p><code>find / -mtime 0</code></p>
<p>将三天前那一天的24小时内有修改过的文件列出</p>
<p><code>find / -mtime 3</code></p>
<p>范例二：寻找<code>/etc</code>下的文件，如果文件日期比<code>/etc/passwd</code>新就列出</p>
<p><code>find /etc -newer /etc/passwd</code></p>
<p>三天内&lt;br&gt;
<code>find / -mtime -3</code></p>
<p>三天外&lt;br&gt;
<code>find / -mtime +3</code></p>
<ol>
<li><strong>与使用者或用户组有关的参数：<code>-uid n</code>,<code>-gid n</code>,<code>-user name</code>,<code>-group name</code>,<code>-nouser</code>,<code>-nogroup</code></strong></li>
</ol>
<p>范例三：查找/home下属于Nagisa的文件</p>
<p><code>find /home -user Nagisa</code></p>
<p>范例四：查找系统中不属于任何人的文件</p>
<p><code>find / -nouser</code></p>
<ol>
<li><strong>与文件权限及名称有关的参数：<code>-name filename</code>,<code>-size [+-]SIZE</code>(查找比SIZE还要大(+)的或小(-)的文件,size规格为<code>c</code>Bytes和<code>k</code>KBytes),<code>-type TYPE</code>;<code>-perm -mode / /mode</code>;</strong>
范例五：找出文件名为passwd的文件</li>
</ol>
<p><code>find / -name passwd</code></p>
<p>范例六：找出包含passwd关键字的文件</p>
<p><code>find / -name "*passwd*"</code></p>
<p>范例七：找出在<code>/run</code>目录下，文件类型为socket的文件名有哪些？</p>
<p><code>find /run -type s</code></p>
<p>范例八：查找文件当中含有SGID、SUID、SBIT属性的文件
<code>find / -perm /7000</code></p>
<blockquote>
<p>所谓的7000就是 <code>---s--s--t</code>,那么只要含有s或t的就列出，所以当然要使用<code>/7000</code></p>
<blockquote>
<p>使用<code>-7000</code>需要同时含有这三个权限</p>
<blockquote>
<p>-perm 亦可用于普通权限文件查找&lt;br&gt;
<code>find /usr/bin -perm 755</code></p>
</blockquote>
</blockquote>
</blockquote>
<p>常用例：</p>
<pre><code>find /usr/bin /usr/sbin -perm /6000 # 无SBIT权限

inshell: $(find "$WALLPAPER_DIR" -type f \( -iname "*.jpg" -o -iname "*.png" -o -iname "*.jpeg" -o \) | shuf -n 1) 
# 随机抽取指定目录下的一张指定格式的图片

find . -type f \( -name "*.txt" -o -name "*.md" \) ! -name "README.md"
# 查找当前目录下，**文件类型是普通文件**，扩展名为.txt 或 .md 但不包括 README.md的文件

find . -type f ! -name "*.bak"
# 排除以.bak结尾的文件

find . -name "*.tmp" -delete
# 删除文件 (-delete 一定要配合 -type f 使用防止误删文件)

find . -name "*.log" -exec rm {} \; # 删除 .log 文件
find . -type f -exec chmod 644 {} \; # 批量修改权限
find . -name "*.txt" -exec wc -l {} + # +可以批量处理 统计所有txt行数

find . -name "*.log" | xargs rm
# 搭配xargs 

find . -type f -empty # 空文件
find . -type d -empty # 空目录

find . -name "*.mp3" -exec mv {} /target/dir/ \;
find . -name ".jpg" -exec cp {} /backup/ \;
# 查找并移动/复制文件

find . -maxdepth 1 -name "*.sh" # 当前目录下查找
find . -mindepth 2 # 忽略前几层目录
</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>与 (AND)</th>
<th>或 (OR)</th>
<th>非 (NOT)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Shell 命令行</td>
<td><code>&amp;&amp;</code></td>
<td><code>||</code></td>
<td><code>!</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>find</code> 命令中</td>
<td><code>-a</code>（可省略）</td>
<td><code>-o</code></td>
<td><code>!</code> 或 <code>-not</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>4.<strong>额外可以进行的操作：<code>-exec command</code>(command为其他命令，-exec后面再接额外命令来处理查找到的结果),<code>-print</code>(将结果打印到屏幕上，默认操作)</strong></p>
<p>范例九：将上个范例找到的文件使用ls -l列出来</p>
<p><code>find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \;</code></p>
<blockquote>
<p><code>ls -l</code>就是额外的command，命令不支持命令别名</p>
<blockquote>
<p>所以只能用&lt;ins&gt;<code>ls -l</code>&lt;/ins&gt;不可以使用&lt;ins&gt;<code>ll</code>&lt;/ins&gt;</p>
</blockquote>
</blockquote>
<p>范例十：找出系统中大于1MB的文件</p>
<p><code>find / -size +1M</code></p>
<p>范例十一：找出系统中小于1KB的文件</p>
<p><code>find / -size -1k</code></p>
<p>✅ 总结（速查）</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>按名查</td>
<td><code>-name</code> / <code>-iname</code></td>
</tr>
<tr>
<td>按类型</td>
<td><code>-type f</code> / <code>-type d</code></td>
</tr>
<tr>
<td>按时间</td>
<td><code>-mtime -n</code> / <code>-newer</code></td>
</tr>
<tr>
<td>按大小</td>
<td><code>-size +100M</code></td>
</tr>
<tr>
<td>空文件</td>
<td><code>-empty</code></td>
</tr>
<tr>
<td>权限查</td>
<td><code>-perm 755</code></td>
</tr>
<tr>
<td>排除条件</td>
<td><code>! -name</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>-delete</code></td>
</tr>
<tr>
<td>执行命令</td>
<td><code>-exec</code> 或配合 <code>xargs</code></td>
</tr>
<tr>
<td>限制深度</td>
<td><code>-maxdepth</code>、<code>-mindepth</code></td>
</tr>
<tr>
<td>跳过目录</td>
<td><code>-prune</code></td>
</tr>
</tbody>
</table>
<h3>💨 Extra、文件特殊权限：SUID、SGID、SBIT</h3>
<pre><code>chmod u+s # SUID设置
chmod g+s # SGID设置
chmod +t  # SBIT设置
</code></pre>
<ul>
<li>&lt;font color="#8BDB67"&gt;文件具有<code>SUID</code>的特殊权限时，代表当用户执行此二进制程序时，在执行过程中用户会暂时具有程序拥有者的权限&lt;/font&gt;</li>
<li>&lt;font color="#39DBB5"&gt;目录具有<code>SGID</code>的特殊权限时，代表用户在这个目录下面新建的文件的用户组都会与该目录的组名相同&lt;/font&gt;</li>
<li>&lt;font color="#82DBA8"&gt;目录具有<code>SBIT</code>的特殊权限时，代表在该目录下用户建立的文件只有自己与root能够删除&lt;/font&gt;</li>
</ul>
<hr />
<h2>磁盘与文件系统</h2>
<blockquote>
<p>MBR: Master Boot Record&lt;br&gt;
GPT: GUID Partition Table</p>
</blockquote>
<h3>一、磁盘分区 (Partitioning)</h3>
<h4>1. 查看磁盘信息</h4>
<ul>
<li><strong><code>lsblk</code></strong>: 列出所有块设备及其分区信息，包括设备名称、大小、挂载点、文件系统类型等。这是最常用且直观的命令。<pre><code>lsblk
</code></pre>
</li>
<li><strong><code>fdisk -l</code></strong>: 列出所有磁盘的分区表信息。<pre><code>sudo fdisk -l
</code></pre>
</li>
<li><strong><code>parted -l</code></strong>: 另一个查看分区表的工具，对于 GPT 分区表支持更好。<pre><code>sudo parted -l
</code></pre>
</li>
</ul>
<h4>2. 分区工具</h4>
<ul>
<li>
<p><strong><code>fdisk</code> (MBR 和 GPT):</strong> 适用于传统的 MBR (Master Boot Record) 分区表，也支持 GPT (GUID Partition Table) 分区表。它是交互式的。</p>
<pre><code>sudo fdisk /dev/sdX  # 替换 /dev/sdX 为你的磁盘设备名，例如 /dev/sdb
</code></pre>
<p>进入 <code>fdisk</code> 后，可以使用以下常用命令：</p>
<ul>
<li><code>m</code>: 显示帮助信息。</li>
<li><code>p</code>: 打印当前磁盘的分区表。</li>
<li><code>n</code>: 创建新分区。</li>
<li><code>d</code>: 删除分区。</li>
<li><code>w</code>: 将更改写入磁盘并退出。</li>
<li><code>q</code>: 不保存更改并退出。</li>
</ul>
</li>
<li>
<p><strong><code>parted</code> (MBR 和 GPT):</strong> 功能更强大，尤其在处理大容量磁盘和 GPT 分区时更为灵活。可以交互式使用，也可以通过命令行直接操作。</p>
<pre><code>sudo parted /dev/sdX  # 替换 /dev/sdX 为你的磁盘设备名
</code></pre>
<p>进入 <code>parted</code> 后，可以使用以下常用命令：</p>
<ul>
<li><code>print</code>: 打印分区表。</li>
<li><code>mklabel gpt</code> 或 <code>mklabel msdos</code>: 创建新的分区表类型 (GPT 或 MBR)。</li>
<li><code>mkpart primary ext4 0% 100%</code>: 创建一个主分区，文件系统类型为 ext4，从磁盘的0%到100%。你可以根据需要调整大小和文件系统类型。</li>
<li><code>resizepart</code>: 调整分区大小。</li>
<li><code>rm</code>: 删除分区。</li>
<li><code>quit</code>: 退出。</li>
</ul>
</li>
</ul>
<hr />
<h3>二、文件系统格式化 (Formatting File Systems)</h3>
<p>创建分区后，需要对其进行格式化以创建文件系统，才能存储数据。</p>
<ul>
<li><strong><code>mkfs</code> 系列命令：</strong> <code>mkfs</code> 是一个通用命令，后面可以跟不同的文件系统类型。
<ul>
<li><strong>Ext4 (Linux 常用):</strong><pre><code>sudo mkfs.ext4 /dev/sdXY  # 替换 /dev/sdXY 为你的分区名，例如 /dev/sdb1
</code></pre>
或者<pre><code>sudo mkfs -t ext4 /dev/sdXY
</code></pre>
</li>
<li><strong>XFS:</strong><pre><code>sudo mkfs.xfs /dev/sdXY
</code></pre>
</li>
<li><strong>FAT32 (兼容 Windows):</strong><pre><code>sudo mkfs.vfat /dev/sdXY  # 或者 mkfs.fat -F 32 /dev/sdXY
</code></pre>
</li>
<li><strong>NTFS (兼容 Windows):</strong><pre><code>sudo mkfs.ntfs /dev/sdXY
</code></pre>
</li>
<li><strong>Btrfs:</strong><pre><code>sudo mkfs.btrfs /dev/sdXY
</code></pre>
</li>
</ul>
</li>
</ul>
<hr />
<h3>三、分区分卷 (Logical Volume Management - LVM)</h3>
<p>LVM 允许你将多个物理磁盘或分区组合成一个或多个逻辑卷，从而提供更大的灵活性，例如在线调整大小、创建快照等。</p>
<h4>LVM 基本概念</h4>
<ul>
<li><strong>PV (Physical Volume - 物理卷):</strong> 物理磁盘或分区，LVM 的最基本单元。</li>
<li><strong>VG (Volume Group - 卷组):</strong> 一个或多个 PV 的集合。</li>
<li><strong>LV (Logical Volume - 逻辑卷):</strong> 在 VG 上创建的虚拟分区，可以像普通分区一样格式化和挂载。</li>
</ul>
<h4>LVM 常用命令</h4>
<ul>
<li><strong>创建 PV:</strong><pre><code>sudo pvcreate /dev/sdXY  # 将分区标记为物理卷
</code></pre>
</li>
<li><strong>查看 PV:</strong><pre><code>sudo pvs
sudo pvdisplay
</code></pre>
</li>
<li><strong>创建 VG:</strong><pre><code>sudo vgcreate my_vg /dev/sdb1 /dev/sdc1  # 创建名为 my_vg 的卷组，包含 sdb1 和 sdc1
</code></pre>
</li>
<li><strong>查看 VG:</strong><pre><code>sudo vgs
sudo vgdisplay
</code></pre>
</li>
<li><strong>从 VG 中扩展/移除 PV:</strong><pre><code>sudo vgextend my_vg /dev/sdd1  # 将 sdd1 添加到 my_vg
sudo vgreduce my_vg /dev/sdd1  # 从 my_vg 移除 sdd1 (需确保上面没有 LV)
</code></pre>
</li>
<li><strong>创建 LV:</strong><pre><code>sudo lvcreate -L 10G -n my_lv my_vg  # 在 my_vg 中创建名为 my_lv 的 10GB 逻辑卷
sudo lvcreate -l 100%FREE -n my_lv my_vg # 使用 VG 中所有可用空间创建 LV
</code></pre>
</li>
<li><strong>查看 LV:</strong><pre><code>sudo lvs
sudo lvdisplay
</code></pre>
</li>
<li><strong>调整 LV 大小 (扩展/收缩):</strong><pre><code>sudo lvextend -L +5G /dev/my_vg/my_lv  # 将 my_lv 扩展 5GB
sudo lvreduce -L -2G /dev/my_vg/my_lv  # 将 my_lv 缩小 2GB (有数据丢失风险，需先卸载和检查文件系统)
</code></pre>
<ul>
<li><strong>注意：</strong> 扩展逻辑卷后，需要同时扩展文件系统才能使用新增的空间。
<ul>
<li>Ext4: <code>sudo resize2fs /dev/my_vg/my_lv</code></li>
<li>XFS: <code>sudo xfs_growfs /dev/my_vg/my_lv</code> (通常不需要卸载)</li>
</ul>
</li>
</ul>
</li>
<li><strong>删除 LV:</strong><pre><code>sudo lvremove /dev/my_vg/my_lv  # 删除逻辑卷
</code></pre>
</li>
<li><strong>删除 VG:</strong><pre><code>sudo vgremove my_vg  # 删除卷组 (需确保卷组中没有 LV)
</code></pre>
</li>
<li><strong>删除 PV:</strong><pre><code>sudo pvremove /dev/sdXY  # 删除物理卷 (需确保物理卷没有被任何 VG 使用)
</code></pre>
</li>
</ul>
<blockquote>
<p>Btrfs分卷查看Archlinux系统安装--&gt;<a href="https://arch.icekylin.online/guide/rookie/basic-install-detail.html">Why Btrfs</a></p>
</blockquote>
<hr />
<h3>四、分区挂载 (Mounting)</h3>
<p>将格式化后的分区或逻辑卷连接到文件系统树中的一个目录，使其可以被访问。</p>
<h4>1. 创建挂载点</h4>
<ul>
<li>挂载点是一个普通的空目录。<pre><code>sudo mkdir /mnt/mydata  # 创建一个名为 mydata 的挂载点
</code></pre>
</li>
</ul>
<h4>2. 临时挂载</h4>
<ul>
<li><strong>基本挂载：</strong><pre><code>sudo mount /dev/sdXY /mnt/mydata  # 挂载分区 /dev/sdXY 到 /mnt/mydata
</code></pre>
</li>
<li><strong>指定文件系统类型：</strong> (通常不需要，<code>mount</code> 命令可以自动识别)<pre><code>sudo mount -t ext4 /dev/sdXY /mnt/mydata
</code></pre>
</li>
<li><strong>只读挂载：</strong><pre><code>sudo mount -o ro /dev/sdXY /mnt/mydata
</code></pre>
</li>
<li><strong>重新挂载 (改变挂载选项)：</strong><pre><code>sudo mount -o remount,rw /mnt/mydata  # 将已挂载的 /mnt/mydata 重新挂载为读写模式
</code></pre>
</li>
<li><strong>查看已挂载的文件系统：</strong><pre><code>mount          # 列出所有已挂载的文件系统
df -h          # 以人类可读的方式显示磁盘空间使用情况，包括挂载点
lsblk -f       # 显示块设备的文件系统信息和挂载点
</code></pre>
</li>
</ul>
<h4>3. 卸载分区</h4>
<ul>
<li>在卸载之前，确保没有程序正在使用该挂载点下的文件。<pre><code>sudo umount /mnt/mydata  # 卸载 /mnt/mydata 目录
sudo umount /dev/sdXY    # 卸载 /dev/sdXY 分区
</code></pre>
</li>
<li>如果无法卸载（“device is busy”），可以使用 <code>lsof</code> 或 <code>fuser</code> 命令查找占用进程：<pre><code>sudo lsof /mnt/mydata
sudo fuser -km /mnt/mydata  # 强制杀死占用进程并卸载
</code></pre>
</li>
</ul>
<h4>4. 永久挂载 (<code>/etc/fstab</code>)</h4>
<ul>
<li>为了在系统启动时自动挂载分区，需要编辑 <code>/etc/fstab</code> 文件。</li>
<li><strong>推荐使用 UUID (Universally Unique Identifier) 来标识分区，因为设备名（如 <code>/dev/sdb1</code>）可能会在重启后改变。</strong>
<ul>
<li>查找分区的 UUID：<pre><code>sudo blkid /dev/sdXY
</code></pre>
</li>
<li>编辑 <code>/etc/fstab</code> 文件：<pre><code>sudo nano /etc/fstab  # 或者使用 vi、vim 等编辑器
</code></pre>
</li>
<li>在文件末尾添加一行，格式如下：<pre><code>UUID=&lt;你的UUID&gt;  /mnt/mydata  ext4  defaults  0  2
</code></pre>
<ul>
<li><strong><code>&lt;你的UUID&gt;</code>:</strong> 替换为你的分区的实际 UUID。</li>
<li><code>/mnt/mydata</code>: 挂载点。</li>
<li><code>ext4</code>: 文件系统类型。</li>
<li><code>defaults</code>: 常用挂载选项 (rw, suid, dev, exec, auto, nouser, async)。</li>
<li><code>0</code>: dump 选项，通常为 0 (不备份)。</li>
<li><code>2</code>: fsck 检查顺序，根文件系统为 1，其他为 2，不检查为 0。</li>
</ul>
</li>
</ul>
</li>
<li><strong>测试 <code>/etc/fstab</code> 配置：</strong><pre><code>sudo mount -a  # 尝试挂载所有在 /etc/fstab 中列出的但尚未挂载的文件系统
</code></pre>
如果没有任何错误输出，说明配置正确。如果有错误，请检查 <code>/etc/fstab</code> 文件。</li>
</ul>
<hr />
<h2>文件与文件系统的压缩</h2>
<p>&lt;ins&gt;Linux文件压缩技术的核心原理主要是通过消除数据冗余来实现的，通常采用无损压缩算法。简单来说，就是想办法用更少的位（bits）来表示相同的信息。&lt;/ins&gt;</p>
<h2>核心原理</h2>
<ol>
<li>
<h3><strong>数据冗余的消除</strong></h3>
<p>文件中的数据往往存在大量的重复和可预测的模式。压缩算法会识别这些“冗余”并将其替换为更短的表示。</p>
<ul>
<li><strong>重复数据查找和替换：</strong> 这是最直观的方法。如果文件中有大量重复的字符序列，例如“AAAAA”，压缩算法会用一个更短的编码来表示“5个A”，而不是重复写5次“A”。</li>
<li><strong>字典编码（如LZ77/LZ78）：</strong>
<ul>
<li><strong>LZ77</strong> 算法（Lempel-Ziv 77）通过在文件已处理的数据中查找与当前数据流的匹配项。如果找到一个匹配，它就用一个指向匹配位置和匹配长度的“指针”来替换重复数据。这就像建立了一个临时字典，引用已出现过的短语。</li>
<li><strong>LZ78</strong> 算法（Lempel-Ziv 78）则会构建一个显式的字典。它将文件中出现的新的字符串添加到字典中，并用字典中的索引来替换这些字符串。当遇到重复的字符串时，直接用字典索引表示。</li>
</ul>
</li>
<li><strong>熵编码（如霍夫曼编码、算术编码）：</strong> 这种方法基于数据的统计特性。
<ul>
<li><strong>频率分析：</strong> 某些字符或模式在文件中出现的频率更高。</li>
<li><strong>变长编码：</strong> 熵编码利用这种频率差异，为出现频率高的字符分配更短的编码（例如，用1位表示最常见的字符），为出现频率低的字符分配更长的编码。这样一来，文件的平均编码长度就缩短了，从而实现压缩。<strong>霍夫曼编码</strong>就是典型的例子，它通过构建霍夫曼树来生成最优的变长编码。</li>
</ul>
</li>
</ul>
</li>
<li>
<h3><strong>无损压缩 vs. 有损压缩</strong></h3>
<ul>
<li><strong>无损压缩（Lossless Compression）：</strong> Linux文件压缩主要采用的方式。这意味着<strong>在压缩和解压缩后，原始数据可以完全、精确地恢复，没有任何信息损失</strong>。这对于文本文件、程序代码等至关重要，因为任何一点数据丢失都可能导致文件损坏或程序无法运行。<code>gzip</code>、<code>bzip2</code>、<code>xz</code> 等 Linux 命令都属于无损压缩。</li>
<li><strong>有损压缩（Lossy Compression）：</strong> 这种压缩方式会在压缩过程中<strong>舍弃一部分信息以达到更高的压缩比</strong>。解压缩后的数据与原始数据会有所不同，但这种差异通常在特定应用场景下（如图像、音频、视频）是人眼或人耳难以察觉或可以接受的（例如 JPEG 图片和 MP3 音频）。文件压缩通常不使用有损压缩，因为它会改变文件内容。</li>
</ul>
</li>
</ol>
<hr />
<h2>常见的Linux压缩工具及其原理简述</h2>
<table>
<thead>
<tr>
<th>工具/后缀</th>
<th>核心算法</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>gzip (.gz)</strong></td>
<td><strong>Deflate</strong> (LZ77 + 霍夫曼编码)</td>
<td><strong>速度快</strong>，压缩比适中，应用最广泛。</td>
</tr>
<tr>
<td><strong>bzip2 (.bz2)</strong></td>
<td><strong>BWT (Burrows-Wheeler Transform)</strong> + <strong>MTF</strong> + 霍夫曼/算术编码</td>
<td><strong>压缩比通常比gzip高</strong>，但压缩和解压缩<strong>速度相对较慢</strong>，更消耗CPU。</td>
</tr>
<tr>
<td><strong>xz (.xz)</strong></td>
<td><strong>LZMA (Lempel-Ziv-Markov chain Algorithm)</strong></td>
<td><strong>压缩比最高</strong>，尤其适合大型文件。但压缩速度通常<strong>最慢</strong>，也更消耗内存。</td>
</tr>
<tr>
<td><strong>zip (.zip)</strong></td>
<td>通常是 <strong>Deflate</strong></td>
<td><strong>跨平台</strong>压缩格式，可打包多个文件和目录。</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> <code>tar</code> 命令 (<code>.tar</code> 文件) 本身不是压缩工具，它是一个“打包”工具，用于将多个文件和目录合并成一个单一的归档文件。通常会与 <code>gzip</code> (<code>.tar.gz</code> 或 <code>.tgz</code>)、<code>bzip2</code> (<code>.tar.bz2</code> 或 <code>.tbz</code>) 或 <code>xz</code> (<code>.tar.xz</code> 或 <code>.txz</code>) 结合使用，先打包再压缩。</p>
<hr />
<h3>gzip、bzip2、xz、tar 命令详解</h3>
<h3>1. <code>gzip</code> 命令</h3>
<p><code>gzip</code>（GNU zip）是 Linux 中最常用的压缩工具之一，采用 <strong>Deflate</strong> 算法进行无损压缩。</p>
<ul>
<li><strong>功能：</strong> 压缩或解压缩文件。默认会生成 <code>.gz</code> 后缀的压缩文件并删除原文件。</li>
<li><strong>特点：</strong> 压缩速度快，压缩比适中。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-d</code>, <code>--decompress</code>：解压缩。等同于 <code>gunzip</code>。</li>
<li><code>-f</code>, <code>--force</code>：强制执行，覆盖同名文件。</li>
<li><code>-k</code>, <code>--keep</code>：保留原始文件。</li>
<li><code>-v</code>, <code>--verbose</code>：显示详细信息。</li>
<li><code>-c</code>, <code>--stdout</code>：输出到标准输出，不创建文件。</li>
<li><code>-num</code> (e.g., <code>-1</code> 到 <code>-9</code>)：设置压缩级别，<code>-1</code> 最快，<code>-9</code> 最佳（默认 <code>-6</code>）。</li>
</ul>
<p><strong>使用示例：</strong></p>
<pre><code>gzip myfile.txt               # 压缩文件，生成 myfile.txt.gz
gzip -k myfile.txt            # 压缩文件并保留原文件
gzip -d myfile.txt.gz         # 解压缩文件
gzip -l myfile.txt.gz         # 查看压缩信息
gunzip myfile.txt.gz          # 不常用 多用 gzip -d
gzip -v myfile.txt            # 显示压缩过程
zcat myfile.txt.gz            # zcat和gzip -l一样可以查看压缩信息
gzip -9 -c myfile.txt &gt; myfile.txt.gz # 最佳压缩比压缩并保留原本文件
</code></pre>
<h3>2. <code>bzip2</code>命令</h3>
<p><code>bzip2</code>提供比<code>gzip</code>更高的<strong>压缩比</strong>，但压缩和解压缩速度相对较慢，且占用更多内存。</p>
<ul>
<li><strong>功能：</strong> 压缩或解压缩文件。默认会生成 .bz2 后缀的压缩文件并删除原文件。</li>
<li><strong>特点：</strong>  压缩比高，速度慢，资源占用相对较高。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-d</code>, --decompress：解压缩。等同于 bunzip2。</li>
<li><code>-f</code>, --force：强制执行。</li>
<li><code>-k</code>, --keep：保留原始文件。</li>
<li><code>-v</code>, --verbose：显示详细信息。</li>
<li><code>-c</code>, --stdout：输出到标准输出。</li>
<li><code>-num</code>，(e.g. -1 到 -9)：设置压缩级别，默认 -9。</li>
</ul>
<p><strong>使用示例：</strong></p>
<pre><code>bzip2 mydocument.txt          # 压缩文件，生成 mydocument.txt.bz2
bzip2 -k mydocument.txt       # 压缩文件并保留原文件
bzip2 -d mydocument.txt.bz2   # 解压缩文件
bzcat mydocument.txt.bz2      #  查看压缩文件内容（不解压）
bzip2 -c -9 mydocument.txt &gt; mydocument.txt.bz2 # 最佳压缩比压缩并保留原文件
</code></pre>
<h3>3. <code>xz</code>命令</h3>
<p><code>xz</code></p>
<ul>
<li><strong>功能</strong>： 压缩或解压缩文件。默认会生成 <code>.xz</code> 后缀的压缩文件并删除原文件。</li>
<li><strong>特点</strong>： 压缩比最高，速度最慢，压缩时内存消耗最大。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-d</code>, <code>--decompress</code>：解压缩。等同于 <code>unxz</code>。</li>
<li><code>-f</code>, <code>--force</code>：强制执行。</li>
<li><code>-k</code>, <code>--keep</code>：保留原始文件。</li>
<li><code>-c</code>, <code>--stdout</code>：输出到标准输出。</li>
<li><code>-v</code>, <code>--verbose</code>：显示详细信息。</li>
<li><code>-num</code>, (e.g. -0 到 -9)：设置压缩级别，默认 -6。</li>
<li><code>-l</code>, <code>--list</code>：列出压缩文件信息。</li>
</ul>
<p><strong>使用示例：</strong></p>
<pre><code>xz mydata.log         # 压缩文件，生成 mydata.log.xz
xz -k mydata.log      # 压缩文件并保留原文件
xz -d mydata.log.xz   # 解压缩文件
xzcat mydata.log.xz   # 查看压缩文件内容 (不解压)
xz -l mydata.log.xz   # 列出压缩文件信息 
</code></pre>
<h3>4. <code>tar</code>命令</h3>
<p><code>tar</code>（Tape Archive）是一个归档（打包）工具，本身不进行压缩。它将多个文件和目录组合成一个单一的归档文件（“tarball”），常与 <code>gzip</code>、<code>bzip2</code>、<code>xz</code> 结合使用。</p>
<ul>
<li><strong>功能</strong>： 创建归档文件、从归档中提取文件、列出归档内容。</li>
<li><strong>特点</strong>： 仅打包，可与压缩工具结合。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-c</code>, <code>--create</code>：创建归档。</li>
<li><code>-x</code>, <code>--extract</code>：提取（解包）文件。</li>
<li><code>-t</code>, <code>--list</code>：列出归档内容。</li>
<li><code>-f &lt;archive-file&gt;</code>：指定归档文件名。</li>
<li><code>-v</code>, <code>--verbose</code>：显示详细信息。</li>
<li><code>-z</code>, <code>--gzip</code>：使用 gzip 压缩/解压缩。</li>
<li><code>-j</code>, <code>--bzip2</code>：使用 bzip2 压缩/解压缩。</li>
<li><code>-J</code>, <code>--xz</code>：使用 xz 压缩/解压缩。</li>
<li><code>-C &lt;directory&gt;</code>：提取时，将文件更改到指定目录。</li>
<li><code>-p</code>, 保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件。</li>
<li><code>-P</code>, 保留绝对路径，亦即允许备份数据中含有根目录存在之意。</li>
<li><code>--exclude=FILE</code>, 在压缩的过程中不要将FILE打包。</li>
</ul>
<p><strong>常见组合和使用示例：</strong></p>
<ul>
<li><code>.tar.gz</code>或 <code>.tgz</code>：<code>tar + gzip</code></li>
<li><code>.tar.bz2</code>或<code>.tbz</code>：<code>tar + bzip2</code></li>
<li><code>.tar.xz</code>或 <code>.txz</code>：<code>tar + xz</code></li>
</ul>
<p><strong>使用示例：</strong></p>
<pre><code># 打包并用gzip 压缩
tar -czvf myarchive.tar.gz /path/to/my/directory file1.txt

# 解压缩并解包 .tar.gz 文件
tar -xzvf myarchive.tar.gz

# 解压缩 .tar.gz 文件到指定目录
tar -xzvf myarchive.tar.gz

# 打包并用 bzip2 压缩
tar -cjvf finalarchive.tar.bz2 /path/to/final/data

# 打包并用 xz 压缩
tar -cJvf finalarchive.tar.xz /path/to/final/data

# 简建议-f单独写一个选项 (比较不会忘记)
# 查询
tar -jtv -f filename.tar.bz2

# 备份/etc文件夹
time tar -czvp -f /root/etc.tar.gz /etc # 多了time会显示程序运行的时间
time tar -cjvp -f /root/etc.tar.bz2 /etc
time tar -cJvp -f /root/etc.tar.xz /etc

# 仅解开单一文件的方法
# 先找到我们要找的文件名，假设解开 shadow文件
tar -jtv -f /root/etc.tar.bz2 | grep 'shadow'
tar -jxv -f 打包文件.tar.bz2  待解开文件名
tar -jxv -f  /root/etc.tar.bz2 etc/shadow 

# 打包某目录但不含该目录下的某些文件的做法
tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* \
--exclude=/root/system.tar.bz2 /etc /root

# 仅备份比某个时刻还要新的文件
find /etc -newer /etc/shadow
# 找到一个指定的日期
tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 \
--newer-mtime="2025/06/06" /etc/*

# 标准输入输出流重定向和管道符结合 
# 将/etc整个目录一边打包一边在/tmp解开
cd /tmp
tar -czvf - /etc | tar -xvf -
# 这个操作有点像cp -r /etc /tmp 
</code></pre>
<blockquote>
<p>如果想要两行输入时，最后面加上反斜杠<code>\</code>并立刻按下[Enter]就能够到第二行继续输入了。</p>
</blockquote>
<hr />
<h2>光盘写入工具</h2>
<h3><code>mkisofs</code>、<code>cdrecord</code></h3>
<h3>1. <code>mkisofs</code> 命令</h3>
<p><code>mkisofs</code> (或在新版系统上通常是 <code>genisoimage</code>) 用于从一个目录树创建 ISO 9660 文件系统映像文件。这种映像文件常用于制作 CD/DVD/BD 镜像，以便刻录或在虚拟机中使用。</p>
<ul>
<li><strong>功能：</strong> 将文件和目录打包成 ISO 格式的镜像文件。</li>
<li><strong>适用场景：</strong> 制作可引导光盘镜像、数据光盘镜像、虚拟机安装盘等。</li>
</ul>
<p><strong>基本语法：</strong></p>
<pre><code>mkisofs [选项] -o &lt;输出文件名.iso&gt; &lt;源目录/文件&gt;
</code></pre>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-o &lt;输出文件名.iso&gt;</code>：指定输出的 ISO 镜像文件名。这是最重要的选项，如果没有指定，输出会发送到标准输出。</li>
<li><code>-r, --rock-ridge</code>：生成 Rock Ridge 扩展，保留 UNIX 文件权限、所有者、组、符号链接、长文件名等 POSIX 属性。强烈推荐使用，以便在 Linux/Unix 系统上正确读取。</li>
<li><code>-J, --joliet</code>：生成 Joliet 扩展，支持 Windows 上的长文件名和 Unicode 字符。如果你希望在 Windows 和 Linux 上都能良好兼容，通常会同时使用 -r 和 -J。</li>
<li><code>-V &lt;卷标&gt;, --volid &lt;卷标&gt;</code>：设置 ISO 镜像的卷标 (Volume ID)，即光盘插入系统后显示的名称。</li>
<li><code>-b &lt;引导文件&gt;, --boot-image &lt;引导文件&gt;</code>：指定用于创建可引导光盘的引导镜像文件（通常是 isolinux/isolinux.bin 或 grub/efi.img）。需要配合其他选项使用，如 -c。</li>
<li><code>-c &lt;引导目录/文件&gt;, --boot-info-table &lt;引导目录/文件&gt;</code>：指定引导信息目录或文件，通常与 -b 结合使用，用于生成引导目录。</li>
<li><code>-udf</code>：生成 UDF 文件系统，通常用于 DVD 和蓝光。</li>
<li><code>-m &lt;模式&gt;, --exclude &lt;模式&gt;</code>：排除与指定模式匹配的文件。</li>
<li><code>-x &lt;目录&gt;, --exclude-dir &lt;目录&gt;</code>：排除指定的目录。</li>
</ul>
<p><strong>使用示例：</strong></p>
<ol>
<li>创建最基本的 ISO 镜像：</li>
</ol>
<pre><code>mkdir my_iso_content
echo "Hello world" &gt; my_iso_content/hello.txt
mkdir my_iso_content/subdir
echo "Another file" &gt; my_iso_content/subdir/another.txt

mkisofs -o mydata.iso my_iso_content
</code></pre>
<ol>
<li>创建 Linux/Windows 兼容的 ISO 镜像 (常用)：</li>
</ol>
<pre><code>mkisofs -o my_cross_platform.iso -r -J -V "MyDataDisk" my_iso_content
</code></pre>
<p><code>-r</code> (Rock Ridge) 用于 Linux/Unix 兼容，<code>-J</code>(Joliet) 用于 Windows 兼容，<code>-V</code> 设置卷标。</p>
<h3>2. <code>cdrecord</code> 命令</h3>
<p><code>cdrecord</code> (现在通常是 <code>wodim</code> 或 <code>cdrskin</code> 的符号链接) 是一个用于刻录 CD、DVD、蓝光盘的命令行工具。它通常与 <code>mkisofs</code> 生成的 ISO 镜像配合使用。</p>
<ul>
<li><strong>功能</strong>： 将 ISO 镜像或其他数据刻录到光盘上。</li>
<li><strong>适用场景</strong>： 制作物理光盘、备份数据到光盘、刻录音乐 CD。</li>
</ul>
<p><strong>基本语法：</strong></p>
<pre><code>cdrecord [选项] &lt;要刻录的文件.iso&gt;
</code></pre>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>dev=&lt;scsi_id&gt;|/dev/&lt;device&gt;</code>：指定刻录设备。这是最重要的选项。
<ul>
<li><code>&lt;scsi_id&gt;</code> 格式通常是 bus,target,lun (例如 0,0,0)，可以通过 cdrecord --scanbus 命令查找。</li>
<li><code>/dev/&lt;device&gt;</code> 格式是你的光驱设备文件（例如 /dev/sr0 或 /dev/cdrom）。</li>
</ul>
</li>
<li><code>speed=&lt;速度&gt;</code>：设置刻录速度（例如 <code>speed=4</code>，<code>speed=8</code>，<code>speed=max</code>）。</li>
<li><code>-v</code>, <code>--verbose</code>：显示详细信息，包括刻录进度。</li>
<li><code>blank=&lt;模式&gt;</code>：擦除可擦写光盘（CD-RW/DVD-RW）。
<ul>
<li><code>fast</code>：快速擦除，只擦除介质的引导区。</li>
<li><code>all</code>：完全擦除，擦除整个介质。</li>
</ul>
</li>
<li><code>-dummy</code>：进行一次虚拟刻录（测试刻录），不实际写入数据。用于在真正刻录前检查设置。</li>
<li><code>-eject</code>：刻录完成后弹出光盘。</li>
</ul>
<p><strong>使用示例：</strong></p>
<ol>
<li><strong>查找刻录设备：</strong></li>
</ol>
<pre><code>cdrecord --scanbus
</code></pre>
<ol>
<li><strong>刻录 ISO 镜像到光盘</strong></li>
</ol>
<pre><code>sudo cdrecord dev=/dev/sr0 speed=8 -v my_data.iso
</code></pre>
<ol>
<li><strong>擦除 CD-RW 光盘</strong></li>
</ol>
<pre><code>sudo cdrecord dev=/dev/sr0 blank=fast
</code></pre>
<ol>
<li><strong>测试刻录 (虚拟刻录)：</strong></li>
</ol>
<pre><code>sudo cdrecord dev=/dev/sr0 -dummy my_data.iso
</code></pre>
<h2>其他压缩与备份工具</h2>
<h3><code>dd</code> 命令</h3>
<p><code>dd</code> 命令 (dataset definition) 是一个功能强大的块级数据复制工具。它以字节为单位复制数据，因此可以用于复制整个硬盘、分区、创建镜像文件、制作启动盘等。</p>
<ul>
<li><strong>功能</strong>： 按块复制数据。</li>
<li><strong>适用场景</strong>： 磁盘克隆、分区备份与恢复、制作可引导 USB 驱动器、创建交换文件、安全擦除数据。</li>
</ul>
<p><strong>基本语法：</strong></p>
<pre><code>dd if=&lt;输入文件&gt; of=&lt;输出文件&gt; [选项]
</code></pre>
<p><strong>使用示例：</strong></p>
<ol>
<li><strong>克隆整个硬盘 (数据备份/迁移)：</strong></li>
</ol>
<pre><code>sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress
</code></pre>
<ol>
<li><strong>备份分区到文件：</strong></li>
</ol>
<pre><code>sudo dd if=/dev/sda1 of=/path/to/backup/sda1_backup.img bs=4M status=progress
</code></pre>
<ol>
<li><strong>制作可引导 USB 驱动器 (从 ISO 镜像)：</strong></li>
</ol>
<pre><code>sudo dd if=ubuntu-24.04-desktop-amd64.iso of=/dev/sdX bs=4M status=progress
</code></pre>
<ol>
<li><strong>创建大文件（例如用于交换文件或测试文件）：</strong></li>
</ol>
<pre><code>dd if=/dev/zero of=my_large_flie.img bs=1M count=1024
</code></pre>
<blockquote>
<p><code>dd</code> 是一个<strong>非常强大的命令</strong>，也被称为&lt;font color="red"&gt;&lt;ins&gt;“数据毁灭者”&lt;/ins&gt;&lt;/font&gt;。一个参数的错误就可能导致数据永久丢失。在使用 <code>dd</code> 时，请务必再三确认 <code>if</code> 和 <code>of</code> 参数。</p>
</blockquote>
<h3></h3>
<hr />
<h1>Shell 与 ShellScripts</h1>
<h2>Vi、Vim与程序编辑器</h2>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Linux"></category>
  </entry>
  <entry>
    <title>ssh-keygen generate</title>
    <link href="https://love.nagisadaisuki.icu/posts/ssh_keygen/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/ssh_keygen/</id>
    <published>2025-05-05T00:00:00.000Z</published>
    <updated>2025-05-05T00:00:00.000Z</updated>
    <summary>I have a key and you have a door.This key refers to private key and door are public key.</summary>
    <content type="html"><![CDATA[<h1>🛠️ 一、在本地生成 SSH 密钥对</h1>
<h2>打开终端，输入以下命令</h2>
<pre><code>ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
</code></pre>
<h2>参数说明</h2>
<ul>
<li><code>-t rsa</code>:指定密钥类型为RSA</li>
<li><code>-b 4096</code>:指定密钥长度(4096比较安全)</li>
<li><code>-C</code>:添加注释，可选</li>
</ul>
<h2>然后会提示你保存路径，默认是</h2>
<p><code>/home/your_user/.ssh/id_rsa</code></p>
<p>按回车即可（使用默认路径），然后设置密码（也可以直接回车跳过，无密码）</p>
<h1>📂 二、将公钥复制到服务器</h1>
<h2>方法1：使用<code>ssh-copy-id</code></h2>
<p><code>ssh-copy-id username@server_ip</code>
<code>ssh-copy-id Himari@106.15.58.39</code></p>
<p>它会自动把本地的 ~/.ssh/id_rsa.pub 添加到服务器的 ~/.ssh/authorized_keys 中。</p>
<p>你会被要求输入服务器密码，配置成功后就可以免密登录了。</p>
<h2>方法2：手动复制公钥</h2>
<ol>
<li>查看本地公钥内容</li>
</ol>
<pre><code>cat ~/.ssh/id_rsa.pub
</code></pre>
<ol>
<li>登录远程服务器</li>
</ol>
<pre><code>ssh username@server_ip
</code></pre>
<ol>
<li>在服务器上创建<code>.ssh</code>文件夹(如果没有):</li>
</ol>
<pre><code>mkdir -p ~/.ssh
chmod 700 ~/.ssh
</code></pre>
<ol>
<li>编辑<code>authorized_keys</code>文件，将公钥粘贴进去</li>
</ol>
<pre><code>nvim ~/.ssh/authorized_keys
</code></pre>
<p>粘贴后保存，然后执行</p>
<pre><code>chmod 600 ~/.ssh/authorized_keys
</code></pre>
<h1>🔐 三、测试免密登录</h1>
<h2>退出服务器，然后尝试重新连接</h2>
<pre><code>ssh username@server_ip
</code></pre>
<p>如果一切配置正确，将无需输入密码，自动登录。</p>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="ssh"></category>
  </entry>
  <entry>
    <title>Bat编程中的参数修饰符</title>
    <link href="https://love.nagisadaisuki.icu/posts/bat_parameter_modifiers/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/bat_parameter_modifiers/</id>
    <published>2025-05-04T00:00:00.000Z</published>
    <updated>2025-05-04T00:00:00.000Z</updated>
    <summary>也许是一个比较重要的东西?</summary>
    <content type="html"><![CDATA[<h1>Windows 批处理参数修饰符说明文档</h1>
<h2>📌 什么是参数修饰符？</h2>
<p>参数修饰符用于提取文件路径变量中的特定部分，如文件名、扩展名、路径等。常用于批处理脚本中的 <code>%0</code>, <code>%1</code>, <code>%%F</code> 等参数。</p>
<hr />
<h2>🔧 常见语法格式</h2>
<pre><code>%~修饰符N%
%%~修饰符F%%
</code></pre>
<h2>🧩 参数修饰符一览表</h2>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
<th>示例（输入：<code>C:\Path\file.txt</code>）</th>
<th>输出示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~f</code></td>
<td>全路径（Full Path）</td>
<td><code>%~f1</code></td>
<td><code>C:\Path\file.txt</code></td>
</tr>
<tr>
<td><code>~d</code></td>
<td>驱动器（Drive）</td>
<td><code>%~d1</code></td>
<td><code>C:</code></td>
</tr>
<tr>
<td><code>~p</code></td>
<td>路径（Path）</td>
<td><code>%~p1</code></td>
<td><code>\Path\</code></td>
</tr>
<tr>
<td><code>~n</code></td>
<td>文件名（Name，无扩展）</td>
<td><code>%~n1</code></td>
<td><code>file</code></td>
</tr>
<tr>
<td><code>~x</code></td>
<td>扩展名（eXtension）</td>
<td><code>%~x1</code></td>
<td><code>.txt</code></td>
</tr>
<tr>
<td><code>~s</code></td>
<td>短文件名（8.3 格式）</td>
<td><code>%~s1</code></td>
<td><code>C:\PATH\FILE~1.TXT</code></td>
</tr>
<tr>
<td><code>~a</code></td>
<td>文件属性（Attributes）</td>
<td><code>%~a1</code></td>
<td><code>--a--------</code></td>
</tr>
<tr>
<td><code>~t</code></td>
<td>修改时间（Time）</td>
<td><code>%~t1</code></td>
<td><code>2025/05/02 12:00</code></td>
</tr>
<tr>
<td><code>~z</code></td>
<td>文件大小（siZe）</td>
<td><code>%~z1</code></td>
<td><code>15324</code></td>
</tr>
</tbody>
</table>
<h2>🧩 组合使用示例</h2>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
<th>示例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%~dp1</code></td>
<td>驱动器 + 路径</td>
<td><code>C:\Path\</code></td>
</tr>
<tr>
<td><code>%~nx1</code></td>
<td>文件名 + 扩展名</td>
<td><code>file.txt</code></td>
</tr>
<tr>
<td><code>%~dpnx1</code></td>
<td>驱动器 + 路径 + 文件名 + 扩展名</td>
<td><code>C:\Path\file.txt</code></td>
</tr>
</tbody>
</table>
<h2>📘 实用示例（在 FOR 循环中）</h2>
<pre><code>@echo off
for %%F in (*.txt) do (
    echo 文件路径：%%~fF
    echo 文件名：%%~nF
    echo 扩展名：%%xF
    echo --------    
)
</code></pre>
<h2>🧩 常见修饰符总览（适用于 %%F）</h2>
<table>
<thead>
<tr>
<th>写法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%%~fF</code></td>
<td>全路径（Full path）</td>
</tr>
<tr>
<td><code>%%~dF</code></td>
<td>驱动器盘符</td>
</tr>
<tr>
<td><code>%%~pF</code></td>
<td>路径（不含驱动器）</td>
</tr>
<tr>
<td><code>%%~nF</code></td>
<td>文件名（不含扩展名）</td>
</tr>
<tr>
<td><code>%%~xF</code></td>
<td>扩展名</td>
</tr>
<tr>
<td><code>%%~nxF</code></td>
<td>文件名 + 扩展名</td>
</tr>
<tr>
<td><code>%%~dpF</code></td>
<td>驱动器 + 路径</td>
</tr>
</tbody>
</table>
<h2>🔍 示例脚本</h2>
<pre><code>@echo off
for %%F in (*.txt) do (
    echo 文件完整路径:%%~fF
    echo 文件名(无扩展名):%%~nF
    echo ---------
)
</code></pre>
<p>如果当前目录下有 report.txt 和 log.txt，输出大致如下：</p>
<pre><code>文件完整路径：C:\Test\report.txt
文件名（无扩展名）：report
---------------
文件完整路径：C:\Test\log.txt
文件名（无扩展名）：log
---------------
</code></pre>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Bat"></category>
  </entry>
  <entry>
    <title>Windows Network Troubleshooting CheatSheet</title>
    <link href="https://love.nagisadaisuki.icu/posts/windows_network_troubleshooting_cheatsheet/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/windows_network_troubleshooting_cheatsheet/</id>
    <published>2025-05-04T00:00:00.000Z</published>
    <updated>2025-05-04T00:00:00.000Z</updated>
    <summary>How to find out network problem fast!?</summary>
    <content type="html"><![CDATA[<h1>🛠 Windows 网络排障命令速查合集</h1>
<hr />
<h2>📡 1. <code>ipconfig</code> - 查看和管理 IP 配置</h2>
<pre><code>ipconfig                 :: 查看基本IP配置
ipconfig /all            :: 查看详细配置（MAC、DNS、租约时间）
ipconfig /release        :: 释放当前 IP（DHCP 模式）
ipconfig /renew          :: 重新申请 IP 地址
ipconfig /flushdns       :: 清除 DNS 缓存
ipconfig /displaydns     :: 显示 DNS 缓存
</code></pre>
<hr />
<h2>📶 2. <code>ping</code> - 测试网络连通性和延迟</h2>
<pre><code>ping 8.8.8.8             :: 测试公网连通
ping www.baidu.com       :: 测试域名解析和连通
ping -n 5 192.168.1.1    :: 连续 ping 5 次
ping -t 192.168.1.1      :: 持续 ping（Ctrl+C 停止）
</code></pre>
<hr />
<h2>🌐 3. <code>tracert</code> - 路由追踪（逐跳）</h2>
<pre><code>tracert www.google.com   :: 查看数据包路由路径
tracert /d www.baidu.com :: 不解析域名，加快速度
</code></pre>
<hr />
<h2>🔍 4. <code>nslookup</code> - 域名解析诊断</h2>
<pre><code>nslookup                 :: 进入交互模式
nslookup www.baidu.com   :: 查询域名的 IP
nslookup 8.8.8.8         :: 查询 IP 对应的域名
nslookup -type=mx qq.com :: 查询邮件服务器记录
</code></pre>
<hr />
<h2>📊 5. <code>netstat</code> - 查看网络连接状态</h2>
<pre><code>netstat -a               :: 所有连接和监听端口
netstat -n               :: 不解析域名（显示IP）
netstat -an | find "80"  :: 查找80端口使用情况
netstat -b               :: 查看使用端口的程序（需管理员）
</code></pre>
<hr />
<h2>🛣 6. <code>route</code> - 查看/修改路由表</h2>
<pre><code>route print              :: 显示当前路由表
route add 0.0.0.0 mask 0.0.0.0 192.168.1.1 :: 添加默认路由
route delete 0.0.0.0     :: 删除默认路由
</code></pre>
<hr />
<h2>🧰 7. 其他实用工具</h2>
<table>
<thead>
<tr>
<th>工具/命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tasklist</code></td>
<td>查看所有进程</td>
</tr>
<tr>
<td><code>taskkill /PID 1234 /F</code></td>
<td>强制结束指定进程</td>
</tr>
<tr>
<td><code>arp -a</code></td>
<td>查看本地 ARP 缓存</td>
</tr>
<tr>
<td><code>netsh interface ipv4 show config</code></td>
<td>查看网络接口详细配置</td>
</tr>
<tr>
<td><code>netsh winsock reset</code></td>
<td>重置网络组件（解决异常连接）</td>
</tr>
<tr>
<td><code>net use</code></td>
<td>查看网络驱动器共享</td>
</tr>
<tr>
<td><code>telnet IP port</code></td>
<td>测试端口是否通（需启用 Telnet）</td>
</tr>
</tbody>
</table>
<hr />
<h2>🚨 使用技巧</h2>
<ul>
<li>
<p><strong>建议使用管理员 CMD 执行命令</strong></p>
</li>
<li>
<p><strong>分页查看长输出</strong>：加 <code>| more</code>，如：</p>
<pre><code>netstat -an | more
</code></pre>
</li>
</ul>
<hr />
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Network"></category>
  </entry>
  <entry>
    <title>Advanced Calculus Formulas</title>
    <link href="https://love.nagisadaisuki.icu/posts/advanced_calculus_formula/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/advanced_calculus_formula/</id>
    <published>2025-05-01T00:00:00.000Z</published>
    <updated>2025-05-01T00:00:00.000Z</updated>
    <summary>基本上用不到的数学公式🥲</summary>
    <content type="html"><![CDATA[<h2>一、极限与连续</h2>
<h3>数列极限</h3>
<p>$$
\lim_{n \to \infty} a_n = A
$$</p>
<h3>函数极限</h3>
<p>$$
\lim_{x \to a} f(x) = L
$$</p>
<h3>无穷小与无穷大</h3>
<p>$$
\lim_{x \to 0} x^2 = 0 \quad (\text{无穷小})
$$</p>
<p>$$
\lim_{x \to 0} \frac{1}{x} = \infty \quad (\text{无穷大})
$$</p>
<h3>洛必达法则</h3>
<p>$$
\lim_{x \to a} \frac{f(x)}{g(x)} = \lim_{x \to a} \frac{f'(x)}{g'(x)} \quad \text{（0/0 型或 ∞/∞ 型）}
$$</p>
<hr />
<h2>二、导数与微分</h2>
<h3>导数定义</h3>
<p>$$
f'(x) = \lim_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}
$$</p>
<h3>常见函数导数</h3>
<p>$$
\frac{d}{dx} x^n = nx^{n-1}, \quad \frac{d}{dx} \sin x = \cos x, \quad \frac{d}{dx} e^x = e^x
$$</p>
<h3>微分</h3>
<p>$$
dy = f'(x),dx
$$</p>
<hr />
<h2>三、微分中值定理</h2>
<h3>罗尔定理</h3>
<p>若 $f(a) = f(b)$，则存在 $\xi \in (a, b)$ 使得：
$$
f'(\xi) = 0
$$</p>
<h3>拉格朗日中值定理</h3>
<p>$$
f'(\xi) = \frac{f(b) - f(a)}{b - a}
$$</p>
<h3>柯西中值定理</h3>
<p>$$
\frac{f'(\xi)}{g'(\xi)} = \frac{f(b) - f(a)}{g(b) - g(a)}
$$</p>
<hr />
<h2>四、不定积分</h2>
<h3>基本积分表</h3>
<p>$$
\int x^n , dx = \frac{x^{n+1}}{n+1} + C \quad (n \ne -1)
$$</p>
<p>$$
\int e^x , dx = e^x + C, \quad \int \frac{1}{x} , dx = \ln|x| + C
$$</p>
<hr />
<h2>五、定积分</h2>
<h3>定积分定义</h3>
<p>$$
\int_a^b f(x),dx = \lim_{n \to \infty} \sum_{i=1}^{n} f(x_i^*)\Delta x
$$</p>
<h3>牛顿-莱布尼茨公式</h3>
<p>$$
\int_a^b f(x),dx = F(b) - F(a)
$$</p>
<hr />
<h2>六、积分技巧</h2>
<h3>换元积分法</h3>
<p>若 $x = \varphi(t)$，则：
$$
\int f(x),dx = \int f(\varphi(t)) \varphi'(t),dt
$$</p>
<h3>分部积分法</h3>
<p>$$
\int u,dv = uv - \int v,du
$$</p>
<hr />
<h2>七、曲线积分</h2>
<h3>第一类曲线积分</h3>
<p>$$
\int_L f(x, y), ds
$$</p>
<h3>第二类曲线积分</h3>
<p>$$
\int_L P(x, y),dx + Q(x, y),dy
$$</p>
<hr />
<h2>八、二重积分</h2>
<h3>直角坐标系下</h3>
<p>$$
\iint_D f(x, y), dx,dy
$$</p>
<h3>极坐标下</h3>
<p>$$
\iint_D f(r, \theta), r,dr,d\theta
$$</p>
<hr />
<h2>九、其他重要公式</h2>
<h3>泰勒展开（以 $x = a$ 展开）</h3>
<p>$$
f(x) = f(a) + f'(a)(x - a) + \frac{f''(a)}{2!}(x - a)^2 + \cdots
$$</p>
<h3>麦克劳林展开（$a = 0$）</h3>
<p>$$
\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots
$$</p>
<hr />
<p>以上是高等数学中常见的重要公式，建议配合图形、例题或练习一起使用，帮助记忆和理解。</p>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Math"></category>
  </entry>
  <entry>
    <title>Bat脚本编程笔记</title>
    <link href="https://love.nagisadaisuki.icu/posts/bat_programming/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/bat_programming/</id>
    <published>2025-04-27T00:00:00.000Z</published>
    <updated>2025-04-27T00:00:00.000Z</updated>
    <summary>Bat编程是好文明吗? bat or powershell</summary>
    <content type="html"><![CDATA[<h1>📚 Windows批处理编程实践</h1>
<h2>什么是批处理命令</h2>
<p><strong>Batch file programming</strong>是微软操作系统自带原生的开发语言，不需要构建任何环境就可以执行的脚本。</p>
<p>Batch file批处理使用cmd.exe执行</p>
<h2>如何编辑批处理程序</h2>
<p>使用任何文本编辑器</p>
<h2>批处理程序可以做什么</h2>
<p>使用一系列内置命令进行自动化操作</p>
<blockquote>
<p>例如：匹配规则删除文件</p>
<p>新建文件日志等</p>
<p>甚至可以批量创建计算机病毒</p>
</blockquote>
<h2>一个基本的批处理文件</h2>
<p>输出hello world</p>
<pre><code>@echo off
Echo "hello world"
pause
</code></pre>
<h2>命令分类</h2>
<h3>内部命令</h3>
<p><code>cls</code>,<code>ipconfig</code>等</p>
<h3>外部命令</h3>
<p><code>java</code>和<code>python</code>脚本</p>
<hr />
<hr />
<h2>算数运算</h2>
<p>算数运算符具有优先级，括号<code>()</code>进行分组优先级</p>
<h3>命令模式</h3>
<p><code>set /a 1+2</code> <code>/a</code>和<code>/A</code>都可以，不区分大小写</p>
<h3>文本模式</h3>
<pre><code>@echo off
set /a var = 1 + 2
echo %var% // 声明var变量
pause
</code></pre>
<h2>重定向运算</h2>
<p>四个符号<code>&gt;</code> <code>&gt;&gt;</code> <code>&lt;</code> <code>&lt;&lt;</code></p>
<h2>关系运算</h2>
<p><code>&gt;</code>大于<code>&lt;</code>小于</p>
<blockquote>
<p>type命令可以在终端中显示文件内容(和linux中的cat作用相同)</p>
</blockquote>
<h2>多命令运算符</h2>
<p><code>&amp;&amp;</code>：与，具有短路效果，第一个命令为假不会执行第二个命令
<code>||</code>：或，具有短路效果，第一个命令为假也会执行第二个命令，第一个命令为真不会执行后面的命令</p>
<blockquote>
<p><code>net user</code>命令会显示计算机上的用户</p>
</blockquote>
<h2>管道符号运算</h2>
<p><code>A|B</code>：A命令的输出作为B命令的输入</p>
<pre><code>dir | find ".txt" 找出当前目录下的所有以.txt为后缀的文件
netstat -an
</code></pre>
<blockquote>
<p>linux下只有文件与目录的区别，windows以后缀名区分文件</p>
<p><code>dir</code>命令显示当前目录下的所有文件，<code>netstat</code>是一个常用于查看网络连接、路由表、接口状态等网络相关信息的命令。它在网络故障排查、端口监控、安全检测中非常有用。</p>
</blockquote>
<hr />
<hr />
<h2>批处理基本命令</h2>
<h3>命令格式</h3>
<p><code>命令 子命令 参数 操作 选项</code></p>
<blockquote>
<p><code>/?</code>查看命令帮助信息
例如使用net操作命令</p>
</blockquote>
<pre><code>net /?
net user /?
net user /help 显示完整的帮助信息
NET USER
[username [password | *] [options]] [/DOMAIN]
         username {password | *} /ADD [options] [/DOMAIN]
         username [/DELETE] [/DOMAIN]
         username [/TIMES:{times | ALL}]
         username [/ACTIVE: {YES | NO}]

net user test "password" /add 命令添加用户test
</code></pre>
<h2>批处理文件参数传递</h2>
<p><code>.bat</code>文件接受参数使用<code>%num</code>(和shell编程一样作为占位符接收参数)</p>
<pre><code>net user %1 %2 /add // %1 %2 从外部传入
</code></pre>
<p>参数传递使用空格分隔</p>
<h2>注释符</h2>
<pre><code>rem comment多行注释
:: comment单行注释
</code></pre>
<h2>命令提示符</h2>
<h3>颜色命令</h3>
<p>颜色数学由两个十六进制数字指定，第一个对应于背景，第二个对应于前景。<code>color /?</code>查看具体可选参数</p>
<pre><code>color 0a // 0是背景色,a是前景色 
</code></pre>
<h3>标题命令</h3>
<p>改变终端标题</p>
<pre><code>title "title"
</code></pre>
<h3>时间相关命令</h3>
<p><code>date</code>和<code>time</code></p>
<p><code>date /T</code>和<code>time /T</code>能获取更纯粹的时间内容
<code>date /t  &amp;&amp; time /t</code>将日期和时间一起显示</p>
<h3>启动命令</h3>
<p><code>start</code>命令</p>
<pre><code>start /? 查看帮助手册
start "title" "relative path" // title 表示打开终端的标题 "relative path" 表示打开程序路径
</code></pre>
<h3>使用其他bat文件</h3>
<p><code>call</code>命令(类似函数文件调用)</p>
<pre><code>1.bat
echo %1 
echo %2
call 2.bat %1 %2
</code></pre>
<h2>任务列表查看</h2>
<p><code>tasklist</code>命令</p>
<pre><code>tasklist /S （远程ip） /U administrator （以管理员身份登录）/P password （密码）
查看远程计算机的tasklist

tasklist /FI "STATUS eq UNKNOWN"
查看tasklist中状态属于unknown的进程

tasklist /FI "PID EQ 12352"
查看tasklist中PID为12352的进程

tasklist /FI "PID EQ 12352" /FO table
默认输出的table模式

tasklist /FI "PID EQ 12352" /FO csv
输出csv格式

tasklist /FI "PID EQ 12352" /FO csv &gt; task.csv
将csv格式的内容重定向到task.csv文件中
</code></pre>
<h2>任务终止命令</h2>
<p><code>taskkill</code></p>
<pre><code>taskkill /IM notepad.exe 根据印象名称关闭程序
taskkill /PID 1230 /PID 2321 /T 根据pid关闭进程与子进程
taskkill /F /IM cmd.exe /T 根据印象名称关闭进程与子进程
</code></pre>
<h2>文件夹结构查看命令</h2>
<p><code>tree</code> <code>/A</code> <code>/F</code></p>
<blockquote>
<p>/A以ascii字符显示文件结构而不是扩展字符</p>
<p>/F显示每个文件夹中文件的名称</p>
</blockquote>
<h2>关机命令</h2>
<p><code>shutdown</code></p>
<ul>
<li><code>shutdown /i</code>图形化显示关机操作界面</li>
<li><code>shutdown /l</code>注销计算机</li>
<li><code>shutdown /s</code> 关闭计算机</li>
<li><code>shutdown /t</code>定时</li>
</ul>
<h2>计划任务命令</h2>
<p><code>schtasks</code></p>
<h3>🧭 常用格式</h3>
<pre><code>schtasks /&lt;操作&gt; [参数]
</code></pre>
<h3>🔧 常用操作命令</h3>
<h4>📅 创建任务</h4>
<pre><code>schtasks /create /tn "任务名" /tr "程序路径" /sc once /st 14:00
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>/tn</code>：任务名称(Task Name)</li>
<li><code>/tr</code>：任务运行的程序或脚本(Task Run)</li>
<li><code>/sc</code>：计划频率(Schedule: once,daily,monthly,onstart,onlogon等)</li>
<li><code>/st</code>：开始时间(Start Time，格式：HH:MM)</li>
</ul>
<p><strong>例子：每天早上8点运行脚本</strong></p>
<pre><code>schtasks /create /tn "BackupScript" /tr "C:\scripts\backup.bat" /sc daily /st 08:00
</code></pre>
<h4>📜 查询任务列表</h4>
<pre><code>schtasks /query
</code></pre>
<p><strong>带详细信息：</strong></p>
<pre><code>schtasks /query /v /fo list
</code></pre>
<ul>
<li><code>/v</code>：详细模式(Verbose)</li>
<li><code>/fo</code>：输出格式(Format：table、list、csv)</li>
</ul>
<h4>❌ 删除任务</h4>
<pre><code>schtasks /delete /tn "任务名" /f
</code></pre>
<h4>📝 修改任务</h4>
<pre><code>schtasks /change /tn "任务名" /enable
</code></pre>
<p>也可以用来更改运行用户、禁用任务等。</p>
<h4>▶️ 运行一次任务（手动触发）</h4>
<pre><code>schtasks /run /tn "任务名"
</code></pre>
<h4>⏹️ 停止正在运行的任务</h4>
<pre><code>schtasks /end /tn "任务名"
</code></pre>
<h3>💡 提示</h3>
<ul>
<li>如果任务需要管理员权限运行，建议在创建时指定用户：</li>
</ul>
<pre><code>schtasks /create /tn "MyTask" /tr "C:\myapp.exe" /sc once /st 12:00 /ru "SYSTEM"
</code></pre>
<h2>调用命令</h2>
<p><code>call</code></p>
<h3>📌 基本用法</h3>
<h4>1️⃣ 调用另一个批处理脚本</h4>
<pre><code>call other_script.bat
</code></pre>
<ul>
<li>不使用 <code>call</code>，主脚本会在运行 <code>other_script.bat</code> 后不会返回。</li>
<li>使用 <code>call</code>，则执行完 <code>other_script.bat</code> 后会继续执行主脚本。</li>
</ul>
<h4>2️⃣ 调用并传递参数</h4>
<pre><code>call other_script.bat arg1 arg2
</code></pre>
<p>在<code>other_script.bat</code>中可以用<code>%1</code>,<code>%2</code>来接收参数。</p>
<h4>3️⃣ 调用子程序（同一个脚本内部）</h4>
<pre><code>call :label_name
</code></pre>
<pre><code>@echo off
echo 主脚本开始
call :myFunction
echo 主脚本结束
exit /b

:myFunction
echo 我是子程序
exit /b
</code></pre>
<ul>
<li><code>:label_name</code> 是一个脚本内的子程序标签</li>
<li><code>exit /b</code>用于从子程序返回（不是结束整个脚本）</li>
</ul>
<h4>🔁 常见场景</h4>
<ol>
<li>调用多个批处理文件，按顺序执行</li>
<li>在脚本中使用函数/模块化结构</li>
<li>根据条件选择性地调用不同子程序</li>
</ol>
<h2>批处理环境变量</h2>
<p><code>set</code></p>
<h3>📌 基本用法</h3>
<h2>目录浏览命令dir</h2>
<h3>📌 基本用法</h3>
<h4>🔑 查看所有信息（包括隐藏目录文件）</h4>
<p><code>dir /a</code></p>
<h4>🗝 以小写形式输出</h4>
<p><code>dir /l</code></p>
<h3>目录重命名命令</h3>
<p><code>ren</code>,<code>rename</code></p>
<h3>目录拷贝命令</h3>
<p><code>copy</code>,<code>cp</code></p>
<h3>文件删除命令</h3>
<p><code>del</code>,<code>delete</code></p>
<h3>文件剪切命令</h3>
<p><code>move</code>,<code>mv</code></p>
<h2>网络相关命令</h2>
<ol>
<li><code>net user</code>用户操作命令</li>
</ol>
<ul>
<li>删除用户指令</li>
</ul>
<pre><code>net user username /delete
</code></pre>
<ul>
<li>添加用户指令</li>
</ul>
<pre><code>net user username (password | *) /add
</code></pre>
<ol>
<li><code>net localgroup</code>用户组操作命令</li>
</ol>
<ul>
<li>向本地管理组添加用户</li>
</ul>
<pre><code>net localgroup administrators himari /add
</code></pre>
<ul>
<li>删除指定本地管理组用户</li>
</ul>
<pre><code>net localgroup users himari /delete
</code></pre>
<ol>
<li>主机连通性命令<code>ping</code>指定的主机，直到停止</li>
</ol>
<ul>
<li>设置发送缓冲区大小</li>
</ul>
<pre><code>ping -l 65500 127.0.0.1
</code></pre>
<ul>
<li>ping指定主机直到停止</li>
</ul>
<pre><code>ping -l 444 -t 127.0.0.1
</code></pre>
<ol>
<li>网络连接命令<code>telnet</code></li>
</ol>
<blockquote>
<p>win10默认关闭，要去控制面板中的<strong>程序</strong>--&gt;<strong>程序和功能</strong>--&gt;<strong>启动或关闭windows功能打开</strong></p>
</blockquote>
<ol>
<li>网络路由信息查看命令<code>tracert</code></li>
</ol>
<h3>🧭 tracert 命令（Windows）</h3>
<h4>📌 用途</h4>
<p>查看 <strong>数据包从你本地出发，一跳一跳经过的网络节点</strong>，直到目标地址。</p>
<p>可以用来：</p>
<ul>
<li>排查网络延迟</li>
<li>判断哪一段网络不通</li>
<li>分析出站路径</li>
</ul>
<h4>✅ 基本语法</h4>
<pre><code>tracert [选项] 目标地址
</code></pre>
<pre><code>tracert 192.168.0.1 对本地路由进行跟踪
tracert www.baidu.com 对百度网址进行跟踪
</code></pre>
<ol>
<li>网络适配器命令<code>ipconfig</code></li>
</ol>
<p><code>ipconfig</code>是 Windows 系统中用来查看和管理本机网络配置信息的超常用命令之一。</p>
<h3>🧭 ipconfig 命令作用</h3>
<p>主要用于查看本机：</p>
<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>默认网关</li>
<li>DNS配置</li>
<li>当前网络状态</li>
</ul>
<h3>✅ 常用命令大全</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ipconfig</code></td>
<td>查看简要 IP 配置信息</td>
</tr>
<tr>
<td><code>ipconfig /all</code></td>
<td>查看详细配置信息（包括物理地址、DNS等）</td>
</tr>
<tr>
<td><s>ipconfig /release</s></td>
<td>释放当前IP(DHCP模式下)</td>
</tr>
<tr>
<td><code>ipconfig /renew</code></td>
<td>重新申请IP(DHCP模式下)</td>
</tr>
<tr>
<td><code>ipconfig /flushdns</code></td>
<td>清除DNS缓存</td>
</tr>
<tr>
<td><code>ipconfig /displaydns</code></td>
<td>显示DNS缓存</td>
</tr>
<tr>
<td><code>ipconfig /registrdns</code></td>
<td>刷新DHCP租约并重新注册DNS</td>
</tr>
</tbody>
</table>
<ol>
<li><code>ARP</code>信息命令</li>
</ol>
<h3>📡 arp 命令详解（Windows）</h3>
<h4>🎯 用途</h4>
<p>查看或修改本地ARP缓存表，用于<strong>IP&lt;--&gt;MAC地址映射的管理与排错</strong></p>
<h3>🧾 常用命令速查表</h3>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arp -a</code></td>
<td>显示本地ARP缓存表(IP&lt;--&gt;MAC映射)</td>
</tr>
<tr>
<td><code>arp -a 192.168.1.1</code></td>
<td>查看指定接口的 ARP 缓存</td>
</tr>
<tr>
<td><code>arp -d IP地址</code></td>
<td>删除特定 IP 的 ARP 缓存记录</td>
</tr>
<tr>
<td>arp -s IP地址 MAC地址</td>
<td>添加静态 ARP 映射（不会随系统重启保留）</td>
</tr>
</tbody>
</table>
<h3>📌 注意事项</h3>
<ul>
<li><code>arp</code> 只作用于本地的 IP/MAC 映射缓存。</li>
<li>ARP 表仅包含最近通信过的设备，<strong>不是扫描整个局域网的工具</strong>。</li>
</ul>
<h2>条件判断结构</h2>
<h3>😎 if-else结构</h3>
<h4>✅ 基本语法</h4>
<pre><code>if 条件(
    命令1
) else (
    命令2
)
</code></pre>
<h3>🔍 示例：判断文件是否存在</h3>
<pre><code>@echo off
if exist "C:\test.txt"(
    echo 文件存在！
) else (
    echo 文件不存在。
)
pause&gt;nul
</code></pre>
<h3>🧠 for 循环结构</h3>
<h4>✅ 遍历文件夹中的所有文件</h4>
<pre><code>@echo off
for %%f in (*.txt) do (
    echo 找到文件: %%f
)
pause&gt;nul
</code></pre>
<blockquote>
<p>⚠ 注意：在 .bat 脚本中用 <strong>%%变量</strong>，而在命令行窗口直接输入时只用一个 <strong>%变量</strong>。</p>
</blockquote>
<h4>😚 遍历目录(文件夹)</h4>
<pre><code>@echo off
for /d %%a in (*) do echo %%a
pause
</code></pre>
<h4>🔄 遍历文件夹中的所有子目录和文件（递归）(recursion)</h4>
<pre><code>for /r "C:\MyFolder" %%f in (*.jpg) do (
    echo 发现图片：%%f
)
pause
</code></pre>
<h4>🧪 遍历一个列表</h4>
<pre><code>@echo off
for %%i in (苹果 香蕉 西瓜) do (
    echo 水果：%%i
pause
</code></pre>
<pre><code>@echo off
rem for 遍历数字 /l
for /l %%i in (1,1,20) do ping %1.%%i
pause
</code></pre>
<h4>🧠 if 与 for 嵌套使用（判断文件是否包含关键字）</h4>
<pre><code>@echo off
for %%f in (*.txt) do (
    findstr "关键字" %%f &gt;nul
    if errorlevel 1(
        echo 没找到：%%f
    ) else (
        echo 找到关键字于：%%f
    )
)
pause
</code></pre>
<h4>逐行读取文件内容</h4>
<pre><code>@echo off
rem for test
for /f %%i in (for.cmd) do echo %%i
</code></pre>
<h4>🔥 常用增强参数</h4>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for /r</code></td>
<td>递归子目录</td>
</tr>
<tr>
<td><code>for /f</code></td>
<td>逐行读取文件内容</td>
</tr>
<tr>
<td><code>for /d</code></td>
<td>遍历目录</td>
</tr>
<tr>
<td><code>if exist</code></td>
<td>判断文件或目录存在</td>
</tr>
<tr>
<td><code>if "%var%"==""</code></td>
<td>判断变量是否为空</td>
</tr>
<tr>
<td><code>if not defined VAR</code></td>
<td>判断变量未定义</td>
</tr>
</tbody>
</table>
<h3>✅ 命名习惯（但不是语法限制）</h3>
<table>
<thead>
<tr>
<th><strong>变量名</strong></th>
<th><strong>通常用途</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%%i</code></td>
<td>通用索引(index)</td>
<td><code>for %%i in (...) do</code></td>
</tr>
<tr>
<td><code>%%f</code></td>
<td>文件(file)相关循环</td>
<td><code>for %%f in (*.txt) do</code></td>
</tr>
<tr>
<td><code>%%d</code></td>
<td>目录(dir)相关</td>
<td><code>for /d %%d in (*) do</code></td>
</tr>
</tbody>
</table>
<h2>goto命令</h2>
<h3>✅ 基本语法</h3>
<p><code>goto 标签名</code></p>
<pre><code>:标签名
rem 在这里执行跳转后的代码
</code></pre>
<h3>🧩 示例：if 判断 + goto 跳转</h3>
<pre><code>@echo off
set /p answer=是否继续?(y/n):

if /i "%answer%"=="y" goto continue
if /i "%answer%"=="n" goto exit
:continue
echo 你选择了继续
goto end

:exit
echo 已退出程序

:end
pause&gt;nul
</code></pre>
<h3>♻ 示例：goto 构造简单循环</h3>
<pre><code>@echo off
set /a count=0

:loop
set /a count+=1
echo 当前计数：%count%

if %count% lss 5 goto loop
echo 循环结束
pause
</code></pre>
<h2>set命令</h2>
<p><code>set</code> 是 Windows 批处理脚本中最基础、最常用的命令之一，用于定义、读取和修改变量。</p>
<h3>🧩 基本语法</h3>
<p><code>set 变量名=值</code></p>
<h3>✅ 示例</h3>
<pre><code>set name=张三
echo 你好，%name%
</code></pre>
<h3>🔢 示例：数学运算</h3>
<pre><code>@echo off
set /a a=5
set /a b=3
set /a sum=a+b
echo 和是：%sum%
</code></pre>
<h3>⌨ 示例：用户输入</h3>
<pre><code>@echo off
set /p name=请输入你的名字：
echo 你好，%name%
</code></pre>
<h3>🔁 示例：循环中使用变量（延迟扩展）</h3>
<pre><code>@echo off
setlocal enabledelayedexpansion
for /l %%i in (1,1,5) do (
    set /a val=%%i*2
    echo 第%%i项:!val!
)
</code></pre>
<blockquote>
<p>🚨 注意：循环中需要用 <strong>!变量名!</strong> 而不是 <s>%变量名%</s>，并配合 <code>setlocal enabledelayedexpansion</code></p>
</blockquote>
<h3>🧽 示例：清空变量</h3>
<p><code>set var=</code></p>
<h3>💡 高级技巧</h3>
<ul>
<li><code>set "var=value"</code>（推荐写法，防止空格问题）</li>
<li><code>set /a i+=1</code>支持累加减法等</li>
<li><code>set /p</code>可用于制作简易菜单输入</li>
</ul>
<h2>💡 什么是延迟扩展（Delayed Variable Expansion）</h2>
<blockquote>
<p>延迟扩展 = <strong>让变量在运行到那一行时才获取值</strong>，而不是在脚本解析阶段就确定值。</p>
</blockquote>
<h3>📌 默认行为（非延迟）</h3>
<p>批处理在执行 <strong>for/if</strong> 结构前，会先整体解析整段语句中的 %变量% —— 也就是说 “提前确定值”！</p>
<p>这就导致：你在 <strong>for</strong> 循环中改变了变量，但 %变量% 仍然是旧值。</p>
<h3>🧨 问题例子（没开启延迟扩展）</h3>
<pre><code>@echo off
set count=0
for /l %%i in (1,1,3) do (
    set /a count+=1
    echo 循环中：%count%
)
</code></pre>
<h3>💥 输出是</h3>
<pre><code>循环中：0
循环中：0
循环中：0
</code></pre>
<h3>✅ 正确写法：开启延迟扩展</h3>
<pre><code>@echo off
setlocal enabledelayedexpansion
set count=0
for /l %%i in (1,1,3) do (
    set /a count+=1
    echo 循环中：!count!
)
</code></pre>
<h2>at命令</h2>
<p><code>at</code> 命令是 Windows（尤其是早期版本）中的一个计划任务命令，用于在指定时间运行程序或命令。它已经被较新的 <code>schtasks</code> 命令取代，但在某些系统上仍然可用。</p>
<h3>🧭 基本格式</h3>
<pre><code>at [时间] [命令]
</code></pre>
<p>时间格式通常是<strong>24小时制</strong>，如 <code>14:30</code></p>
<h3>✅ 示例用法</h3>
<ol>
<li>在下午2点30分执行一个程序：
<code>at 14:30 "notepad.exe"</code></li>
<li>执行一个批处理脚本：
<code>at 18:00 xxx.bat</code></li>
<li>查看当前已排的任务：
<code>at</code></li>
<li>删除任务：
<code>at [任务ID] /delete</code></li>
</ol>
<h3>⚠️ 注意事项</h3>
<table>
<thead>
<tr>
<th><strong>限制/说明</strong></th>
<th><strong>详情</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 管理员权限</td>
<td>需要以 <strong>管理员身份运行命令提示符</strong> 才能使用 <code>at</code></td>
</tr>
<tr>
<td>❌ 不支持日期计划</td>
<td>只能设置“<strong>今天</strong>几点执行”，不支持设置“哪天”</td>
</tr>
<tr>
<td>❌ 在 Win10 后被废弃</td>
<td>Windows 8/10/11 推荐使用 schtasks 命令</td>
</tr>
<tr>
<td>❌ 无法持久保存</td>
<td>重启后计划任务通常会丢失（默认行为）</td>
</tr>
</tbody>
</table>
<h3>🆕 推荐替代：schtasks</h3>
<pre><code>schtasks /create /tn "OpenNotepad" /tr "notepad.exe" /sc once /st 14:30
</code></pre>
<h2>find命令和findstr命令</h2>
<ul>
<li><code>find</code>命令查找的是纯文本字符串</li>
</ul>
<pre><code>find "hello" myfile.txt
// 查找文本中包含hello的行，不能使用正则表达式
/i 忽略大小写
/c 统计匹配的行数
/v 查找不包含某字符串的行
</code></pre>
<ul>
<li><code>findstr</code>功能更强可以用简单正则</li>
</ul>
<pre><code>findstr /R "^A.*Z$" myfile.txt
// 查找以A开头以Z结尾的行
/s 递归子目录
/i 忽略大小写
/r 正则模式
/c:"exact phrase"查找精确短语
</code></pre>
<h1>✅ 示例：模糊查找并杀掉进程名中包含 chrome 的程序</h1>
<pre><code>for /f "tokens=2 delims= " %%i in ('tasklist ^| findstr /i chrome') do taskkill /pid %%i /f 
</code></pre>
<ul>
<li><code>/f</code>：逐行读取文件内容</li>
<li><code>tokens=2 delims=</code>：取第二行，按空格分割</li>
<li><code>%%i</code>和<code>%i</code>为在bat文件内运行和cmd终端运行</li>
<li><code>('tasklist ^| findstr /i chrome')</code>：这里使用<code>''</code>和<code>^|</code>转义符是为了防止<code>for</code>命令将前后分为两个语句</li>
<li><code>taskkill /pid %%i /f</code>：将指定的进程名程序杀死</li>
</ul>
<h2>🧩 扩展用法（高级）</h2>
<h3>▶ 只杀掉特定用户下的进程</h3>
<pre><code>tasklist /v | findstr /i "chrome myusername"
</code></pre>
<h3>▶ 匹配多个关键词</h3>
<pre><code>tasklist | findstr /i "chrome firefox"
</code></pre>
<h3>▶ 过滤多个字段（通过正则）</h3>
<pre><code>tasklist | findstr /r /i "notepad.*Console"
</code></pre>
<h1>✅ for 循环常用语法和选项</h1>
<h2>🧩 常用结构一：遍历文件列表</h2>
<pre><code>for %%f in (*.txt) do echo %%f
</code></pre>
<h2>🧩 常用结构二：读取文件内容（逐行处理）</h2>
<pre><code>for /f "tokens=1,2 delims= " %%a in (data.csv) do echo 第一列=%%a 第二列=%%b
</code></pre>
<h2>🧩 常用结构三：命令输出处理</h2>
<pre><code>for /f "usebackq tokens=*" %%i in ('tasklist ^| findstr notepad') do echo %%i
</code></pre>
<ul>
<li><code>usebackq</code>：让命令用反引号包围</li>
<li><code>tokens=*</code>：整行提取(防止空格截断)</li>
</ul>
<h2>🔧 for 参数说明</h2>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/f</code></td>
<td>从文本文件或命令输出中逐行读取</td>
</tr>
<tr>
<td><code>/r</code></td>
<td>递归遍历目录</td>
</tr>
<tr>
<td><code>/d</code></td>
<td>仅匹配目录名</td>
</tr>
<tr>
<td><code>tokens=n</code></td>
<td>指定取第几列(n可以是多个)</td>
</tr>
<tr>
<td><code>delims=x</code></td>
<td>指定分隔符(默认为空格和制表符)</td>
</tr>
<tr>
<td><code>usebackq</code></td>
<td>使用反引号执行命令/支持文件路径含空格</td>
</tr>
</tbody>
</table>
<h1>✅ if 语句常用结构</h1>
<h2>🧩 结构一：字符串比较</h2>
<pre><code>if "%var%"=="hello" echo 是hello
</code></pre>
<h2>🧩 结构二：数字比较</h2>
<pre><code>if %num% GEQ 100 echo 大于等于100
</code></pre>
<table>
<thead>
<tr>
<th><strong>比较符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>等于(字符串)</td>
</tr>
<tr>
<td><code>NEQ</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>LSS</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>LEQ</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>GTR</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>GEQ</code></td>
<td>大于等于</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚠ 注意：数字比较时变量不能加引号。</p>
</blockquote>
<h2>🧩 结构三：文件/目录判断</h2>
<pre><code>if exist myfile.txt echo 文件存在
if not exist myfolder\NUL echo 文件夹不存在
</code></pre>
<p>🧩 结构四：带括号的多语句判断（推荐）</p>
<pre><code>if "%var%"=="yes" (
    echo 用户确认
    echo 正在继续
) else (
    echo 用户取消
)
</code></pre>
<h1>📝 练习1：遍历所有 .log 文件，并显示文件名和行数</h1>
<pre><code>for %%f in (*.log) do (]
    echo 文件：%%f
    find /c /v "" "%%f"
)
</code></pre>
<h2>✅ 各部分含义</h2>
<table>
<thead>
<tr>
<th><strong>部分</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find</code></td>
<td>Windows的文本查找命令</td>
</tr>
<tr>
<td><code>/c</code></td>
<td>只显示匹配行的数量</td>
</tr>
<tr>
<td><code>/v ""</code></td>
<td>匹配所有"<strong>不包含空字符串</strong>"的行-&gt;相当于"所有行"</td>
</tr>
<tr>
<td><code>%%f</code></td>
<td>要处理的文件名(在<code>for</code>循环中)</td>
</tr>
</tbody>
</table>
<h1>📝 练习3：用 tasklist 和 if 判断某进程是否存在</h1>
<pre><code>tasklist | findstr /i notepad &gt;nul
if errorlevel 1 (
    echo Notepad 没有运行
) else (
    echo Notepad 正在运行
)
</code></pre>
<h1>✨字符串截取语法</h1>
<h2>✅ 通用语法</h2>
<pre><code>%变量名:~起始位置,长度%
</code></pre>
<ul>
<li><em>起始位置</em>：从0开始</li>
<li><em>长度</em>：截取的字符数(可以省略，表示到结尾)</li>
</ul>
<h2>✅ 举例说明</h2>
<h3>📆 示例1：处理 %date%</h3>
<p>假设 <em>%date% = 2025/04/29</em></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>结果</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%date:~0,4%</code></td>
<td><code>2025</code></td>
<td>年</td>
</tr>
<tr>
<td><code>%date:~5,2%</code></td>
<td><code>04</code></td>
<td>月</td>
</tr>
<tr>
<td><code>%date:~8,2%</code></td>
<td><code>29</code></td>
<td>日</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="bat"></category>
  </entry>
  <entry>
    <title>Markdown Extended Features</title>
    <link href="https://love.nagisadaisuki.icu/posts/markdown-extended/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/markdown-extended/</id>
    <published>2024-05-01T00:00:00.000Z</published>
    <updated>2024-11-29T00:00:00.000Z</updated>
    <summary>Read more about Markdown features in Mizuki</summary>
    <content type="html"><![CDATA[<h2>GitHub Repository Cards</h2>
<p>You can add dynamic cards that link to GitHub repositories, on page load, the repository information is pulled from the GitHub API.</p>
<p>::github{repo="matsuzaka-yuki/Mizuki"}</p>
<p>Create a GitHub repository card with the code <code>::github{repo="matsuzaka-yuki/Mizuki"}</code>.</p>
<pre><code>::github{repo="matsuzaka-yuki/Mizuki"}
</code></pre>
<h2>Admonitions</h2>
<p>Following types of admonitions are supported: <code>note</code> <code>tip</code> <code>important</code> <code>warning</code> <code>caution</code></p>
<p>:::note
Highlights information that users should take into account, even when skimming.
:::</p>
<p>:::tip
Optional information to help a user be more successful.
:::</p>
<p>:::important
Crucial information necessary for users to succeed.
:::</p>
<p>:::warning
Critical content demanding immediate user attention due to potential risks.
:::</p>
<p>:::caution
Negative potential consequences of an action.
:::</p>
<h3>Basic Syntax</h3>
<pre><code>:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
</code></pre>
<h3>Custom Titles</h3>
<p>The title of the admonition can be customized.</p>
<p>:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::</p>
<pre><code>:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
</code></pre>
<h3>GitHub Syntax</h3>
<blockquote>
<p>[!TIP]
<a href="https://github.com/orgs/community/discussions/16925">The GitHub syntax</a> is also supported.</p>
</blockquote>
<pre><code>&gt; [!NOTE]
&gt; The GitHub syntax is also supported.

&gt; [!TIP]
&gt; The GitHub syntax is also supported.
</code></pre>
<h3>Spoiler</h3>
<p>You can add spoilers to your text. The text also supports <strong>Markdown</strong> syntax.</p>
<p>The content :spoiler[is hidden <strong>ayyy</strong>]!</p>
<pre><code>The content :spoiler[is hidden **ayyy**]!</code></pre>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Examples"></category>
  </entry>
  <entry>
    <title>Simple Guides for Mizuki</title>
    <link href="https://love.nagisadaisuki.icu/posts/guide/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/guide/</id>
    <published>2024-04-01T00:00:00.000Z</published>
    <updated>2024-04-01T00:00:00.000Z</updated>
    <summary>How to use this blog template.</summary>
    <content type="html"><![CDATA[<p>This blog template is built with <a href="https://astro.build/">Astro</a>. For the things that are not mentioned in this guide, you may find the answers in the <a href="https://docs.astro.build/">Astro Docs</a>.</p>
<h2>Front-matter of Posts</h2>
<pre><code>---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>The title of the post.</td>
</tr>
<tr>
<td><code>published</code></td>
<td>The date the post was published.</td>
</tr>
<tr>
<td><code>pinned</code></td>
<td>Whether this post is pinned to the top of the post list.</td>
</tr>
<tr>
<td><code>description</code></td>
<td>A short description of the post. Displayed on index page.</td>
</tr>
<tr>
<td><code>image</code></td>
<td>The cover image path of the post.&lt;br/&gt;1. Start with <code>http://</code> or <code>https://</code>: Use web image&lt;br/&gt;2. Start with <code>/</code>: For image in <code>public</code> dir&lt;br/&gt;3. With none of the prefixes: Relative to the markdown file</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>The tags of the post.</td>
</tr>
<tr>
<td><code>category</code></td>
<td>The category of the post.</td>
</tr>
<tr>
<td><code>licenseName</code></td>
<td>The license name for the post content.</td>
</tr>
<tr>
<td><code>author</code></td>
<td>The author of the post.</td>
</tr>
<tr>
<td><code>sourceLink</code></td>
<td>The source link or reference for the post content.</td>
</tr>
<tr>
<td><code>draft</code></td>
<td>If this post is still a draft, which won't be displayed.</td>
</tr>
</tbody>
</table>
<h2>Where to Place the Post Files</h2>
<p>Your post files should be placed in <code>src/content/posts/</code> directory. You can also create sub-directories to better organize your posts and assets.</p>
<pre><code>src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
</code></pre>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Guides"></category>
  </entry>
  <entry>
    <title>Markdown Mermaid</title>
    <link href="https://love.nagisadaisuki.icu/posts/markdown-mermaid/" rel="alternate" type="text/html"/>
    <id>https://love.nagisadaisuki.icu/posts/markdown-mermaid/</id>
    <published>2023-10-01T00:00:00.000Z</published>
    <updated>2023-10-01T00:00:00.000Z</updated>
    <summary>A simple example of a Markdown blog post with Mermaid.</summary>
    <content type="html"><![CDATA[<h1>Complete Guide to Markdown with Mermaid Diagrams</h1>
<p>This article demonstrates how to create various complex diagrams using Mermaid in Markdown documents, including flowcharts, sequence diagrams, Gantt charts, class diagrams, and state diagrams.</p>
<h2>Flowchart Example</h2>
<p>Flowcharts are excellent for representing processes or algorithm steps.</p>
<pre><code>graph TD
    A[Start] --&gt; B{Condition Check}
    B --&gt;|Yes| C[Process Step 1]
    B --&gt;|No| D[Process Step 2]
    C --&gt; E[Subprocess]
    D --&gt; E
    subgraph E [Subprocess Details]
        E1[Substep 1] --&gt; E2[Substep 2]
        E2 --&gt; E3[Substep 3]
    end
    E --&gt; F{Another Decision}
    F --&gt;|Option 1| G[Result 1]
    F --&gt;|Option 2| H[Result 2]
    F --&gt;|Option 3| I[Result 3]
    G --&gt; J[End]
    H --&gt; J
    I --&gt; J
</code></pre>
<h2>Sequence Diagram Example</h2>
<p>Sequence diagrams show interactions between objects over time.</p>
<pre><code>sequenceDiagram
    participant User
    participant WebApp
    participant Server
    participant Database

    User-&gt;&gt;WebApp: Submit Login Request
    WebApp-&gt;&gt;Server: Send Auth Request
    Server-&gt;&gt;Database: Query User Credentials
    Database--&gt;&gt;Server: Return User Data
    Server--&gt;&gt;WebApp: Return Auth Result
    
    alt Auth Successful
        WebApp-&gt;&gt;User: Show Welcome Page
        WebApp-&gt;&gt;Server: Request User Data
        Server-&gt;&gt;Database: Get User Preferences
        Database--&gt;&gt;Server: Return Preferences
        Server--&gt;&gt;WebApp: Return User Data
        WebApp-&gt;&gt;User: Load Personalized Interface
    else Auth Failed
        WebApp-&gt;&gt;User: Show Error Message
        WebApp-&gt;&gt;User: Prompt Re-entry
    end
</code></pre>
<h2>Gantt Chart Example</h2>
<p>Gantt charts are perfect for displaying project schedules and timelines.</p>
<pre><code>gantt
    title Website Development Project Timeline
    dateFormat  YYYY-MM-DD
    axisFormat  %m/%d
    
    section Design Phase
    Requirements Analysis      :a1, 2023-10-01, 7d
    UI Design                 :a2, after a1, 10d
    Prototype Creation        :a3, after a2, 5d
    
    section Development Phase
    Frontend Development      :b1, 2023-10-20, 15d
    Backend Development       :b2, after a2, 18d
    Database Design           :b3, after a1, 12d
    
    section Testing Phase
    Unit Testing              :c1, after b1, 8d
    Integration Testing       :c2, after b2, 10d
    User Acceptance Testing   :c3, after c2, 7d
    
    section Deployment
    Production Deployment     :d1, after c3, 3d
    Launch                    :milestone, after d1, 0d
</code></pre>
<h2>Class Diagram Example</h2>
<p>Class diagrams show the static structure of a system, including classes, attributes, methods, and their relationships.</p>
<pre><code>classDiagram
    class User {
        +String username
        +String password
        +String email
        +Boolean active
        +login()
        +logout()
        +updateProfile()
    }
    
    class Article {
        +String title
        +String content
        +Date publishDate
        +Boolean published
        +publish()
        +edit()
        +delete()
    }
    
    class Comment {
        +String content
        +Date commentDate
        +addComment()
        +deleteComment()
    }
    
    class Category {
        +String name
        +String description
        +addArticle()
        +removeArticle()
    }
    
    User "1" -- "*" Article : writes
    User "1" -- "*" Comment : posts
    Article "1" -- "*" Comment : has
    Article "1" -- "*" Category : belongs to
</code></pre>
<h2>State Diagram Example</h2>
<p>State diagrams show the sequence of states an object goes through during its life cycle.</p>
<pre><code>stateDiagram-v2
    [*] --&gt; Draft
    
    Draft --&gt; UnderReview : submit
    UnderReview --&gt; Draft : reject
    UnderReview --&gt; Approved : approve
    Approved --&gt; Published : publish
    Published --&gt; Archived : archive
    Published --&gt; Draft : retract
    
    state Published {
        [*] --&gt; Active
        Active --&gt; Hidden : temporarily hide
        Hidden --&gt; Active : restore
        Active --&gt; [*]
        Hidden --&gt; [*]
    }
    
    Archived --&gt; [*]
</code></pre>
<h2>Pie Chart Example</h2>
<p>Pie charts are ideal for displaying proportions and percentage data.</p>
<pre><code>pie title Website Traffic Sources Analysis
    "Search Engines" : 45.6
    "Direct Access" : 30.1
    "Social Media" : 15.3
    "Referral Links" : 6.4
    "Other Sources" : 2.6
</code></pre>
<h2>Conclusion</h2>
<p>Mermaid is a powerful tool for creating various types of diagrams in Markdown documents. This article demonstrated how to use flowcharts, sequence diagrams, Gantt charts, class diagrams, state diagrams, and pie charts. These diagrams can help you express complex concepts, processes, and data structures more clearly.</p>
<p>To use Mermaid, simply specify the mermaid language in a code block and describe the diagram using concise text syntax. Mermaid will automatically convert these descriptions into beautiful visual diagrams.</p>
<p>Try using Mermaid diagrams in your next technical blog post or project documentation - they will make your content more professional and easier to understand!</p>
]]></content>
    <author>
      <name>Kirifuji Nagisa</name>
    </author>
    <category term="Examples"></category>
  </entry>
</feed>